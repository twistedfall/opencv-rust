use crate::{mod_prelude_sys::*, core};

#[cfg(ocvrs_has_module_alphamat)]
mod alphamat_sys {
	use super::*;

	extern "C" {
		pub fn cv_alphamat_infoFlow_const__InputArrayR_const__InputArrayR_const__OutputArrayR(image: *const c_void, tmap: *const c_void, result: *const c_void, ocvrs_return: *mut Result_void);
	}
}
#[cfg(ocvrs_has_module_alphamat)]
pub use alphamat_sys::*;

#[cfg(ocvrs_has_module_aruco)]
mod aruco_sys {
	use super::*;

	extern "C" {
		pub fn cv_aruco_calibrateCameraAruco_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_PtrLBoardGR_Size_const__InputOutputArrayR_const__InputOutputArrayR(corners: *const c_void, ids: *const c_void, counter: *const c_void, board: *const c_void, image_size: *const core::Size, camera_matrix: *const c_void, dist_coeffs: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_aruco_calibrateCameraAruco_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_PtrLBoardGR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(corners: *const c_void, ids: *const c_void, counter: *const c_void, board: *const c_void, image_size: *const core::Size, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, std_deviations_intrinsics: *const c_void, std_deviations_extrinsics: *const c_void, per_view_errors: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_aruco_calibrateCameraAruco_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_PtrLBoardGR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_const_TermCriteriaR(corners: *const c_void, ids: *const c_void, counter: *const c_void, board: *const c_void, image_size: *const core::Size, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, std_deviations_intrinsics: *const c_void, std_deviations_extrinsics: *const c_void, per_view_errors: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_aruco_calibrateCameraAruco_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_PtrLBoardGR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_int_const_TermCriteriaR(corners: *const c_void, ids: *const c_void, counter: *const c_void, board: *const c_void, image_size: *const core::Size, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_aruco_calibrateCameraCharuco_const__InputArrayR_const__InputArrayR_const_PtrLCharucoBoardGR_Size_const__InputOutputArrayR_const__InputOutputArrayR(charuco_corners: *const c_void, charuco_ids: *const c_void, board: *const c_void, image_size: *const core::Size, camera_matrix: *const c_void, dist_coeffs: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_aruco_calibrateCameraCharuco_const__InputArrayR_const__InputArrayR_const_PtrLCharucoBoardGR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(charuco_corners: *const c_void, charuco_ids: *const c_void, board: *const c_void, image_size: *const core::Size, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, std_deviations_intrinsics: *const c_void, std_deviations_extrinsics: *const c_void, per_view_errors: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_aruco_calibrateCameraCharuco_const__InputArrayR_const__InputArrayR_const_PtrLCharucoBoardGR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_const_TermCriteriaR(charuco_corners: *const c_void, charuco_ids: *const c_void, board: *const c_void, image_size: *const core::Size, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, std_deviations_intrinsics: *const c_void, std_deviations_extrinsics: *const c_void, per_view_errors: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_aruco_calibrateCameraCharuco_const__InputArrayR_const__InputArrayR_const_PtrLCharucoBoardGR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_int_const_TermCriteriaR(charuco_corners: *const c_void, charuco_ids: *const c_void, board: *const c_void, image_size: *const core::Size, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_aruco_detectCharucoDiamond_const__InputArrayR_const__InputArrayR_const__InputArrayR_float_const__OutputArrayR_const__OutputArrayR(image: *const c_void, marker_corners: *const c_void, marker_ids: *const c_void, square_marker_length_rate: f32, diamond_corners: *const c_void, diamond_ids: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_detectCharucoDiamond_const__InputArrayR_const__InputArrayR_const__InputArrayR_float_const__OutputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_PtrLDictionaryG(image: *const c_void, marker_corners: *const c_void, marker_ids: *const c_void, square_marker_length_rate: f32, diamond_corners: *const c_void, diamond_ids: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, dictionary: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_detectMarkers_const__InputArrayR_const_PtrLDictionaryGR_const__OutputArrayR_const__OutputArrayR(image: *const c_void, dictionary: *const c_void, corners: *const c_void, ids: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_detectMarkers_const__InputArrayR_const_PtrLDictionaryGR_const__OutputArrayR_const__OutputArrayR_const_PtrLDetectorParametersGR_const__OutputArrayR(image: *const c_void, dictionary: *const c_void, corners: *const c_void, ids: *const c_void, parameters: *const c_void, rejected_img_points: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_drawCharucoDiamond_const_PtrLDictionaryGR_Vec4i_int_int_const__OutputArrayR(dictionary: *const c_void, ids: *const core::Vec4i, square_length: i32, marker_length: i32, img: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_drawCharucoDiamond_const_PtrLDictionaryGR_Vec4i_int_int_const__OutputArrayR_int_int(dictionary: *const c_void, ids: *const core::Vec4i, square_length: i32, marker_length: i32, img: *const c_void, margin_size: i32, border_bits: i32, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_drawPlanarBoard_const_PtrLBoardGR_Size_const__OutputArrayR_int_int(board: *const c_void, out_size: *const core::Size, img: *const c_void, margin_size: i32, border_bits: i32, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_estimatePoseBoard_const__InputArrayR_const__InputArrayR_const_PtrLBoardGR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(corners: *const c_void, ids: *const c_void, board: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_aruco_estimatePoseBoard_const__InputArrayR_const__InputArrayR_const_PtrLBoardGR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_bool(corners: *const c_void, ids: *const c_void, board: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, use_extrinsic_guess: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_aruco_estimatePoseCharucoBoard_const__InputArrayR_const__InputArrayR_const_PtrLCharucoBoardGR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(charuco_corners: *const c_void, charuco_ids: *const c_void, board: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_estimatePoseCharucoBoard_const__InputArrayR_const__InputArrayR_const_PtrLCharucoBoardGR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_bool(charuco_corners: *const c_void, charuco_ids: *const c_void, board: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, use_extrinsic_guess: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_estimatePoseSingleMarkers_const__InputArrayR_float_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(corners: *const c_void, marker_length: f32, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_estimatePoseSingleMarkers_const__InputArrayR_float_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const_PtrLEstimateParametersGR(corners: *const c_void, marker_length: f32, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, obj_points: *const c_void, estimate_parameters: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_getBoardObjectAndImagePoints_const_PtrLBoardGR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(board: *const c_void, detected_corners: *const c_void, detected_ids: *const c_void, obj_points: *const c_void, img_points: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_interpolateCornersCharuco_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_PtrLCharucoBoardGR_const__OutputArrayR_const__OutputArrayR(marker_corners: *const c_void, marker_ids: *const c_void, image: *const c_void, board: *const c_void, charuco_corners: *const c_void, charuco_ids: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_aruco_interpolateCornersCharuco_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_PtrLCharucoBoardGR_const__OutputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_int(marker_corners: *const c_void, marker_ids: *const c_void, image: *const c_void, board: *const c_void, charuco_corners: *const c_void, charuco_ids: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, min_markers: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_aruco_refineDetectedMarkers_const__InputArrayR_const_PtrLBoardGR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(image: *const c_void, board: *const c_void, detected_corners: *const c_void, detected_ids: *const c_void, rejected_corners: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_refineDetectedMarkers_const__InputArrayR_const_PtrLBoardGR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR_float_float_bool_const__OutputArrayR_const_PtrLDetectorParametersGR(image: *const c_void, board: *const c_void, detected_corners: *const c_void, detected_ids: *const c_void, rejected_corners: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, min_rep_distance: f32, error_correction_rate: f32, check_all_orders: bool, recovered_idxs: *const c_void, parameters: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_testCharucoCornersCollinear_const_PtrLCharucoBoardGR_const__InputArrayR(board: *const c_void, charuco_ids: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_EstimateParameters_EstimateParameters(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_EstimateParameters_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_EstimateParameters_propPattern_const(instance: *const c_void, ocvrs_return: *mut crate::aruco::PatternPositionType);
		pub fn cv_aruco_EstimateParameters_propPattern_PatternPositionType(instance: *mut c_void, val: crate::aruco::PatternPositionType);
		pub fn cv_aruco_EstimateParameters_propUseExtrinsicGuess_const(instance: *const c_void) -> bool;
		pub fn cv_aruco_EstimateParameters_propUseExtrinsicGuess_bool(instance: *mut c_void, val: bool);
		pub fn cv_aruco_EstimateParameters_propSolvePnPMethod_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_EstimateParameters_propSolvePnPMethod_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_EstimateParameters_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_aruco_EstimateParametersG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_EstimateParametersG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_EstimateParametersG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_aruco_EstimateParametersG_new_const_EstimateParameters(val: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_aruco)]
pub use aruco_sys::*;

#[cfg(ocvrs_has_module_bgsegm)]
mod bgsegm_sys {
	use super::*;

	extern "C" {
		pub fn cv_bgsegm_createBackgroundSubtractorCNT(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bgsegm_createBackgroundSubtractorCNT_int_bool_int_bool(min_pixel_stability: i32, use_history: bool, max_pixel_stability: i32, is_parallel: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bgsegm_createBackgroundSubtractorGMG(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bgsegm_createBackgroundSubtractorGMG_int_double(initialization_frames: i32, decision_threshold: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bgsegm_createBackgroundSubtractorGSOC(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bgsegm_createBackgroundSubtractorGSOC_int_int_float_float_int_float_float_float_float_float_float(mc: i32, n_samples: i32, replace_rate: f32, propagation_rate: f32, hits_threshold: i32, alpha: f32, beta: f32, blinking_supression_decay: f32, blinking_supression_multiplier: f32, noise_removal_threshold_fac_bg: f32, noise_removal_threshold_fac_fg: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bgsegm_createBackgroundSubtractorLSBP(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bgsegm_createBackgroundSubtractorLSBP_int_int_int_float_float_float_float_float_float_float_float_int_int(mc: i32, n_samples: i32, lsbp_radius: i32, tlower: f32, tupper: f32, tinc: f32, tdec: f32, rscale: f32, rincdec: f32, noise_removal_threshold_fac_bg: f32, noise_removal_threshold_fac_fg: f32, lsb_pthreshold: i32, min_count: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bgsegm_createBackgroundSubtractorMOG(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bgsegm_createBackgroundSubtractorMOG_int_int_double_double(history: i32, nmixtures: i32, background_ratio: f64, noise_sigma: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bgsegm_createSyntheticSequenceGenerator_const__InputArrayR_const__InputArrayR(background: *const c_void, object: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bgsegm_createSyntheticSequenceGenerator_const__InputArrayR_const__InputArrayR_double_double_double_double(background: *const c_void, object: *const c_void, amplitude: f64, wavelength: f64, wavespeed: f64, objspeed: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bgsegm_BackgroundSubtractorCNT_apply_const__InputArrayR_const__OutputArrayR_double(instance: *mut c_void, image: *const c_void, fgmask: *const c_void, learning_rate: f64, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorCNT_apply_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, fgmask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorCNT_getBackgroundImage_const_const__OutputArrayR(instance: *const c_void, background_image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorCNT_getMinPixelStability_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_bgsegm_BackgroundSubtractorCNT_setMinPixelStability_int(instance: *mut c_void, value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorCNT_getMaxPixelStability_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_bgsegm_BackgroundSubtractorCNT_setMaxPixelStability_int(instance: *mut c_void, value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorCNT_getUseHistory_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_bgsegm_BackgroundSubtractorCNT_setUseHistory_bool(instance: *mut c_void, value: bool, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorCNT_getIsParallel_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_bgsegm_BackgroundSubtractorCNT_setIsParallel_bool(instance: *mut c_void, value: bool, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorCNT_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_bgsegm_BackgroundSubtractorCNT_to_BackgroundSubtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_bgsegm_BackgroundSubtractorCNT_delete(instance: *mut c_void);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getMaxFeatures_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setMaxFeatures_int(instance: *mut c_void, max_features: i32, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getDefaultLearningRate_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setDefaultLearningRate_double(instance: *mut c_void, lr: f64, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getNumFrames_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setNumFrames_int(instance: *mut c_void, nframes: i32, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getQuantizationLevels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setQuantizationLevels_int(instance: *mut c_void, nlevels: i32, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getBackgroundPrior_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setBackgroundPrior_double(instance: *mut c_void, bgprior: f64, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getSmoothingRadius_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setSmoothingRadius_int(instance: *mut c_void, radius: i32, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getDecisionThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setDecisionThreshold_double(instance: *mut c_void, thresh: f64, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getUpdateBackgroundModel_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setUpdateBackgroundModel_bool(instance: *mut c_void, update: bool, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getMinVal_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setMinVal_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_getMaxVal_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_setMaxVal_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorGMG_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_to_BackgroundSubtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_bgsegm_BackgroundSubtractorGMG_delete(instance: *mut c_void);
		pub fn cv_bgsegm_BackgroundSubtractorGSOC_apply_const__InputArrayR_const__OutputArrayR_double(instance: *mut c_void, image: *const c_void, fgmask: *const c_void, learning_rate: f64, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorGSOC_apply_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, fgmask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorGSOC_getBackgroundImage_const_const__OutputArrayR(instance: *const c_void, background_image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorGSOC_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_bgsegm_BackgroundSubtractorGSOC_to_BackgroundSubtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_bgsegm_BackgroundSubtractorGSOC_delete(instance: *mut c_void);
		pub fn cv_bgsegm_BackgroundSubtractorLSBP_apply_const__InputArrayR_const__OutputArrayR_double(instance: *mut c_void, image: *const c_void, fgmask: *const c_void, learning_rate: f64, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorLSBP_apply_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, fgmask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorLSBP_getBackgroundImage_const_const__OutputArrayR(instance: *const c_void, background_image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorLSBP_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_bgsegm_BackgroundSubtractorLSBP_to_BackgroundSubtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_bgsegm_BackgroundSubtractorLSBP_delete(instance: *mut c_void);
		pub fn cv_bgsegm_BackgroundSubtractorLSBPDesc_calcLocalSVDValues_const__OutputArrayR_const_MatR(local_svd_values: *const c_void, frame: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorLSBPDesc_computeFromLocalSVDValues_const__OutputArrayR_const_MatR_const_Point2iX(desc: *const c_void, local_svd_values: *const c_void, lsbp_sample_points: *const core::Point2i, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorLSBPDesc_compute_const__OutputArrayR_const_MatR_const_Point2iX(desc: *const c_void, frame: *const c_void, lsbp_sample_points: *const core::Point2i, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorLSBPDesc_delete(instance: *mut c_void);
		pub fn cv_bgsegm_BackgroundSubtractorMOG_getHistory_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_bgsegm_BackgroundSubtractorMOG_setHistory_int(instance: *mut c_void, nframes: i32, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorMOG_getNMixtures_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_bgsegm_BackgroundSubtractorMOG_setNMixtures_int(instance: *mut c_void, nmix: i32, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorMOG_getBackgroundRatio_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_bgsegm_BackgroundSubtractorMOG_setBackgroundRatio_double(instance: *mut c_void, background_ratio: f64, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorMOG_getNoiseSigma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_bgsegm_BackgroundSubtractorMOG_setNoiseSigma_double(instance: *mut c_void, noise_sigma: f64, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_BackgroundSubtractorMOG_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_bgsegm_BackgroundSubtractorMOG_to_BackgroundSubtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_bgsegm_BackgroundSubtractorMOG_delete(instance: *mut c_void);
		pub fn cv_bgsegm_SyntheticSequenceGenerator_SyntheticSequenceGenerator_const__InputArrayR_const__InputArrayR_double_double_double_double(background: *const c_void, object: *const c_void, amplitude: f64, wavelength: f64, wavespeed: f64, objspeed: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bgsegm_SyntheticSequenceGenerator_getNextFrame_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, frame: *const c_void, gt_mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bgsegm_SyntheticSequenceGenerator_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_bgsegm_SyntheticSequenceGenerator_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorCNTG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorCNTG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorCNTG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorCNTG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorCNTG_to_PtrOfBackgroundSubtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorGMGG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorGMGG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorGMGG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorGMGG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorGMGG_to_PtrOfBackgroundSubtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorGSOCG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorGSOCG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorGSOCG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorGSOCG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorGSOCG_to_PtrOfBackgroundSubtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorLSBPG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorLSBPG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorLSBPG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorLSBPG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorLSBPG_to_PtrOfBackgroundSubtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorMOGG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorMOGG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorMOGG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorMOGG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_BackgroundSubtractorMOGG_to_PtrOfBackgroundSubtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_SyntheticSequenceGeneratorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_SyntheticSequenceGeneratorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_SyntheticSequenceGeneratorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_bgsegm_SyntheticSequenceGeneratorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bgsegm_SyntheticSequenceGeneratorG_new_const_SyntheticSequenceGenerator(val: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_bgsegm)]
pub use bgsegm_sys::*;

#[cfg(ocvrs_has_module_bioinspired)]
mod bioinspired_sys {
	use super::*;

	extern "C" {
		pub fn cv_bioinspired_Retina_getInputSize(instance: *mut c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_bioinspired_Retina_getOutputSize(instance: *mut c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_bioinspired_Retina_setup_String_const_bool(instance: *mut c_void, retina_parameter_file: *mut c_char, apply_default_setup_on_failure: bool, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_setup(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_setup_FileStorageR_const_bool(instance: *mut c_void, fs: *mut c_void, apply_default_setup_on_failure: bool, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_setup_FileStorageR(instance: *mut c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_setup_RetinaParameters(instance: *mut c_void, new_parameters: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_getParameters(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bioinspired_Retina_printSetup(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bioinspired_Retina_write_const_String(instance: *const c_void, fs: *mut c_char, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_setupOPLandIPLParvoChannel_const_bool_const_bool_const_float_const_float_const_float_const_float_const_float_const_float_const_float(instance: *mut c_void, color_mode: bool, normalise_output: bool, photoreceptors_local_adaptation_sensitivity: f32, photoreceptors_temporal_constant: f32, photoreceptors_spatial_constant: f32, horizontal_cells_gain: f32, hcells_temporal_constant: f32, hcells_spatial_constant: f32, ganglion_cells_sensitivity: f32, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_setupOPLandIPLParvoChannel(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_setupIPLMagnoChannel_const_bool_const_float_const_float_const_float_const_float_const_float_const_float_const_float(instance: *mut c_void, normalise_output: bool, parasol_cells_beta: f32, parasol_cells_tau: f32, parasol_cells_k: f32, amacrin_cells_temporal_cut_frequency: f32, v0_compression_parameter: f32, local_adaptintegration_tau: f32, local_adaptintegration_k: f32, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_setupIPLMagnoChannel(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_run_const__InputArrayR(instance: *mut c_void, input_image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_applyFastToneMapping_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, input_image: *const c_void, output_tone_mapped_image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_getParvo_const__OutputArrayR(instance: *mut c_void, retina_output_parvo: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_getParvoRAW_const__OutputArrayR(instance: *mut c_void, retina_output_parvo: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_getMagno_const__OutputArrayR(instance: *mut c_void, retina_output_magno: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_getMagnoRAW_const__OutputArrayR(instance: *mut c_void, retina_output_magno: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_getMagnoRAW_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bioinspired_Retina_getParvoRAW_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bioinspired_Retina_setColorSaturation_const_bool_const_float(instance: *mut c_void, saturate_colors: bool, color_saturation_value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_setColorSaturation(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_clearBuffers(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_activateMovingContoursProcessing_const_bool(instance: *mut c_void, activate: bool, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_activateContoursProcessing_const_bool(instance: *mut c_void, activate: bool, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_Retina_create_Size(input_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bioinspired_Retina_create_Size_const_bool_int_const_bool_const_float_const_float(input_size: *const core::Size, color_mode: bool, color_sampling_method: i32, use_retina_log_sampling: bool, reduction_factor: f32, sampling_strength: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bioinspired_Retina_create_Size_const_bool(input_size: *const core::Size, color_mode: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bioinspired_Retina_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_bioinspired_Retina_delete(instance: *mut c_void);
		pub fn cv_bioinspired_RetinaFastToneMapping_applyFastToneMapping_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, input_image: *const c_void, output_tone_mapped_image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_RetinaFastToneMapping_setup_const_float_const_float_const_float(instance: *mut c_void, photoreceptors_neighborhood_radius: f32, ganglioncells_neighborhood_radius: f32, mean_luminance_modulator_k: f32, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_RetinaFastToneMapping_setup(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_RetinaFastToneMapping_create_Size(input_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bioinspired_RetinaFastToneMapping_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_bioinspired_RetinaFastToneMapping_delete(instance: *mut c_void);
		pub fn cv_bioinspired_RetinaParameters_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_bioinspired_RetinaParameters_defaultNew_const() -> *mut c_void;
		pub fn cv_bioinspired_RetinaParameters_propOPLandIplParvo_const(instance: *const c_void, ocvrs_return: *mut crate::bioinspired::RetinaParameters_OPLandIplParvoParameters);
		pub fn cv_bioinspired_RetinaParameters_propOPLandIplParvo_OPLandIplParvoParameters(instance: *mut c_void, val: *const crate::bioinspired::RetinaParameters_OPLandIplParvoParameters);
		pub fn cv_bioinspired_RetinaParameters_propIplMagno_const(instance: *const c_void, ocvrs_return: *mut crate::bioinspired::RetinaParameters_IplMagnoParameters);
		pub fn cv_bioinspired_RetinaParameters_propIplMagno_IplMagnoParameters(instance: *mut c_void, val: *const crate::bioinspired::RetinaParameters_IplMagnoParameters);
		pub fn cv_bioinspired_RetinaParameters_delete(instance: *mut c_void);
		pub fn cv_bioinspired_RetinaParameters_IplMagnoParameters_IplMagnoParameters(ocvrs_return: *mut Result<crate::bioinspired::RetinaParameters_IplMagnoParameters>);
		pub fn cv_bioinspired_RetinaParameters_OPLandIplParvoParameters_OPLandIplParvoParameters(ocvrs_return: *mut Result<crate::bioinspired::RetinaParameters_OPLandIplParvoParameters>);
		pub fn cv_bioinspired_SegmentationParameters_SegmentationParameters(ocvrs_return: *mut Result<crate::bioinspired::SegmentationParameters>);
		pub fn cv_bioinspired_TransientAreasSegmentationModule_getSize(instance: *mut c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_bioinspired_TransientAreasSegmentationModule_setup_String_const_bool(instance: *mut c_void, segmentation_parameter_file: *mut c_char, apply_default_setup_on_failure: bool, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_TransientAreasSegmentationModule_setup(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_TransientAreasSegmentationModule_setup_FileStorageR_const_bool(instance: *mut c_void, fs: *mut c_void, apply_default_setup_on_failure: bool, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_TransientAreasSegmentationModule_setup_FileStorageR(instance: *mut c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_TransientAreasSegmentationModule_setup_SegmentationParameters(instance: *mut c_void, new_parameters: *const crate::bioinspired::SegmentationParameters, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_TransientAreasSegmentationModule_getParameters(instance: *mut c_void, ocvrs_return: *mut Result<crate::bioinspired::SegmentationParameters>);
		pub fn cv_bioinspired_TransientAreasSegmentationModule_printSetup(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bioinspired_TransientAreasSegmentationModule_write_const_String(instance: *const c_void, fs: *mut c_char, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_TransientAreasSegmentationModule_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_TransientAreasSegmentationModule_run_const__InputArrayR_const_int(instance: *mut c_void, input_to_segment: *const c_void, channel_index: i32, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_TransientAreasSegmentationModule_run_const__InputArrayR(instance: *mut c_void, input_to_segment: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_TransientAreasSegmentationModule_getSegmentationPicture_const__OutputArrayR(instance: *mut c_void, transient_areas: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_TransientAreasSegmentationModule_clearAllBuffers(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bioinspired_TransientAreasSegmentationModule_create_Size(input_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_bioinspired_TransientAreasSegmentationModule_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_bioinspired_TransientAreasSegmentationModule_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_bioinspired_RetinaG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bioinspired_RetinaG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bioinspired_RetinaG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_bioinspired_RetinaG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bioinspired_RetinaFastToneMappingG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bioinspired_RetinaFastToneMappingG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bioinspired_RetinaFastToneMappingG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_bioinspired_RetinaFastToneMappingG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bioinspired_TransientAreasSegmentationModuleG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bioinspired_TransientAreasSegmentationModuleG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_bioinspired_TransientAreasSegmentationModuleG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_bioinspired_TransientAreasSegmentationModuleG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_bioinspired)]
pub use bioinspired_sys::*;

#[cfg(ocvrs_has_module_calib3d)]
mod calib3d_sys {
	use super::*;

	extern "C" {
		pub fn cv_RQDecomp3x3_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, mtx_r: *const c_void, mtx_q: *const c_void, ocvrs_return: *mut Result<core::Vec3d>);
		pub fn cv_RQDecomp3x3_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, mtx_r: *const c_void, mtx_q: *const c_void, qx: *const c_void, qy: *const c_void, qz: *const c_void, ocvrs_return: *mut Result<core::Vec3d>);
		pub fn cv_Rodrigues_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Rodrigues_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, jacobian: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_calibrateCameraRO_const__InputArrayR_const__InputArrayR_Size_int_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, i_fixed_point: i32, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, new_obj_points: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_calibrateCameraRO_const__InputArrayR_const__InputArrayR_Size_int_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, i_fixed_point: i32, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, new_obj_points: *const c_void, std_deviations_intrinsics: *const c_void, std_deviations_extrinsics: *const c_void, std_deviations_obj_points: *const c_void, per_view_errors: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_calibrateCameraRO_const__InputArrayR_const__InputArrayR_Size_int_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, i_fixed_point: i32, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, new_obj_points: *const c_void, std_deviations_intrinsics: *const c_void, std_deviations_extrinsics: *const c_void, std_deviations_obj_points: *const c_void, per_view_errors: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_calibrateCameraRO_const__InputArrayR_const__InputArrayR_Size_int_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, i_fixed_point: i32, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, new_obj_points: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_calibrateCamera_const__InputArrayR_const__InputArrayR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_calibrateCamera_const__InputArrayR_const__InputArrayR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, std_deviations_intrinsics: *const c_void, std_deviations_extrinsics: *const c_void, per_view_errors: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_calibrateCamera_const__InputArrayR_const__InputArrayR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, std_deviations_intrinsics: *const c_void, std_deviations_extrinsics: *const c_void, per_view_errors: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_calibrateCamera_const__InputArrayR_const__InputArrayR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_calibrateHandEye_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(r_gripper2base: *const c_void, t_gripper2base: *const c_void, r_target2cam: *const c_void, t_target2cam: *const c_void, r_cam2gripper: *const c_void, t_cam2gripper: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_calibrateHandEye_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_HandEyeCalibrationMethod(r_gripper2base: *const c_void, t_gripper2base: *const c_void, r_target2cam: *const c_void, t_target2cam: *const c_void, r_cam2gripper: *const c_void, t_cam2gripper: *const c_void, method: crate::calib3d::HandEyeCalibrationMethod, ocvrs_return: *mut Result_void);
		pub fn cv_calibrateRobotWorldHandEye_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(r_world2cam: *const c_void, t_world2cam: *const c_void, r_base2gripper: *const c_void, t_base2gripper: *const c_void, r_base2world: *const c_void, t_base2world: *const c_void, r_gripper2cam: *const c_void, t_gripper2cam: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_calibrateRobotWorldHandEye_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_RobotWorldHandEyeCalibrationMethod(r_world2cam: *const c_void, t_world2cam: *const c_void, r_base2gripper: *const c_void, t_base2gripper: *const c_void, r_base2world: *const c_void, t_base2world: *const c_void, r_gripper2cam: *const c_void, t_gripper2cam: *const c_void, method: crate::calib3d::RobotWorldHandEyeCalibrationMethod, ocvrs_return: *mut Result_void);
		pub fn cv_calibrationMatrixValues_const__InputArrayR_Size_double_double_doubleR_doubleR_doubleR_Point2dR_doubleR(camera_matrix: *const c_void, image_size: *const core::Size, aperture_width: f64, aperture_height: f64, fovx: *mut f64, fovy: *mut f64, focal_length: *mut f64, principal_point: *mut core::Point2d, aspect_ratio: *mut f64, ocvrs_return: *mut Result_void);
		pub fn cv_checkChessboard_const__InputArrayR_Size(img: *const c_void, size: *const core::Size, ocvrs_return: *mut Result<bool>);
		pub fn cv_composeRT_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(rvec1: *const c_void, tvec1: *const c_void, rvec2: *const c_void, tvec2: *const c_void, rvec3: *const c_void, tvec3: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_composeRT_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(rvec1: *const c_void, tvec1: *const c_void, rvec2: *const c_void, tvec2: *const c_void, rvec3: *const c_void, tvec3: *const c_void, dr3dr1: *const c_void, dr3dt1: *const c_void, dr3dr2: *const c_void, dr3dt2: *const c_void, dt3dr1: *const c_void, dt3dt1: *const c_void, dt3dr2: *const c_void, dt3dt2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_computeCorrespondEpilines_const__InputArrayR_int_const__InputArrayR_const__OutputArrayR(points: *const c_void, which_image: i32, f: *const c_void, lines: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_convertPointsFromHomogeneous_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_convertPointsHomogeneous_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_convertPointsToHomogeneous_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_correctMatches_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(f: *const c_void, points1: *const c_void, points2: *const c_void, new_points1: *const c_void, new_points2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_decomposeEssentialMat_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(e: *const c_void, r1: *const c_void, r2: *const c_void, t: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_decomposeHomographyMat_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(h: *const c_void, k: *const c_void, rotations: *const c_void, translations: *const c_void, normals: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_decomposeProjectionMatrix_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(proj_matrix: *const c_void, camera_matrix: *const c_void, rot_matrix: *const c_void, trans_vect: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_decomposeProjectionMatrix_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(proj_matrix: *const c_void, camera_matrix: *const c_void, rot_matrix: *const c_void, trans_vect: *const c_void, rot_matrix_x: *const c_void, rot_matrix_y: *const c_void, rot_matrix_z: *const c_void, euler_angles: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_drawChessboardCorners_const__InputOutputArrayR_Size_const__InputArrayR_bool(image: *const c_void, pattern_size: *const core::Size, corners: *const c_void, pattern_was_found: bool, ocvrs_return: *mut Result_void);
		pub fn cv_drawFrameAxes_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_float(image: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, length: f32, ocvrs_return: *mut Result_void);
		pub fn cv_drawFrameAxes_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_float_int(image: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, length: f32, thickness: i32, ocvrs_return: *mut Result_void);
		pub fn cv_estimateAffine2D_const__InputArrayR_const__InputArrayR(from: *const c_void, to: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_estimateAffine2D_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const_UsacParamsR(pts1: *const c_void, pts2: *const c_void, inliers: *const c_void, params: *const crate::calib3d::UsacParams, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_estimateAffine2D_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_double_size_t_double_size_t(from: *const c_void, to: *const c_void, inliers: *const c_void, method: i32, ransac_reproj_threshold: f64, max_iters: size_t, confidence: f64, refine_iters: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_estimateAffine3D_const__InputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_estimateAffine3D_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, out: *const c_void, inliers: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_estimateAffine3D_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double_double(src: *const c_void, dst: *const c_void, out: *const c_void, inliers: *const c_void, ransac_threshold: f64, confidence: f64, ocvrs_return: *mut Result<i32>);
		pub fn cv_estimateAffine3D_const__InputArrayR_const__InputArrayR_doubleX_bool(src: *const c_void, dst: *const c_void, scale: *mut f64, force_rotation: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_estimateAffinePartial2D_const__InputArrayR_const__InputArrayR(from: *const c_void, to: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_estimateAffinePartial2D_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_double_size_t_double_size_t(from: *const c_void, to: *const c_void, inliers: *const c_void, method: i32, ransac_reproj_threshold: f64, max_iters: size_t, confidence: f64, refine_iters: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_estimateChessboardSharpness_const__InputArrayR_Size_const__InputArrayR(image: *const c_void, pattern_size: *const core::Size, corners: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_estimateChessboardSharpness_const__InputArrayR_Size_const__InputArrayR_float_bool_const__OutputArrayR(image: *const c_void, pattern_size: *const core::Size, corners: *const c_void, rise_distance: f32, vertical: bool, sharpness: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_estimateTranslation3D_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, out: *const c_void, inliers: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_estimateTranslation3D_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double_double(src: *const c_void, dst: *const c_void, out: *const c_void, inliers: *const c_void, ransac_threshold: f64, confidence: f64, ocvrs_return: *mut Result<i32>);
		pub fn cv_filterHomographyDecompByVisibleRefpoints_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(rotations: *const c_void, normals: *const c_void, before_points: *const c_void, after_points: *const c_void, possible_solutions: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_filterHomographyDecompByVisibleRefpoints_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR(rotations: *const c_void, normals: *const c_void, before_points: *const c_void, after_points: *const c_void, possible_solutions: *const c_void, points_mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_filterSpeckles_const__InputOutputArrayR_double_int_double(img: *const c_void, new_val: f64, max_speckle_size: i32, max_diff: f64, ocvrs_return: *mut Result_void);
		pub fn cv_filterSpeckles_const__InputOutputArrayR_double_int_double_const__InputOutputArrayR(img: *const c_void, new_val: f64, max_speckle_size: i32, max_diff: f64, buf: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_find4QuadCornerSubpix_const__InputArrayR_const__InputOutputArrayR_Size(img: *const c_void, corners: *const c_void, region_size: *const core::Size, ocvrs_return: *mut Result<bool>);
		pub fn cv_findChessboardCornersSB_const__InputArrayR_Size_const__OutputArrayR(image: *const c_void, pattern_size: *const core::Size, corners: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_findChessboardCornersSB_const__InputArrayR_Size_const__OutputArrayR_int(image: *const c_void, pattern_size: *const core::Size, corners: *const c_void, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_findChessboardCornersSB_const__InputArrayR_Size_const__OutputArrayR_int_const__OutputArrayR(image: *const c_void, pattern_size: *const core::Size, corners: *const c_void, flags: i32, meta: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_findChessboardCorners_const__InputArrayR_Size_const__OutputArrayR(image: *const c_void, pattern_size: *const core::Size, corners: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_findChessboardCorners_const__InputArrayR_Size_const__OutputArrayR_int(image: *const c_void, pattern_size: *const core::Size, corners: *const c_void, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_findCirclesGrid_const__InputArrayR_Size_const__OutputArrayR(image: *const c_void, pattern_size: *const core::Size, centers: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_findCirclesGrid_const__InputArrayR_Size_const__OutputArrayR_int_const_PtrLFeature2DGR(image: *const c_void, pattern_size: *const core::Size, centers: *const c_void, flags: i32, blob_detector: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_findCirclesGrid_const__InputArrayR_Size_const__OutputArrayR_int_const_PtrLFeature2DGR_const_CirclesGridFinderParametersR(image: *const c_void, pattern_size: *const core::Size, centers: *const c_void, flags: i32, blob_detector: *const c_void, parameters: *const crate::calib3d::CirclesGridFinderParameters, ocvrs_return: *mut Result<bool>);
		pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR(points1: *const c_void, points2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_const__InputArrayR(points1: *const c_void, points2: *const c_void, camera_matrix: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(points1: *const c_void, points2: *const c_void, camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const_UsacParamsR(points1: *const c_void, points2: *const c_void, camera_matrix1: *const c_void, camera_matrix2: *const c_void, dist_coeff1: *const c_void, dist_coeff2: *const c_void, mask: *const c_void, params: *const crate::calib3d::UsacParams, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_double_double_const__OutputArrayR(points1: *const c_void, points2: *const c_void, camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, method: i32, prob: f64, threshold: f64, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_double_double_const__OutputArrayR(points1: *const c_void, points2: *const c_void, camera_matrix: *const c_void, method: i32, prob: f64, threshold: f64, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_double_double_int_const__OutputArrayR(points1: *const c_void, points2: *const c_void, camera_matrix: *const c_void, method: i32, prob: f64, threshold: f64, max_iters: i32, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_double_Point2d_int_double_double_const__OutputArrayR(points1: *const c_void, points2: *const c_void, focal: f64, pp: *const core::Point2d, method: i32, prob: f64, threshold: f64, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findEssentialMat_const__InputArrayR_const__InputArrayR_double_Point2d_int_double_double_int_const__OutputArrayR(points1: *const c_void, points2: *const c_void, focal: f64, pp: *const core::Point2d, method: i32, prob: f64, threshold: f64, max_iters: i32, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findFundamentalMat_const__InputArrayR_const__InputArrayR(points1: *const c_void, points2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findFundamentalMat_const__InputArrayR_const__InputArrayR_const__OutputArrayR(points1: *const c_void, points2: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findFundamentalMat_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const_UsacParamsR(points1: *const c_void, points2: *const c_void, mask: *const c_void, params: *const crate::calib3d::UsacParams, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findFundamentalMat_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_double_double(points1: *const c_void, points2: *const c_void, mask: *const c_void, method: i32, ransac_reproj_threshold: f64, confidence: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findFundamentalMat_const__InputArrayR_const__InputArrayR_int_double_double_const__OutputArrayR(points1: *const c_void, points2: *const c_void, method: i32, ransac_reproj_threshold: f64, confidence: f64, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findFundamentalMat_const__InputArrayR_const__InputArrayR_int_double_double_int(points1: *const c_void, points2: *const c_void, method: i32, ransac_reproj_threshold: f64, confidence: f64, max_iters: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findFundamentalMat_const__InputArrayR_const__InputArrayR_int_double_double_int_const__OutputArrayR(points1: *const c_void, points2: *const c_void, method: i32, ransac_reproj_threshold: f64, confidence: f64, max_iters: i32, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findHomography_const__InputArrayR_const__InputArrayR(src_points: *const c_void, dst_points: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findHomography_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src_points: *const c_void, dst_points: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findHomography_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const_UsacParamsR(src_points: *const c_void, dst_points: *const c_void, mask: *const c_void, params: *const crate::calib3d::UsacParams, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findHomography_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_double(src_points: *const c_void, dst_points: *const c_void, mask: *const c_void, method: i32, ransac_reproj_threshold: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findHomography_const__InputArrayR_const__InputArrayR_int_double_const__OutputArrayR_const_int_const_double(src_points: *const c_void, dst_points: *const c_void, method: i32, ransac_reproj_threshold: f64, mask: *const c_void, max_iters: i32, confidence: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_fisheye_calibrate_const__InputArrayR_const__InputArrayR_const_SizeR_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, k: *const c_void, d: *const c_void, rvecs: *const c_void, tvecs: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_fisheye_calibrate_const__InputArrayR_const__InputArrayR_const_SizeR_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, k: *const c_void, d: *const c_void, rvecs: *const c_void, tvecs: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_fisheye_distortPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR(undistorted: *const c_void, distorted: *const c_void, k: *const c_void, d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_distortPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_double(undistorted: *const c_void, distorted: *const c_void, k: *const c_void, d: *const c_void, alpha: f64, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_estimateNewCameraMatrixForUndistortRectify_const__InputArrayR_const__InputArrayR_const_SizeR_const__InputArrayR_const__OutputArrayR(k: *const c_void, d: *const c_void, image_size: *const core::Size, r: *const c_void, p: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_estimateNewCameraMatrixForUndistortRectify_const__InputArrayR_const__InputArrayR_const_SizeR_const__InputArrayR_const__OutputArrayR_double_const_SizeR_double(k: *const c_void, d: *const c_void, image_size: *const core::Size, r: *const c_void, p: *const c_void, balance: f64, new_size: *const core::Size, fov_scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_initUndistortRectifyMap_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_SizeR_int_const__OutputArrayR_const__OutputArrayR(k: *const c_void, d: *const c_void, r: *const c_void, p: *const c_void, size: *const core::Size, m1type: i32, map1: *const c_void, map2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_projectPoints_const__InputArrayR_const__OutputArrayR_const_Affine3dR_const__InputArrayR_const__InputArrayR(object_points: *const c_void, image_points: *const c_void, affine: *const core::Affine3d, k: *const c_void, d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_projectPoints_const__InputArrayR_const__OutputArrayR_const_Affine3dR_const__InputArrayR_const__InputArrayR_double_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, affine: *const core::Affine3d, k: *const c_void, d: *const c_void, alpha: f64, jacobian: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_projectPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(object_points: *const c_void, image_points: *const c_void, rvec: *const c_void, tvec: *const c_void, k: *const c_void, d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_projectPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_double_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, rvec: *const c_void, tvec: *const c_void, k: *const c_void, d: *const c_void, alpha: f64, jacobian: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_stereoCalibrate_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_const__OutputArrayR_const__OutputArrayR(object_points: *const c_void, image_points1: *const c_void, image_points2: *const c_void, k1: *const c_void, d1: *const c_void, k2: *const c_void, d2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_fisheye_stereoCalibrate_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(object_points: *const c_void, image_points1: *const c_void, image_points2: *const c_void, k1: *const c_void, d1: *const c_void, k2: *const c_void, d2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, rvecs: *const c_void, tvecs: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_fisheye_stereoCalibrate_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points1: *const c_void, image_points2: *const c_void, k1: *const c_void, d1: *const c_void, k2: *const c_void, d2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, rvecs: *const c_void, tvecs: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_fisheye_stereoCalibrate_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points1: *const c_void, image_points2: *const c_void, k1: *const c_void, d1: *const c_void, k2: *const c_void, d2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_fisheye_stereoRectify_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_SizeR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int(k1: *const c_void, d1: *const c_void, k2: *const c_void, d2: *const c_void, image_size: *const core::Size, r: *const c_void, tvec: *const c_void, r1: *const c_void, r2: *const c_void, p1: *const c_void, p2: *const c_void, q: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_stereoRectify_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_SizeR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_const_SizeR_double_double(k1: *const c_void, d1: *const c_void, k2: *const c_void, d2: *const c_void, image_size: *const core::Size, r: *const c_void, tvec: *const c_void, r1: *const c_void, r2: *const c_void, p1: *const c_void, p2: *const c_void, q: *const c_void, flags: i32, new_image_size: *const core::Size, balance: f64, fov_scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_undistortImage_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR(distorted: *const c_void, undistorted: *const c_void, k: *const c_void, d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_undistortImage_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_SizeR(distorted: *const c_void, undistorted: *const c_void, k: *const c_void, d: *const c_void, knew: *const c_void, new_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_undistortPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR(distorted: *const c_void, undistorted: *const c_void, k: *const c_void, d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_fisheye_undistortPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_TermCriteria(distorted: *const c_void, undistorted: *const c_void, k: *const c_void, d: *const c_void, r: *const c_void, p: *const c_void, criteria: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_getDefaultNewCameraMatrix_const__InputArrayR(camera_matrix: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getDefaultNewCameraMatrix_const__InputArrayR_Size_bool(camera_matrix: *const c_void, imgsize: *const core::Size, center_principal_point: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getOptimalNewCameraMatrix_const__InputArrayR_const__InputArrayR_Size_double(camera_matrix: *const c_void, dist_coeffs: *const c_void, image_size: *const core::Size, alpha: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getOptimalNewCameraMatrix_const__InputArrayR_const__InputArrayR_Size_double_Size_RectX_bool(camera_matrix: *const c_void, dist_coeffs: *const c_void, image_size: *const core::Size, alpha: f64, new_img_size: *const core::Size, valid_pix_roi: *mut core::Rect, center_principal_point: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getValidDisparityROI_Rect_Rect_int_int_int(roi1: *const core::Rect, roi2: *const core::Rect, min_disparity: i32, number_of_disparities: i32, block_size: i32, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_initCameraMatrix2D_const__InputArrayR_const__InputArrayR_Size(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_initCameraMatrix2D_const__InputArrayR_const__InputArrayR_Size_double(object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, aspect_ratio: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_initInverseRectificationMap_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_SizeR_int_const__OutputArrayR_const__OutputArrayR(camera_matrix: *const c_void, dist_coeffs: *const c_void, r: *const c_void, new_camera_matrix: *const c_void, size: *const core::Size, m1type: i32, map1: *const c_void, map2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_initUndistortRectifyMap_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_Size_int_const__OutputArrayR_const__OutputArrayR(camera_matrix: *const c_void, dist_coeffs: *const c_void, r: *const c_void, new_camera_matrix: *const c_void, size: *const core::Size, m1type: i32, map1: *const c_void, map2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_initWideAngleProjMap_const__InputArrayR_const__InputArrayR_Size_int_int_const__OutputArrayR_const__OutputArrayR(camera_matrix: *const c_void, dist_coeffs: *const c_void, image_size: *const core::Size, dest_image_width: i32, m1type: i32, map1: *const c_void, map2: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_initWideAngleProjMap_const__InputArrayR_const__InputArrayR_Size_int_int_const__OutputArrayR_const__OutputArrayR_UndistortTypes_double(camera_matrix: *const c_void, dist_coeffs: *const c_void, image_size: *const core::Size, dest_image_width: i32, m1type: i32, map1: *const c_void, map2: *const c_void, proj_type: crate::calib3d::UndistortTypes, alpha: f64, ocvrs_return: *mut Result<f32>);
		pub fn cv_matMulDeriv_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(a: *const c_void, b: *const c_void, d_a_bd_a: *const c_void, d_a_bd_b: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_projectPoints_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(object_points: *const c_void, rvec: *const c_void, tvec: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, image_points: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_projectPoints_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double(object_points: *const c_void, rvec: *const c_void, tvec: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, image_points: *const c_void, jacobian: *const c_void, aspect_ratio: f64, ocvrs_return: *mut Result_void);
		pub fn cv_recoverPose_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(points1: *const c_void, points2: *const c_void, camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, e: *const c_void, r: *const c_void, t: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_recoverPose_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_double_double_const__InputOutputArrayR(points1: *const c_void, points2: *const c_void, camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, e: *const c_void, r: *const c_void, t: *const c_void, method: i32, prob: f64, threshold: f64, mask: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_recoverPose_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(e: *const c_void, points1: *const c_void, points2: *const c_void, camera_matrix: *const c_void, r: *const c_void, t: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_recoverPose_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__InputOutputArrayR(e: *const c_void, points1: *const c_void, points2: *const c_void, camera_matrix: *const c_void, r: *const c_void, t: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_recoverPose_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double(e: *const c_void, points1: *const c_void, points2: *const c_void, camera_matrix: *const c_void, r: *const c_void, t: *const c_void, distance_thresh: f64, ocvrs_return: *mut Result<i32>);
		pub fn cv_recoverPose_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double_const__InputOutputArrayR_const__OutputArrayR(e: *const c_void, points1: *const c_void, points2: *const c_void, camera_matrix: *const c_void, r: *const c_void, t: *const c_void, distance_thresh: f64, mask: *const c_void, triangulated_points: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_recoverPose_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(e: *const c_void, points1: *const c_void, points2: *const c_void, r: *const c_void, t: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_recoverPose_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double_Point2d_const__InputOutputArrayR(e: *const c_void, points1: *const c_void, points2: *const c_void, r: *const c_void, t: *const c_void, focal: f64, pp: *const core::Point2d, mask: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rectify3Collinear_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_Size_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_double_Size_RectX_RectX_int(camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, camera_matrix3: *const c_void, dist_coeffs3: *const c_void, imgpt1: *const c_void, imgpt3: *const c_void, image_size: *const core::Size, r12: *const c_void, t12: *const c_void, r13: *const c_void, t13: *const c_void, r1: *const c_void, r2: *const c_void, r3: *const c_void, p1: *const c_void, p2: *const c_void, p3: *const c_void, q: *const c_void, alpha: f64, new_img_size: *const core::Size, roi1: *mut core::Rect, roi2: *mut core::Rect, flags: i32, ocvrs_return: *mut Result<f32>);
		pub fn cv_reprojectImageTo3D_const__InputArrayR_const__OutputArrayR_const__InputArrayR(disparity: *const c_void, _3d_image: *const c_void, q: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_reprojectImageTo3D_const__InputArrayR_const__OutputArrayR_const__InputArrayR_bool_int(disparity: *const c_void, _3d_image: *const c_void, q: *const c_void, handle_missing_values: bool, ddepth: i32, ocvrs_return: *mut Result_void);
		pub fn cv_sampsonDistance_const__InputArrayR_const__InputArrayR_const__InputArrayR(pt1: *const c_void, pt2: *const c_void, f: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_solveP3P_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, flags: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_solvePnPGeneric_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_solvePnPGeneric_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_bool_SolvePnPMethod_const__InputArrayR_const__InputArrayR_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, use_extrinsic_guess: bool, flags: crate::calib3d::SolvePnPMethod, rvec: *const c_void, tvec: *const c_void, reprojection_error: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_solvePnPRansac_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_solvePnPRansac_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_bool_int_float_double_const__OutputArrayR_int(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, use_extrinsic_guess: bool, iterations_count: i32, reprojection_error: f32, confidence: f64, inliers: *const c_void, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_solvePnPRansac_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, inliers: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_solvePnPRansac_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const_UsacParamsR(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, inliers: *const c_void, params: *const crate::calib3d::UsacParams, ocvrs_return: *mut Result<bool>);
		pub fn cv_solvePnPRefineLM_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_solvePnPRefineLM_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_TermCriteria(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, criteria: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_solvePnPRefineVVS_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_solvePnPRefineVVS_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_TermCriteria_double(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, criteria: *const core::TermCriteria, vv_slambda: f64, ocvrs_return: *mut Result_void);
		pub fn cv_solvePnP_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_solvePnP_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_bool_int(object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, use_extrinsic_guess: bool, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_stereoCalibrate_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(object_points: *const c_void, image_points1: *const c_void, image_points2: *const c_void, camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, e: *const c_void, f: *const c_void, per_view_errors: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_stereoCalibrate_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(object_points: *const c_void, image_points1: *const c_void, image_points2: *const c_void, camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, e: *const c_void, f: *const c_void, rvecs: *const c_void, tvecs: *const c_void, per_view_errors: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_stereoCalibrate_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points1: *const c_void, image_points2: *const c_void, camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, e: *const c_void, f: *const c_void, rvecs: *const c_void, tvecs: *const c_void, per_view_errors: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_stereoCalibrate_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points1: *const c_void, image_points2: *const c_void, camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, e: *const c_void, f: *const c_void, per_view_errors: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_stereoCalibrate_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(object_points: *const c_void, image_points1: *const c_void, image_points2: *const c_void, camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, e: *const c_void, f: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_stereoCalibrate_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points1: *const c_void, image_points2: *const c_void, camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, e: *const c_void, f: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_stereoRectifyUncalibrated_const__InputArrayR_const__InputArrayR_const__InputArrayR_Size_const__OutputArrayR_const__OutputArrayR(points1: *const c_void, points2: *const c_void, f: *const c_void, img_size: *const core::Size, h1: *const c_void, h2: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_stereoRectifyUncalibrated_const__InputArrayR_const__InputArrayR_const__InputArrayR_Size_const__OutputArrayR_const__OutputArrayR_double(points1: *const c_void, points2: *const c_void, f: *const c_void, img_size: *const core::Size, h1: *const c_void, h2: *const c_void, threshold: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_stereoRectify_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, r1: *const c_void, r2: *const c_void, p1: *const c_void, p2: *const c_void, q: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_stereoRectify_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_double_Size_RectX_RectX(camera_matrix1: *const c_void, dist_coeffs1: *const c_void, camera_matrix2: *const c_void, dist_coeffs2: *const c_void, image_size: *const core::Size, r: *const c_void, t: *const c_void, r1: *const c_void, r2: *const c_void, p1: *const c_void, p2: *const c_void, q: *const c_void, flags: i32, alpha: f64, new_image_size: *const core::Size, valid_pix_roi1: *mut core::Rect, valid_pix_roi2: *mut core::Rect, ocvrs_return: *mut Result_void);
		pub fn cv_triangulatePoints_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(proj_matr1: *const c_void, proj_matr2: *const c_void, proj_points1: *const c_void, proj_points2: *const c_void, points4_d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_undistortImagePoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_undistortImagePoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_TermCriteria(src: *const c_void, dst: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, unnamed: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_undistortPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_undistortPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, r: *const c_void, p: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_undistortPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_TermCriteria(src: *const c_void, dst: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, r: *const c_void, p: *const c_void, criteria: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_undistort_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_undistort_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, new_camera_matrix: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_validateDisparity_const__InputOutputArrayR_const__InputArrayR_int_int(disparity: *const c_void, cost: *const c_void, min_disparity: i32, number_of_disparities: i32, ocvrs_return: *mut Result_void);
		pub fn cv_validateDisparity_const__InputOutputArrayR_const__InputArrayR_int_int_int(disparity: *const c_void, cost: *const c_void, min_disparity: i32, number_of_disparities: i32, disp12_max_disp: i32, ocvrs_return: *mut Result_void);
		pub fn cv_CirclesGridFinderParameters_CirclesGridFinderParameters(ocvrs_return: *mut Result<crate::calib3d::CirclesGridFinderParameters>);
		pub fn cv_LMSolver_run_const_const__InputOutputArrayR(instance: *const c_void, param: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_LMSolver_setMaxIters_int(instance: *mut c_void, max_iters: i32, ocvrs_return: *mut Result_void);
		pub fn cv_LMSolver_getMaxIters_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_LMSolver_create_const_PtrLCallbackGR_int(cb: *const c_void, max_iters: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LMSolver_create_const_PtrLCallbackGR_int_double(cb: *const c_void, max_iters: i32, eps: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LMSolver_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_LMSolver_delete(instance: *mut c_void);
		pub fn cv_LMSolver_Callback_compute_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, param: *const c_void, err: *const c_void, j: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_LMSolver_Callback_delete(instance: *mut c_void);
		pub fn cv_StereoBM_getPreFilterType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoBM_setPreFilterType_int(instance: *mut c_void, pre_filter_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoBM_getPreFilterSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoBM_setPreFilterSize_int(instance: *mut c_void, pre_filter_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoBM_getPreFilterCap_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoBM_setPreFilterCap_int(instance: *mut c_void, pre_filter_cap: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoBM_getTextureThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoBM_setTextureThreshold_int(instance: *mut c_void, texture_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoBM_getUniquenessRatio_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoBM_setUniquenessRatio_int(instance: *mut c_void, uniqueness_ratio: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoBM_getSmallerBlockSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoBM_setSmallerBlockSize_int(instance: *mut c_void, block_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoBM_getROI1_const(instance: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_StereoBM_setROI1_Rect(instance: *mut c_void, roi1: *const core::Rect, ocvrs_return: *mut Result_void);
		pub fn cv_StereoBM_getROI2_const(instance: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_StereoBM_setROI2_Rect(instance: *mut c_void, roi2: *const core::Rect, ocvrs_return: *mut Result_void);
		pub fn cv_StereoBM_create_int_int(num_disparities: i32, block_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_StereoBM_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_StereoBM_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_StereoBM_to_StereoMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_StereoBM_delete(instance: *mut c_void);
		pub fn cv_StereoMatcher_compute_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, left: *const c_void, right: *const c_void, disparity: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_StereoMatcher_getMinDisparity_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoMatcher_setMinDisparity_int(instance: *mut c_void, min_disparity: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoMatcher_getNumDisparities_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoMatcher_setNumDisparities_int(instance: *mut c_void, num_disparities: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoMatcher_getBlockSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoMatcher_setBlockSize_int(instance: *mut c_void, block_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoMatcher_getSpeckleWindowSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoMatcher_setSpeckleWindowSize_int(instance: *mut c_void, speckle_window_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoMatcher_getSpeckleRange_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoMatcher_setSpeckleRange_int(instance: *mut c_void, speckle_range: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoMatcher_getDisp12MaxDiff_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoMatcher_setDisp12MaxDiff_int(instance: *mut c_void, disp12_max_diff: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoMatcher_to_StereoBM(instance: *mut c_void) -> *mut c_void;
		pub fn cv_StereoMatcher_to_StereoSGBM(instance: *mut c_void) -> *mut c_void;
		pub fn cv_StereoMatcher_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_StereoMatcher_delete(instance: *mut c_void);
		pub fn cv_StereoSGBM_getPreFilterCap_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoSGBM_setPreFilterCap_int(instance: *mut c_void, pre_filter_cap: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoSGBM_getUniquenessRatio_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoSGBM_setUniquenessRatio_int(instance: *mut c_void, uniqueness_ratio: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoSGBM_getP1_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoSGBM_setP1_int(instance: *mut c_void, p1: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoSGBM_getP2_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoSGBM_setP2_int(instance: *mut c_void, p2: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoSGBM_getMode_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_StereoSGBM_setMode_int(instance: *mut c_void, mode: i32, ocvrs_return: *mut Result_void);
		pub fn cv_StereoSGBM_create_int_int_int_int_int_int_int_int_int_int_int(min_disparity: i32, num_disparities: i32, block_size: i32, p1: i32, p2: i32, disp12_max_diff: i32, pre_filter_cap: i32, uniqueness_ratio: i32, speckle_window_size: i32, speckle_range: i32, mode: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_StereoSGBM_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_StereoSGBM_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_StereoSGBM_to_StereoMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_StereoSGBM_delete(instance: *mut c_void);
		pub fn cv_UsacParams_UsacParams(ocvrs_return: *mut Result<crate::calib3d::UsacParams>);
		pub fn cv_PtrLcv_LMSolverG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_LMSolverG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_LMSolverG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_LMSolverG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_LMSolver_CallbackG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_LMSolver_CallbackG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_LMSolver_CallbackG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_StereoBMG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_StereoBMG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_StereoBMG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_StereoBMG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_StereoBMG_to_PtrOfStereoMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_StereoMatcherG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_StereoMatcherG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_StereoMatcherG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_StereoMatcherG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_StereoSGBMG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_StereoSGBMG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_StereoSGBMG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_StereoSGBMG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_StereoSGBMG_to_PtrOfStereoMatcher(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_calib3d)]
pub use calib3d_sys::*;

#[cfg(ocvrs_has_module_ccalib)]
mod ccalib_sys {
	use super::*;

	extern "C" {
		pub fn cv_omnidir_calibrate_const__InputArrayR_const__InputArrayR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points: *const c_void, size: *const core::Size, k: *const c_void, xi: *const c_void, d: *const c_void, rvecs: *const c_void, tvecs: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_omnidir_calibrate_const__InputArrayR_const__InputArrayR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, size: *const core::Size, k: *const c_void, xi: *const c_void, d: *const c_void, rvecs: *const c_void, tvecs: *const c_void, flags: i32, criteria: *const core::TermCriteria, idx: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_omnidir_initUndistortRectifyMap_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_SizeR_int_const__OutputArrayR_const__OutputArrayR_int(k: *const c_void, d: *const c_void, xi: *const c_void, r: *const c_void, p: *const c_void, size: *const core::Size, m1type: i32, map1: *const c_void, map2: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_omnidir_projectPoints_const__InputArrayR_const__OutputArrayR_const_Affine3dR_const__InputArrayR_double_const__InputArrayR(object_points: *const c_void, image_points: *const c_void, affine: *const core::Affine3d, k: *const c_void, xi: f64, d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_omnidir_projectPoints_const__InputArrayR_const__OutputArrayR_const_Affine3dR_const__InputArrayR_double_const__InputArrayR_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, affine: *const core::Affine3d, k: *const c_void, xi: f64, d: *const c_void, jacobian: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_omnidir_projectPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_double_const__InputArrayR(object_points: *const c_void, image_points: *const c_void, rvec: *const c_void, tvec: *const c_void, k: *const c_void, xi: f64, d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_omnidir_projectPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_double_const__InputArrayR_const__OutputArrayR(object_points: *const c_void, image_points: *const c_void, rvec: *const c_void, tvec: *const c_void, k: *const c_void, xi: f64, d: *const c_void, jacobian: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_omnidir_stereoCalibrate_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const_SizeR_const_SizeR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(object_points: *const c_void, image_points1: *const c_void, image_points2: *const c_void, image_size1: *const core::Size, image_size2: *const core::Size, k1: *const c_void, xi1: *const c_void, d1: *const c_void, k2: *const c_void, xi2: *const c_void, d2: *const c_void, rvec: *const c_void, tvec: *const c_void, rvecs_l: *const c_void, tvecs_l: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_omnidir_stereoCalibrate_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const_SizeR_const_SizeR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria_const__OutputArrayR(object_points: *const c_void, image_points1: *const c_void, image_points2: *const c_void, image_size1: *const core::Size, image_size2: *const core::Size, k1: *const c_void, xi1: *const c_void, d1: *const c_void, k2: *const c_void, xi2: *const c_void, d2: *const c_void, rvec: *const c_void, tvec: *const c_void, rvecs_l: *const c_void, tvecs_l: *const c_void, flags: i32, criteria: *const core::TermCriteria, idx: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_omnidir_stereoReconstruct_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_int_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(image1: *const c_void, image2: *const c_void, k1: *const c_void, d1: *const c_void, xi1: *const c_void, k2: *const c_void, d2: *const c_void, xi2: *const c_void, r: *const c_void, t: *const c_void, flag: i32, num_disparities: i32, sad_window_size: i32, disparity: *const c_void, image1_rec: *const c_void, image2_rec: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_omnidir_stereoReconstruct_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_int_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const_SizeR_const__InputArrayR_const__OutputArrayR_int(image1: *const c_void, image2: *const c_void, k1: *const c_void, d1: *const c_void, xi1: *const c_void, k2: *const c_void, d2: *const c_void, xi2: *const c_void, r: *const c_void, t: *const c_void, flag: i32, num_disparities: i32, sad_window_size: i32, disparity: *const c_void, image1_rec: *const c_void, image2_rec: *const c_void, new_size: *const core::Size, knew: *const c_void, point_cloud: *const c_void, point_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_omnidir_stereoRectify_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(r: *const c_void, t: *const c_void, r1: *const c_void, r2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_omnidir_undistortImage_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_int(distorted: *const c_void, undistorted: *const c_void, k: *const c_void, d: *const c_void, xi: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_omnidir_undistortImage_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_const__InputArrayR_const_SizeR_const__InputArrayR(distorted: *const c_void, undistorted: *const c_void, k: *const c_void, d: *const c_void, xi: *const c_void, flags: i32, knew: *const c_void, new_size: *const core::Size, r: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_omnidir_undistortPoints_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(distorted: *const c_void, undistorted: *const c_void, k: *const c_void, d: *const c_void, xi: *const c_void, r: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ccalib_CustomPattern_CustomPattern(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ccalib_CustomPattern_create_const__InputArrayR_const_Size2f_const__OutputArrayR(instance: *mut c_void, pattern: *const c_void, board_size: *const core::Size2f, output: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ccalib_CustomPattern_create_const__InputArrayR_const_Size2f(instance: *mut c_void, pattern: *const c_void, board_size: *const core::Size2f, ocvrs_return: *mut Result<bool>);
		pub fn cv_ccalib_CustomPattern_findPattern_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const_double_const_double_const_bool_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, matched_features: *const c_void, pattern_points: *const c_void, ratio: f64, proj_error: f64, refine_position: bool, out: *const c_void, h: *const c_void, pattern_corners: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ccalib_CustomPattern_findPattern_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, matched_features: *const c_void, pattern_points: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ccalib_CustomPattern_isInitialized(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ccalib_CustomPattern_getPatternPoints_vectorLKeyPointGR(instance: *mut c_void, original_points: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ccalib_CustomPattern_getPixelSize(instance: *mut c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ccalib_CustomPattern_setFeatureDetector_PtrLFeature2DG(instance: *mut c_void, feature_detector: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ccalib_CustomPattern_setDescriptorExtractor_PtrLFeature2DG(instance: *mut c_void, extractor: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ccalib_CustomPattern_setDescriptorMatcher_PtrLDescriptorMatcherG(instance: *mut c_void, matcher: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ccalib_CustomPattern_getFeatureDetector(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ccalib_CustomPattern_getDescriptorExtractor(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ccalib_CustomPattern_getDescriptorMatcher(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ccalib_CustomPattern_calibrate_const__InputArrayR_const__InputArrayR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_int_TermCriteria(instance: *mut c_void, object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, flags: i32, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<f64>);
		pub fn cv_ccalib_CustomPattern_calibrate_const__InputArrayR_const__InputArrayR_Size_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, object_points: *const c_void, image_points: *const c_void, image_size: *const core::Size, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvecs: *const c_void, tvecs: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ccalib_CustomPattern_findRt_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_bool_int(instance: *mut c_void, object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, use_extrinsic_guess: bool, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_ccalib_CustomPattern_findRt_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(instance: *mut c_void, object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ccalib_CustomPattern_findRt_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_bool_int(instance: *mut c_void, image: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, use_extrinsic_guess: bool, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_ccalib_CustomPattern_findRt_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(instance: *mut c_void, image: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ccalib_CustomPattern_findRtRANSAC_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_bool_int_float_int_const__OutputArrayR_int(instance: *mut c_void, object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, use_extrinsic_guess: bool, iterations_count: i32, reprojection_error: f32, min_inliers_count: i32, inliers: *const c_void, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_ccalib_CustomPattern_findRtRANSAC_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(instance: *mut c_void, object_points: *const c_void, image_points: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ccalib_CustomPattern_findRtRANSAC_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_bool_int_float_int_const__OutputArrayR_int(instance: *mut c_void, image: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, use_extrinsic_guess: bool, iterations_count: i32, reprojection_error: f32, min_inliers_count: i32, inliers: *const c_void, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_ccalib_CustomPattern_findRtRANSAC_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(instance: *mut c_void, image: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, rvec: *const c_void, tvec: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ccalib_CustomPattern_drawOrientation_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_double_int(instance: *mut c_void, image: *const c_void, tvec: *const c_void, rvec: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, axis_length: f64, axis_width: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ccalib_CustomPattern_drawOrientation_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, image: *const c_void, tvec: *const c_void, rvec: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ccalib_CustomPattern_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ccalib_CustomPattern_delete(instance: *mut c_void);
		pub fn cv_multicalib_MultiCameraCalibration_MultiCameraCalibration_int_int_const_stringR_float_float_int_int_int_int_TermCriteria_PtrLFeature2DG_PtrLFeature2DG_PtrLDescriptorMatcherG(camera_type: i32, n_cameras: i32, file_name: *const c_char, pattern_width: f32, pattern_height: f32, verbose: i32, show_extration: i32, n_mini_matches: i32, flags: i32, criteria: *const core::TermCriteria, detector: *mut c_void, descriptor: *mut c_void, matcher: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_multicalib_MultiCameraCalibration_MultiCameraCalibration_int_int_const_stringR_float_float(camera_type: i32, n_cameras: i32, file_name: *const c_char, pattern_width: f32, pattern_height: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_multicalib_MultiCameraCalibration_loadImages(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_multicalib_MultiCameraCalibration_initialize(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_multicalib_MultiCameraCalibration_optimizeExtrinsics(instance: *mut c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_multicalib_MultiCameraCalibration_run(instance: *mut c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_multicalib_MultiCameraCalibration_writeParameters_const_stringR(instance: *mut c_void, filename: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_multicalib_MultiCameraCalibration_delete(instance: *mut c_void);
		pub fn cv_multicalib_MultiCameraCalibration_edge_edge_int_int_int_Mat(cv: i32, pv: i32, pi: i32, trans: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_multicalib_MultiCameraCalibration_edge_propCameraVertex_const(instance: *const c_void) -> i32;
		pub fn cv_multicalib_MultiCameraCalibration_edge_propCameraVertex_int(instance: *mut c_void, val: i32);
		pub fn cv_multicalib_MultiCameraCalibration_edge_propPhotoVertex_const(instance: *const c_void) -> i32;
		pub fn cv_multicalib_MultiCameraCalibration_edge_propPhotoVertex_int(instance: *mut c_void, val: i32);
		pub fn cv_multicalib_MultiCameraCalibration_edge_propPhotoIndex_const(instance: *const c_void) -> i32;
		pub fn cv_multicalib_MultiCameraCalibration_edge_propPhotoIndex_int(instance: *mut c_void, val: i32);
		pub fn cv_multicalib_MultiCameraCalibration_edge_propTransform_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_multicalib_MultiCameraCalibration_edge_propTransform_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_multicalib_MultiCameraCalibration_edge_delete(instance: *mut c_void);
		pub fn cv_multicalib_MultiCameraCalibration_vertex_vertex_Mat_int(po: *mut c_void, ts: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_multicalib_MultiCameraCalibration_vertex_vertex(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_multicalib_MultiCameraCalibration_vertex_propPose_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_multicalib_MultiCameraCalibration_vertex_propPose_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_multicalib_MultiCameraCalibration_vertex_propTimestamp_const(instance: *const c_void) -> i32;
		pub fn cv_multicalib_MultiCameraCalibration_vertex_propTimestamp_int(instance: *mut c_void, val: i32);
		pub fn cv_multicalib_MultiCameraCalibration_vertex_delete(instance: *mut c_void);
		pub fn cv_randpattern_RandomPatternCornerFinder_RandomPatternCornerFinder_float_float_int_int_int_int_PtrLFeature2DG_PtrLFeature2DG_PtrLDescriptorMatcherG(pattern_width: f32, pattern_height: f32, nmini_match: i32, depth: i32, verbose: i32, show_extraction: i32, detector: *mut c_void, descriptor: *mut c_void, matcher: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_randpattern_RandomPatternCornerFinder_RandomPatternCornerFinder_float_float(pattern_width: f32, pattern_height: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_randpattern_RandomPatternCornerFinder_loadPattern_const_MatR(instance: *mut c_void, pattern_image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_randpattern_RandomPatternCornerFinder_loadPattern_const_MatR_const_vectorLKeyPointGR_const_MatR(instance: *mut c_void, pattern_image: *const c_void, pattern_key_points: *const c_void, pattern_descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_randpattern_RandomPatternCornerFinder_computeObjectImagePoints_vectorLMatG(instance: *mut c_void, input_images: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_randpattern_RandomPatternCornerFinder_computeObjectImagePointsForSingle_Mat(instance: *mut c_void, input_image: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_randpattern_RandomPatternCornerFinder_getObjectPoints(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_randpattern_RandomPatternCornerFinder_getImagePoints(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_randpattern_RandomPatternCornerFinder_delete(instance: *mut c_void);
		pub fn cv_randpattern_RandomPatternGenerator_RandomPatternGenerator_int_int(image_width: i32, image_height: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_randpattern_RandomPatternGenerator_generatePattern(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_randpattern_RandomPatternGenerator_getPattern(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_randpattern_RandomPatternGenerator_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ccalib_CustomPatternG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ccalib_CustomPatternG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ccalib_CustomPatternG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ccalib_CustomPatternG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ccalib_CustomPatternG_new_const_CustomPattern(val: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_ccalib)]
pub use ccalib_sys::*;

#[cfg(ocvrs_has_module_core)]
mod core_sys {
	use super::*;

	extern "C" {
		pub fn cv_Cholesky_doubleX_size_t_int_doubleX_size_t_int(a: *mut f64, astep: size_t, m: i32, b: *mut f64, bstep: size_t, n: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_Cholesky_floatX_size_t_int_floatX_size_t_int(a: *mut f32, astep: size_t, m: i32, b: *mut f32, bstep: size_t, n: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_LUT_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src: *const c_void, lut: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_LU_doubleX_size_t_int_doubleX_size_t_int(a: *mut f64, astep: size_t, m: i32, b: *mut f64, bstep: size_t, n: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_LU_floatX_size_t_int_floatX_size_t_int(a: *mut f32, astep: size_t, m: i32, b: *mut f32, bstep: size_t, n: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Mahalanobis_const__InputArrayR_const__InputArrayR_const__InputArrayR(v1: *const c_void, v2: *const c_void, icovar: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_PCABackProject_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, result: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_PCACompute_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_PCACompute_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, eigenvalues: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_PCACompute_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_double(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, eigenvalues: *const c_void, retained_variance: f64, ocvrs_return: *mut Result_void);
		pub fn cv_PCACompute_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_int(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, eigenvalues: *const c_void, max_components: i32, ocvrs_return: *mut Result_void);
		pub fn cv_PCACompute_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_double(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, retained_variance: f64, ocvrs_return: *mut Result_void);
		pub fn cv_PCACompute_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_int(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, max_components: i32, ocvrs_return: *mut Result_void);
		pub fn cv_PCAProject_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, result: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_PSNR_const__InputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_PSNR_const__InputArrayR_const__InputArrayR_double(src1: *const c_void, src2: *const c_void, r: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_SVBackSubst_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(w: *const c_void, u: *const c_void, vt: *const c_void, rhs: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SVDecomp_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, w: *const c_void, u: *const c_void, vt: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SVDecomp_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int(src: *const c_void, w: *const c_void, u: *const c_void, vt: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_abs_const_MatExprR(e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_abs_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_absdiff_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_addWeighted_const__InputArrayR_double_const__InputArrayR_double_double_const__OutputArrayR(src1: *const c_void, alpha: f64, src2: *const c_void, beta: f64, gamma: f64, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_addWeighted_const__InputArrayR_double_const__InputArrayR_double_double_const__OutputArrayR_int(src1: *const c_void, alpha: f64, src2: *const c_void, beta: f64, gamma: f64, dst: *const c_void, dtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_add_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_add_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, dtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_batchDistance_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dist: *const c_void, dtype: i32, nidx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_batchDistance_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_const__OutputArrayR_int_int_const__InputArrayR_int_bool(src1: *const c_void, src2: *const c_void, dist: *const c_void, dtype: i32, nidx: *const c_void, norm_type: i32, k: i32, mask: *const c_void, update: i32, crosscheck: bool, ocvrs_return: *mut Result_void);
		pub fn cv_bitwise_and_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bitwise_and_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bitwise_not_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bitwise_not_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bitwise_or_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bitwise_or_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bitwise_xor_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_bitwise_xor_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_borderInterpolate_int_int_int(p: i32, len: i32, border_type: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_calcCovarMatrix_const__InputArrayR_const__OutputArrayR_const__InputOutputArrayR_int(samples: *const c_void, covar: *const c_void, mean: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_calcCovarMatrix_const__InputArrayR_const__OutputArrayR_const__InputOutputArrayR_int_int(samples: *const c_void, covar: *const c_void, mean: *const c_void, flags: i32, ctype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cartToPolar_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(x: *const c_void, y: *const c_void, magnitude: *const c_void, angle: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cartToPolar_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_bool(x: *const c_void, y: *const c_void, magnitude: *const c_void, angle: *const c_void, angle_in_degrees: bool, ocvrs_return: *mut Result_void);
		pub fn cv_checkHardwareSupport_int(feature: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_checkRange_const__InputArrayR(a: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_checkRange_const__InputArrayR_bool_PointX_double_double(a: *const c_void, quiet: bool, pos: *mut core::Point, min_val: f64, max_val: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_compare_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, cmpop: i32, ocvrs_return: *mut Result_void);
		pub fn cv_completeSymm_const__InputOutputArrayR(m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_completeSymm_const__InputOutputArrayR_bool(m: *const c_void, lower_to_upper: bool, ocvrs_return: *mut Result_void);
		pub fn cv_convertFp16_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_convertScaleAbs_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_convertScaleAbs_const__InputArrayR_const__OutputArrayR_double_double(src: *const c_void, dst: *const c_void, alpha: f64, beta: f64, ocvrs_return: *mut Result_void);
		pub fn cv_copyMakeBorder_const__InputArrayR_const__OutputArrayR_int_int_int_int_int(src: *const c_void, dst: *const c_void, top: i32, bottom: i32, left: i32, right: i32, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_copyMakeBorder_const__InputArrayR_const__OutputArrayR_int_int_int_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, top: i32, bottom: i32, left: i32, right: i32, border_type: i32, value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_copyTo_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_countNonZero_const__InputArrayR(src: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cubeRoot_float(val: f32, ocvrs_return: *mut Result<f32>);
		pub fn cv_cuda_createContinuous_int_int_int_const__OutputArrayR(rows: i32, cols: i32, typ: i32, arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_createGpuMatFromCudaMemory_Size_int_size_t(size: *const core::Size, typ: i32, cuda_memory_address: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createGpuMatFromCudaMemory_Size_int_size_t_size_t(size: *const core::Size, typ: i32, cuda_memory_address: size_t, step: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createGpuMatFromCudaMemory_int_int_int_size_t(rows: i32, cols: i32, typ: i32, cuda_memory_address: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createGpuMatFromCudaMemory_int_int_int_size_t_size_t(rows: i32, cols: i32, typ: i32, cuda_memory_address: size_t, step: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_deviceSupports_FeatureSet(feature_set: core::FeatureSet, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_ensureSizeIsEnough_int_int_int_const__OutputArrayR(rows: i32, cols: i32, typ: i32, arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_getCudaEnabledDeviceCount(ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_getDevice(ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_printCudaDeviceInfo_int(device: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_printShortCudaDeviceInfo_int(device: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_registerPageLocked_MatR(m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_resetDevice(ocvrs_return: *mut Result_void);
		pub fn cv_cuda_setBufferPoolConfig_int_size_t_int(device_id: i32, stack_size: size_t, stack_count: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_setBufferPoolUsage_bool(on: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_setDevice_int(device: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_setGlDevice(ocvrs_return: *mut Result_void);
		pub fn cv_cuda_setGlDevice_int(device: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_unregisterPageLocked_MatR(m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_wrapStream_size_t(cuda_stream_memory_address: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dct_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dct_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_depthToString_int(depth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_check_failed_MatChannels_const_int_const_CheckContextR(v: i32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_MatChannels_const_int_const_int_const_CheckContextR(v1: i32, v2: i32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_MatDepth_const_int_const_CheckContextR(v: i32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_MatDepth_const_int_const_int_const_CheckContextR(v1: i32, v2: i32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_MatType_const_int_const_CheckContextR(v: i32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_MatType_const_int_const_int_const_CheckContextR(v1: i32, v2: i32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_Size_LintG_const_CheckContextR(v: *const core::Size_<i32>, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_Size_LintG_const_Size_LintG_const_CheckContextR(v1: *const core::Size_<i32>, v2: *const core::Size_<i32>, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_bool_const_bool_const_CheckContextR(v1: bool, v2: bool, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_double_const_CheckContextR(v: f64, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_double_const_double_const_CheckContextR(v1: f64, v2: f64, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_float_const_CheckContextR(v: f32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_float_const_float_const_CheckContextR(v1: f32, v2: f32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_int_const_CheckContextR(v: i32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_int_const_int_const_CheckContextR(v1: i32, v2: i32, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_size_t_const_CheckContextR(v: size_t, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_size_t_const_size_t_const_CheckContextR(v1: size_t, v2: size_t, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_auto_const_stringR_const_CheckContextR(v1: *const c_char, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_false_const_bool_const_CheckContextR(v: bool, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_check_failed_true_const_bool_const_CheckContextR(v: bool, ctx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_determinant_const__InputArrayR(mtx: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_dft_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dft_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, flags: i32, nonzero_rows: i32, ocvrs_return: *mut Result_void);
		pub fn cv_directx_getTypeFromD3DFORMAT_const_int(id_3d_format: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_directx_getTypeFromDXGI_FORMAT_const_int(i_dxgi_format: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_divide_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_divide_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, scale: f64, dtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_divide_double_const__InputArrayR_const__OutputArrayR(scale: f64, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_divide_double_const__InputArrayR_const__OutputArrayR_int(scale: f64, src2: *const c_void, dst: *const c_void, dtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_eigenNonSymmetric_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, eigenvalues: *const c_void, eigenvectors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_eigen_const__InputArrayR_const__OutputArrayR(src: *const c_void, eigenvalues: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_eigen_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, eigenvalues: *const c_void, eigenvectors: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_error_const_ExceptionR(exc: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_error_int_const_StringR_const_charX_const_charX_int(_code: i32, _err: *const c_char, _func: *const c_char, _file: *const c_char, _line: i32, ocvrs_return: *mut Result_void);
		pub fn cv_exp_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_extractChannel_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, coi: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fastAtan2_float_float(y: f32, x: f32, ocvrs_return: *mut Result<f32>);
		pub fn cv_findNonZero_const__InputArrayR_const__OutputArrayR(src: *const c_void, idx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_flipND_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, axis: i32, ocvrs_return: *mut Result_void);
		pub fn cv_flip_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flip_code: i32, ocvrs_return: *mut Result_void);
		pub fn cv_gemm_const__InputArrayR_const__InputArrayR_double_const__InputArrayR_double_const__OutputArrayR(src1: *const c_void, src2: *const c_void, alpha: f64, src3: *const c_void, beta: f64, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_gemm_const__InputArrayR_const__InputArrayR_double_const__InputArrayR_double_const__OutputArrayR_int(src1: *const c_void, src2: *const c_void, alpha: f64, src3: *const c_void, beta: f64, dst: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_getBuildInformation(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getCPUFeaturesLine(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getCPUTickCount(ocvrs_return: *mut Result<i64>);
		pub fn cv_getElemSize_int(typ: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_getHardwareFeatureName_int(feature: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getLogLevel(ocvrs_return: *mut Result<i32>);
		pub fn cv_getNumThreads(ocvrs_return: *mut Result<i32>);
		pub fn cv_getNumberOfCPUs(ocvrs_return: *mut Result<i32>);
		pub fn cv_getOptimalDFTSize_int(vecsize: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_getThreadNum(ocvrs_return: *mut Result<i32>);
		pub fn cv_getTickCount(ocvrs_return: *mut Result<i64>);
		pub fn cv_getTickFrequency(ocvrs_return: *mut Result<f64>);
		pub fn cv_getVersionMajor() -> i32;
		pub fn cv_getVersionMinor() -> i32;
		pub fn cv_getVersionRevision() -> i32;
		pub fn cv_getVersionString(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_glob_String_vectorLStringGR(pattern: *mut c_char, result: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_glob_String_vectorLStringGR_bool(pattern: *mut c_char, result: *mut c_void, recursive: bool, ocvrs_return: *mut Result_void);
		pub fn cv_hasNonZero_const__InputArrayR(src: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_haveOpenVX(ocvrs_return: *mut Result<bool>);
		pub fn cv_hconcat_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_hconcat_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_idct_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_idct_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_idft_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_idft_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, flags: i32, nonzero_rows: i32, ocvrs_return: *mut Result_void);
		pub fn cv_inRange_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src: *const c_void, lowerb: *const c_void, upperb: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_insertChannel_const__InputArrayR_const__InputOutputArrayR_int(src: *const c_void, dst: *const c_void, coi: i32, ocvrs_return: *mut Result_void);
		pub fn cv_instr_getFlags(ocvrs_return: *mut Result<core::FLAGS>);
		pub fn cv_instr_resetTrace(ocvrs_return: *mut Result_void);
		pub fn cv_instr_setFlags_FLAGS(mode_flags: core::FLAGS, ocvrs_return: *mut Result_void);
		pub fn cv_instr_setUseInstrumentation_bool(flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_instr_useInstrumentation(ocvrs_return: *mut Result<bool>);
		pub fn cv_invert_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_invert_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_ipp_getIppErrorLocation(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ipp_getIppFeatures(ocvrs_return: *mut Result<u64>);
		pub fn cv_ipp_getIppStatus(ocvrs_return: *mut Result<i32>);
		pub fn cv_ipp_getIppVersion(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ipp_setIppStatus_int(status: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ipp_setIppStatus_int_const_charX_const_charX_int(status: i32, funcname: *const c_char, filename: *const c_char, line: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ipp_setUseIPP_NotExact_bool(flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ipp_setUseIPP_bool(flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ipp_useIPP(ocvrs_return: *mut Result<bool>);
		pub fn cv_ipp_useIPP_NotExact(ocvrs_return: *mut Result<bool>);
		pub fn cv_kmeans_const__InputArrayR_int_const__InputOutputArrayR_TermCriteria_int_int(data: *const c_void, k: i32, best_labels: *const c_void, criteria: *const core::TermCriteria, attempts: i32, flags: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_kmeans_const__InputArrayR_int_const__InputOutputArrayR_TermCriteria_int_int_const__OutputArrayR(data: *const c_void, k: i32, best_labels: *const c_void, criteria: *const core::TermCriteria, attempts: i32, flags: i32, centers: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_log_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_magnitude_const__InputArrayR_const__InputArrayR_const__OutputArrayR(x: *const c_void, y: *const c_void, magnitude: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_max_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_max_const_MatR_const_MatR_MatR(src1: *const c_void, src2: *const c_void, dst: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_max_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_max_const_UMatR_const_UMatR_UMatR(src1: *const c_void, src2: *const c_void, dst: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_max_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_max_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_meanStdDev_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, mean: *const c_void, stddev: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_meanStdDev_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, mean: *const c_void, stddev: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_mean_const__InputArrayR(src: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_mean_const__InputArrayR_const__InputArrayR(src: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_merge_const__InputArrayR_const__OutputArrayR(mv: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_minMaxIdx_const__InputArrayR_doubleX(src: *const c_void, min_val: *mut f64, ocvrs_return: *mut Result_void);
		pub fn cv_minMaxIdx_const__InputArrayR_doubleX_doubleX_intX_intX_const__InputArrayR(src: *const c_void, min_val: *mut f64, max_val: *mut f64, min_idx: *mut i32, max_idx: *mut i32, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_minMaxLoc_const_SparseMatR_doubleX_doubleX(a: *const c_void, min_val: *mut f64, max_val: *mut f64, ocvrs_return: *mut Result_void);
		pub fn cv_minMaxLoc_const_SparseMatR_doubleX_doubleX_intX_intX(a: *const c_void, min_val: *mut f64, max_val: *mut f64, min_idx: *mut i32, max_idx: *mut i32, ocvrs_return: *mut Result_void);
		pub fn cv_minMaxLoc_const__InputArrayR_doubleX(src: *const c_void, min_val: *mut f64, ocvrs_return: *mut Result_void);
		pub fn cv_minMaxLoc_const__InputArrayR_doubleX_doubleX_PointX_PointX_const__InputArrayR(src: *const c_void, min_val: *mut f64, max_val: *mut f64, min_loc: *mut core::Point, max_loc: *mut core::Point, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_min_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_min_const_MatR_const_MatR_MatR(src1: *const c_void, src2: *const c_void, dst: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_min_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_min_const_UMatR_const_UMatR_UMatR(src1: *const c_void, src2: *const c_void, dst: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_min_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_min_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_mixChannels_const__InputArrayR_const__InputOutputArrayR_const_intX_size_t(src: *const c_void, dst: *const c_void, from_to: *const i32, npairs: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_mixChannels_const__InputArrayR_const__InputOutputArrayR_const_vectorLintGR(src: *const c_void, dst: *const c_void, from_to: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_mulSpectrums_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(a: *const c_void, b: *const c_void, c: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_mulSpectrums_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_bool(a: *const c_void, b: *const c_void, c: *const c_void, flags: i32, conj_b: bool, ocvrs_return: *mut Result_void);
		pub fn cv_mulTransposed_const__InputArrayR_const__OutputArrayR_bool(src: *const c_void, dst: *const c_void, a_ta: bool, ocvrs_return: *mut Result_void);
		pub fn cv_mulTransposed_const__InputArrayR_const__OutputArrayR_bool_const__InputArrayR_double_int(src: *const c_void, dst: *const c_void, a_ta: bool, delta: *const c_void, scale: f64, dtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_multiply_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_multiply_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, scale: f64, dtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_noArray() -> *mut c_void;
		pub fn cv_norm_const_SparseMatR_int(src: *const c_void, norm_type: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_norm_const__InputArrayR(src1: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_norm_const__InputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_norm_const__InputArrayR_const__InputArrayR_int_const__InputArrayR(src1: *const c_void, src2: *const c_void, norm_type: i32, mask: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_norm_const__InputArrayR_int_const__InputArrayR(src1: *const c_void, norm_type: i32, mask: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_normalize_const_SparseMatR_SparseMatR_double_int(src: *const c_void, dst: *mut c_void, alpha: f64, norm_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_normalize_const__InputArrayR_const__InputOutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_normalize_const__InputArrayR_const__InputOutputArrayR_double_double_int_int_const__InputArrayR(src: *const c_void, dst: *const c_void, alpha: f64, beta: f64, norm_type: i32, dtype: i32, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_attachContext_const_StringR_voidX_voidX_voidX(platform_name: *const c_char, platform_id: *mut c_void, context: *mut c_void, device_id: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_buildOptionsAddMatrixDescription_StringR_const_StringR_const__InputArrayR(build_options: *mut *mut c_void, name: *const c_char, _m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_checkOptimalVectorWidth_const_intX_const__InputArrayR(vector_widths: *const i32, src1: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_checkOptimalVectorWidth_const_intX_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_OclVectorStrategy(vector_widths: *const i32, src1: *const c_void, src2: *const c_void, src3: *const c_void, src4: *const c_void, src5: *const c_void, src6: *const c_void, src7: *const c_void, src8: *const c_void, src9: *const c_void, strat: core::OclVectorStrategy, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_convertFromBuffer_voidX_size_t_int_int_int_UMatR(cl_mem_buffer: *mut c_void, step: size_t, rows: i32, cols: i32, typ: i32, dst: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_convertFromImage_voidX_UMatR(cl_mem_image: *mut c_void, dst: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_convertTypeStr_int_int_int_charX(sdepth: i32, ddepth: i32, cn: i32, buf: *mut *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_convertTypeStr_int_int_int_charX_size_t(sdepth: i32, ddepth: i32, cn: i32, buf: *mut *mut c_void, buf_size: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_finish(ocvrs_return: *mut Result_void);
		pub fn cv_ocl_getOpenCLErrorString_int(error_code: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_getPlatfomsInfo_vectorLPlatformInfoGR(platform_info: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_haveAmdBlas(ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_haveAmdFft(ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_haveOpenCL(ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_haveSVM(ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_kernelToStr_const__InputArrayR(_kernel: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_kernelToStr_const__InputArrayR_int_const_charX(_kernel: *const c_void, ddepth: i32, name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_memopTypeToStr_int(t: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_predictOptimalVectorWidthMax_const__InputArrayR(src1: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_predictOptimalVectorWidthMax_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, src3: *const c_void, src4: *const c_void, src5: *const c_void, src6: *const c_void, src7: *const c_void, src8: *const c_void, src9: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_predictOptimalVectorWidth_const__InputArrayR(src1: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_predictOptimalVectorWidth_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_OclVectorStrategy(src1: *const c_void, src2: *const c_void, src3: *const c_void, src4: *const c_void, src5: *const c_void, src6: *const c_void, src7: *const c_void, src8: *const c_void, src9: *const c_void, strat: core::OclVectorStrategy, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_setUseOpenCL_bool(flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_typeToStr_int(t: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_useOpenCL(ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_vecopTypeToStr_int(t: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_convertFromGLTexture2D_const_Texture2DR_const__OutputArrayR(texture: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_convertToGLTexture2D_const__InputArrayR_Texture2DR(src: *const c_void, texture: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_mapGLBuffer_const_BufferR(buffer: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_mapGLBuffer_const_BufferR_AccessFlag(buffer: *const c_void, access_flags: core::AccessFlag, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_ocl_initializeContextFromGL(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_render_const_ArraysR(arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_render_const_ArraysR_const__InputArrayR(arr: *const c_void, indices: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_render_const_ArraysR_const__InputArrayR_int_Scalar(arr: *const c_void, indices: *const c_void, mode: i32, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_render_const_ArraysR_int_Scalar(arr: *const c_void, mode: i32, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_render_const_Texture2DR(tex: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_render_const_Texture2DR_Rect_LdoubleG_Rect_LdoubleG(tex: *const c_void, wnd_rect: *const core::Rect_<f64>, tex_rect: *const core::Rect_<f64>, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_unmapGLBuffer_UMatR(u: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_operatorA_const_MatExprR_const_MatExprR(e1: *const c_void, e2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_MatExprR_const_MatR(e: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_MatExprR_const_ScalarR(e: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_MatR_const_MatExprR(m: *const c_void, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_MatR_const_ScalarR(a: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_ScalarR_const_MatExprR(s: *const core::Scalar, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_ScalarR_const_MatR(s: *const core::Scalar, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_MatExprR_const_MatExprR(e1: *const c_void, e2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_MatExprR_const_MatR(e: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_MatExprR_double(e: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_MatR_const_MatExprR(m: *const c_void, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_double_const_MatExprR(s: f64, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorEQ_const_FileNodeIteratorR_const_FileNodeIteratorR(it1: *const c_void, it2: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_operatorEQ_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorEQ_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorEQ_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorGE_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorGE_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorGE_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorG_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorG_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorG_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorLE_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorLE_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorLE_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorL_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorL_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorL_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNE_const_FileNodeIteratorR_const_FileNodeIteratorR(it1: *const c_void, it2: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_operatorNE_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNE_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNE_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNOTB_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorOR_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorOR_const_MatR_const_ScalarR(a: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorOR_const_ScalarR_const_MatR(s: *const core::Scalar, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorR_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorR_const_MatR_const_ScalarR(a: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorR_const_ScalarR_const_MatR(s: *const core::Scalar, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatExprR(e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatExprR_const_MatExprR(e1: *const c_void, e2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatExprR_const_MatR(e: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatExprR_const_ScalarR(e: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatR_const_MatExprR(m: *const c_void, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatR_const_ScalarR(a: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_ScalarR_const_MatExprR(s: *const core::Scalar, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_ScalarR_const_MatR(s: *const core::Scalar, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorXOR_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorXOR_const_MatR_const_ScalarR(a: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorXOR_const_ScalarR_const_MatR(s: *const core::Scalar, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_MatExprR_const_MatExprR(e1: *const c_void, e2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_MatExprR_const_MatR(e: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_MatExprR_double(e: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_MatR_const_MatExprR(m: *const c_void, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_double_const_MatExprR(s: f64, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_parallel_for__const_RangeR_const_ParallelLoopBodyR(range: *const c_void, body: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_parallel_for__const_RangeR_const_ParallelLoopBodyR_double(range: *const c_void, body: *const c_void, nstripes: f64, ocvrs_return: *mut Result_void);
		pub fn cv_patchNaNs_const__InputOutputArrayR(a: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_patchNaNs_const__InputOutputArrayR_double(a: *const c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_perspectiveTransform_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_phase_const__InputArrayR_const__InputArrayR_const__OutputArrayR(x: *const c_void, y: *const c_void, angle: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_phase_const__InputArrayR_const__InputArrayR_const__OutputArrayR_bool(x: *const c_void, y: *const c_void, angle: *const c_void, angle_in_degrees: bool, ocvrs_return: *mut Result_void);
		pub fn cv_polarToCart_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(magnitude: *const c_void, angle: *const c_void, x: *const c_void, y: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_polarToCart_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_bool(magnitude: *const c_void, angle: *const c_void, x: *const c_void, y: *const c_void, angle_in_degrees: bool, ocvrs_return: *mut Result_void);
		pub fn cv_pow_const__InputArrayR_double_const__OutputArrayR(src: *const c_void, power: f64, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_randShuffle_const__InputOutputArrayR(dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_randShuffle_const__InputOutputArrayR_double_RNGX(dst: *const c_void, iter_factor: f64, rng: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_randn_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR(dst: *const c_void, mean: *const c_void, stddev: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_randu_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR(dst: *const c_void, low: *const c_void, high: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_DMatchR_const_DMatchR(node: *const c_void, value: *mut core::DMatch, default_value: *const core::DMatch, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_KeyPointR_const_KeyPointR(node: *const c_void, value: *mut c_void, default_value: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_MatR(node: *const c_void, mat: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_MatR_const_MatR(node: *const c_void, mat: *mut c_void, default_mat: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_SparseMatR(node: *const c_void, mat: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_SparseMatR_const_SparseMatR(node: *const c_void, mat: *mut c_void, default_mat: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_doubleR_double(node: *const c_void, value: *mut f64, default_value: f64, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_floatR_float(node: *const c_void, value: *mut f32, default_value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_intR_int(node: *const c_void, value: *mut i32, default_value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_stringR_const_stringR(node: *const c_void, value: *mut *mut c_void, default_value: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_vectorLDMatchGR(node: *const c_void, matches: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_read_const_FileNodeR_vectorLKeyPointGR(node: *const c_void, keypoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rectangleIntersectionArea_const_Rect2dR_const_Rect2dR(a: *const core::Rect2d, b: *const core::Rect2d, ocvrs_return: *mut Result<f64>);
		pub fn cv_reduceArgMax_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, axis: i32, ocvrs_return: *mut Result_void);
		pub fn cv_reduceArgMax_const__InputArrayR_const__OutputArrayR_int_bool(src: *const c_void, dst: *const c_void, axis: i32, last_index: bool, ocvrs_return: *mut Result_void);
		pub fn cv_reduceArgMin_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, axis: i32, ocvrs_return: *mut Result_void);
		pub fn cv_reduceArgMin_const__InputArrayR_const__OutputArrayR_int_bool(src: *const c_void, dst: *const c_void, axis: i32, last_index: bool, ocvrs_return: *mut Result_void);
		pub fn cv_reduce_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, dim: i32, rtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_reduce_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, dim: i32, rtype: i32, dtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_repeat_const_MatR_int_int(src: *const c_void, ny: i32, nx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_repeat_const__InputArrayR_int_int_const__OutputArrayR(src: *const c_void, ny: i32, nx: i32, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rotate_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, rotate_code: i32, ocvrs_return: *mut Result_void);
		pub fn cv_samples_addSamplesDataSearchPath_const_StringR(path: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_samples_addSamplesDataSearchSubDirectory_const_StringR(subdir: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_samples_findFileOrKeep_const_StringR(relative_path: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_samples_findFileOrKeep_const_StringR_bool(relative_path: *const c_char, silent_mode: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_samples_findFile_const_StringR(relative_path: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_samples_findFile_const_StringR_bool_bool(relative_path: *const c_char, required: bool, silent_mode: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_scaleAdd_const__InputArrayR_double_const__InputArrayR_const__OutputArrayR(src1: *const c_void, alpha: f64, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_setBreakOnError_bool(flag: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_setIdentity_const__InputOutputArrayR(mtx: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_setIdentity_const__InputOutputArrayR_const_ScalarR(mtx: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_setLogLevel_int(level: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_setNumThreads_int(nthreads: i32, ocvrs_return: *mut Result_void);
		pub fn cv_setRNGSeed_int(seed: i32, ocvrs_return: *mut Result_void);
		pub fn cv_setUseOpenVX_bool(flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_setUseOptimized_bool(onoff: bool, ocvrs_return: *mut Result_void);
		pub fn cv_solveCubic_const__InputArrayR_const__OutputArrayR(coeffs: *const c_void, roots: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_solveLP_const__InputArrayR_const__InputArrayR_const__OutputArrayR(func: *const c_void, constr: *const c_void, z: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_solveLP_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double(func: *const c_void, constr: *const c_void, z: *const c_void, constr_eps: f64, ocvrs_return: *mut Result<i32>);
		pub fn cv_solvePoly_const__InputArrayR_const__OutputArrayR(coeffs: *const c_void, roots: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_solvePoly_const__InputArrayR_const__OutputArrayR_int(coeffs: *const c_void, roots: *const c_void, max_iters: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_solve_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_solve_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_sortIdx_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_sort_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_split_const_MatR_MatX(src: *const c_void, mvbegin: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_split_const__InputArrayR_const__OutputArrayR(m: *const c_void, mv: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sqrt_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_subtract_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_subtract_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, dtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_sum_const__InputArrayR(src: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_swap_MatR_MatR(a: *mut c_void, b: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_swap_UMatR_UMatR(a: *mut c_void, b: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_tempfile(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_tempfile_const_charX(suffix: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_theRNG(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_trace_const__InputArrayR(mtx: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_transform_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_transposeND_const__InputArrayR_const_vectorLintGR_const__OutputArrayR(src: *const c_void, order: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_transpose_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_typeToString_int(typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_useOpenVX(ocvrs_return: *mut Result<bool>);
		pub fn cv_useOptimized(ocvrs_return: *mut Result<bool>);
		pub fn cv_utils_copyMatAndDumpNamedArguments_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_copyMatAndDumpNamedArguments_const__InputArrayR_const__OutputArrayR_const_FunctionParamsR(src: *const c_void, dst: *const c_void, params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpBool_bool(argument: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpCString_const_charX(argument: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpDouble_double(argument: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpFloat_float(argument: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpInputArrayOfArrays_const__InputArrayR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpInputArray_const__InputArrayR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpInputOutputArrayOfArrays_const__InputOutputArrayR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpInputOutputArray_const__InputOutputArrayR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpInt64_int64_t(argument: i64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpInt_int(argument: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpRange_const_RangeR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpRect_const_RectR(argument: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpRotatedRect_const_RotatedRectR(argument: *const core::RotatedRect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpSizeT_size_t(argument: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpString_const_StringR(argument: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpTermCriteria_const_TermCriteriaR(argument: *const core::TermCriteria, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpVec2i(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpVec2i_const_Vec2i(value: *const core::Vec2i, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpVectorOfDouble_const_vectorLdoubleGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpVectorOfInt_const_vectorLintGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpVectorOfRect_const_vectorLRectGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_fs_getCacheDirectoryForDownloads(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_generateVectorOfInt_size_t_vectorLintGR(len: size_t, vec: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_utils_generateVectorOfMat_size_t_int_int_int_vectorLMatGR(len: size_t, rows: i32, cols: i32, dtype: i32, vec: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_utils_generateVectorOfRect_size_t_vectorLRectGR(len: size_t, vec: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_utils_getThreadID(ocvrs_return: *mut Result<i32>);
		pub fn cv_utils_logging_getLogLevel(ocvrs_return: *mut Result<core::LogLevel>);
		pub fn cv_utils_logging_getLogTagLevel_const_charX(tag: *const c_char, ocvrs_return: *mut Result<core::LogLevel>);
		pub fn cv_utils_logging_internal_getGlobalLogTag(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_logging_internal_writeLogMessageEx_LogLevel_const_charX_const_charX_int_const_charX_const_charX(log_level: core::LogLevel, tag: *const c_char, file: *const c_char, line: i32, func: *const c_char, message: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_utils_logging_internal_writeLogMessage_LogLevel_const_charX(log_level: core::LogLevel, message: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_utils_logging_registerLogTag_LogTagX(plogtag: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_utils_logging_setLogLevel_LogLevel(log_level: core::LogLevel, ocvrs_return: *mut Result<core::LogLevel>);
		pub fn cv_utils_logging_setLogTagLevel_const_charX_LogLevel(tag: *const c_char, level: core::LogLevel, ocvrs_return: *mut Result_void);
		pub fn cv_utils_nested_testEchoBooleanFunction_bool(flag: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_utils_testAsyncArray_const__InputArrayR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testAsyncException(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testOverloadResolution_const_RectR(rect: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testOverloadResolution_int(value: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testOverloadResolution_int_const_PointR(value: i32, point: *const core::Point, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testOverwriteNativeMethod_int(argument: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_utils_testRaiseGeneralException(ocvrs_return: *mut Result_void);
		pub fn cv_utils_testReservedKeywordConversion_int(positional_argument: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testReservedKeywordConversion_int_int_int(positional_argument: i32, lambda: i32, from: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testRotatedRectVector_float_float_float_float_float(x: f32, y: f32, w: f32, h: f32, angle: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testRotatedRect_float_float_float_float_float(x: f32, y: f32, w: f32, h: f32, angle: f32, ocvrs_return: *mut Result<core::RotatedRect>);
		pub fn cv_va_intel_convertFromVASurface_VADisplay_VASurfaceID_Size_const__OutputArrayR(display: *mut c_void, surface: core::va_surface_id, size: *const core::Size, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_va_intel_convertToVASurface_VADisplay_const__InputArrayR_VASurfaceID_Size(display: *mut c_void, src: *const c_void, surface: core::va_surface_id, size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_va_intel_ocl_initializeContextFromVA_VADisplay(display: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_va_intel_ocl_initializeContextFromVA_VADisplay_bool(display: *mut c_void, try_interop: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_vconcat_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_vconcat_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_writeScalar_FileStorageR_const_StringR(fs: *mut c_void, value: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_writeScalar_FileStorageR_double(fs: *mut c_void, value: f64, ocvrs_return: *mut Result_void);
		pub fn cv_writeScalar_FileStorageR_float(fs: *mut c_void, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_writeScalar_FileStorageR_int(fs: *mut c_void, value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_write_FileStorageR_const_StringR_const_MatR(fs: *mut c_void, name: *const c_char, value: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_write_FileStorageR_const_StringR_const_SparseMatR(fs: *mut c_void, name: *const c_char, value: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_write_FileStorageR_const_StringR_const_StringR(fs: *mut c_void, name: *const c_char, value: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_write_FileStorageR_const_StringR_const_vectorLDMatchGR(fs: *mut c_void, name: *const c_char, value: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_write_FileStorageR_const_StringR_const_vectorLKeyPointGR(fs: *mut c_void, name: *const c_char, value: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_write_FileStorageR_const_StringR_double(fs: *mut c_void, name: *const c_char, value: f64, ocvrs_return: *mut Result_void);
		pub fn cv_write_FileStorageR_const_StringR_float(fs: *mut c_void, name: *const c_char, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_write_FileStorageR_const_StringR_int(fs: *mut c_void, name: *const c_char, value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Algorithm_Algorithm(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Algorithm_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Algorithm_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Algorithm_write_const_FileStorageR_const_StringR(instance: *const c_void, fs: *mut c_void, name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_Algorithm_write_const_const_PtrLFileStorageGR_const_StringR(instance: *const c_void, fs: *const c_void, name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_Algorithm_write_const_const_PtrLFileStorageGR(instance: *const c_void, fs: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Algorithm_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Algorithm_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_Algorithm_save_const_const_StringR(instance: *const c_void, filename: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_Algorithm_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Algorithm_to_ConjGradSolver(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Algorithm_to_DownhillSolver(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Algorithm_to_MinProblemSolver(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Algorithm_delete(instance: *mut c_void);
		pub fn cv_AsyncArray_AsyncArray() -> *mut c_void;
		pub fn cv_AsyncArray_AsyncArray_const_AsyncArrayR(o: *const c_void) -> *mut c_void;
		pub fn cv_AsyncArray_operatorST_const_AsyncArrayR(instance: *mut c_void, o: *const c_void);
		pub fn cv_AsyncArray_release(instance: *mut c_void);
		pub fn cv_AsyncArray_get_const_const__OutputArrayR(instance: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_AsyncArray_get_const_const__OutputArrayR_int64_t(instance: *const c_void, dst: *const c_void, timeout_ns: i64, ocvrs_return: *mut Result<bool>);
		pub fn cv_AsyncArray_get_const_const__OutputArrayR_double(instance: *const c_void, dst: *const c_void, timeout_ns: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_AsyncArray_wait_for_const_int64_t(instance: *const c_void, timeout_ns: i64, ocvrs_return: *mut Result<bool>);
		pub fn cv_AsyncArray_wait_for_const_double(instance: *const c_void, timeout_ns: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_AsyncArray_valid_const(instance: *const c_void) -> bool;
		pub fn cv_AsyncArray_AsyncArray_AsyncArrayRR(o: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AsyncArray_operatorST_AsyncArrayRR(instance: *mut c_void, o: *mut c_void);
		pub fn cv_AsyncArray_delete(instance: *mut c_void);
		pub fn cv_AsyncPromise_AsyncPromise() -> *mut c_void;
		pub fn cv_AsyncPromise_AsyncPromise_const_AsyncPromiseR(o: *const c_void) -> *mut c_void;
		pub fn cv_AsyncPromise_operatorST_const_AsyncPromiseR(instance: *mut c_void, o: *const c_void);
		pub fn cv_AsyncPromise_release(instance: *mut c_void);
		pub fn cv_AsyncPromise_getArrayResult(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AsyncPromise_setValue_const__InputArrayR(instance: *mut c_void, value: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_AsyncPromise_setException_const_ExceptionR(instance: *mut c_void, exception: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_AsyncPromise_AsyncPromise_AsyncPromiseRR(o: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AsyncPromise_operatorST_AsyncPromiseRR(instance: *mut c_void, o: *mut c_void);
		pub fn cv_AsyncPromise__getImpl_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_AsyncPromise_delete(instance: *mut c_void);
		pub fn cv_CommandLineParser_CommandLineParser_int_const_charXX_const_StringR(argc: i32, argv: *const *const c_char, keys: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CommandLineParser_CommandLineParser_const_CommandLineParserR(parser: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CommandLineParser_operatorST_const_CommandLineParserR(instance: *mut c_void, parser: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_CommandLineParser_getPathToApplication_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CommandLineParser_get_bool_const_const_StringR_bool(instance: *const c_void, name: *const c_char, space_delete: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_CommandLineParser_get_bool_const_const_StringR(instance: *const c_void, name: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_CommandLineParser_get_int_const_const_StringR_bool(instance: *const c_void, name: *const c_char, space_delete: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_CommandLineParser_get_int_const_const_StringR(instance: *const c_void, name: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_CommandLineParser_get_double_const_const_StringR_bool(instance: *const c_void, name: *const c_char, space_delete: bool, ocvrs_return: *mut Result<f64>);
		pub fn cv_CommandLineParser_get_double_const_const_StringR(instance: *const c_void, name: *const c_char, ocvrs_return: *mut Result<f64>);
		pub fn cv_CommandLineParser_get_cv_String_const_const_StringR_bool(instance: *const c_void, name: *const c_char, space_delete: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CommandLineParser_get_cv_String_const_const_StringR(instance: *const c_void, name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CommandLineParser_get_uint64_t_const_const_StringR_bool(instance: *const c_void, name: *const c_char, space_delete: bool, ocvrs_return: *mut Result<u64>);
		pub fn cv_CommandLineParser_get_uint64_t_const_const_StringR(instance: *const c_void, name: *const c_char, ocvrs_return: *mut Result<u64>);
		pub fn cv_CommandLineParser_get_bool_const_int_bool(instance: *const c_void, index: i32, space_delete: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_CommandLineParser_get_bool_const_int(instance: *const c_void, index: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_CommandLineParser_get_int_const_int_bool(instance: *const c_void, index: i32, space_delete: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_CommandLineParser_get_int_const_int(instance: *const c_void, index: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_CommandLineParser_get_double_const_int_bool(instance: *const c_void, index: i32, space_delete: bool, ocvrs_return: *mut Result<f64>);
		pub fn cv_CommandLineParser_get_double_const_int(instance: *const c_void, index: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_CommandLineParser_get_cv_String_const_int_bool(instance: *const c_void, index: i32, space_delete: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CommandLineParser_get_cv_String_const_int(instance: *const c_void, index: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CommandLineParser_get_uint64_t_const_int_bool(instance: *const c_void, index: i32, space_delete: bool, ocvrs_return: *mut Result<u64>);
		pub fn cv_CommandLineParser_get_uint64_t_const_int(instance: *const c_void, index: i32, ocvrs_return: *mut Result<u64>);
		pub fn cv_CommandLineParser_has_const_const_StringR(instance: *const c_void, name: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_CommandLineParser_check_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_CommandLineParser_about_const_StringR(instance: *mut c_void, message: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_CommandLineParser_printMessage_const(instance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_CommandLineParser_printErrors_const(instance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_CommandLineParser_delete(instance: *mut c_void);
		pub fn cv_ConjGradSolver_create_const_PtrLFunctionGR_TermCriteria(f: *const c_void, termcrit: *const core::TermCriteria, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ConjGradSolver_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ConjGradSolver_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ConjGradSolver_to_MinProblemSolver(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ConjGradSolver_delete(instance: *mut c_void);
		pub fn cv_DMatch_DMatch(ocvrs_return: *mut Result<core::DMatch>);
		pub fn cv_DMatch_DMatch_int_int_float(_query_idx: i32, _train_idx: i32, _distance: f32, ocvrs_return: *mut Result<core::DMatch>);
		pub fn cv_DMatch_DMatch_int_int_int_float(_query_idx: i32, _train_idx: i32, _img_idx: i32, _distance: f32, ocvrs_return: *mut Result<core::DMatch>);
		pub fn cv_DMatch_operatorL_const_const_DMatchR(instance: *const core::DMatch, m: *const core::DMatch, ocvrs_return: *mut Result<bool>);
		pub fn cv_DownhillSolver_getInitStep_const_const__OutputArrayR(instance: *const c_void, step: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DownhillSolver_setInitStep_const__InputArrayR(instance: *mut c_void, step: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DownhillSolver_create_const_PtrLFunctionGR_const__InputArrayR_TermCriteria(f: *const c_void, init_step: *const c_void, termcrit: *const core::TermCriteria, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DownhillSolver_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DownhillSolver_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_DownhillSolver_to_MinProblemSolver(instance: *mut c_void) -> *mut c_void;
		pub fn cv_DownhillSolver_delete(instance: *mut c_void);
		pub fn cv_Exception_Exception(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Exception_Exception_int_const_StringR_const_StringR_const_StringR_int(_code: i32, _err: *const c_char, _func: *const c_char, _file: *const c_char, _line: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Exception_what_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Exception_formatMessage(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Exception_propMsg_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Exception_propMsg_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_Exception_propCode_const(instance: *const c_void) -> i32;
		pub fn cv_Exception_propCode_int(instance: *mut c_void, val: i32);
		pub fn cv_Exception_propErr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Exception_propErr_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_Exception_propFunc_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Exception_propFunc_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_Exception_propFile_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Exception_propFile_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_Exception_propLine_const(instance: *const c_void) -> i32;
		pub fn cv_Exception_propLine_int(instance: *mut c_void, val: i32);
		pub fn cv_Exception_delete(instance: *mut c_void);
		pub fn cv_FileNode_FileNode(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_FileNode_const_FileStorageX_size_t_size_t(fs: *const c_void, block_idx: size_t, ofs: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_FileNode_const_FileNodeR(node: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_operatorST_const_FileNodeR(instance: *mut c_void, node: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FileNode_operator___const_const_StringR(instance: *const c_void, nodename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_operator___const_const_charX(instance: *const c_void, nodename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_operator___const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_keys_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FileNode_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isNone_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isSeq_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isMap_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isInt_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isReal_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isString_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isNamed_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_name_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_size_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_FileNode_rawSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_FileNode_operator_int_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FileNode_operator_float_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_FileNode_operator_double_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_FileNode_operator_std_string_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_isMap_int(flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isSeq_int(flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isCollection_int(flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isEmptyCollection_int(flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isFlow_int(flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_ptr(instance: *mut c_void, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_FileNode_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_FileNode_begin_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_end_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_readRaw_const_const_StringR_voidX_size_t(instance: *const c_void, fmt: *const c_char, vec: *mut c_void, len: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_FileNode_setValue_int_const_voidX_int(instance: *mut c_void, typ: i32, value: *const c_void, len: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FileNode_setValue_int_const_voidX(instance: *mut c_void, typ: i32, value: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FileNode_real_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_FileNode_string_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_mat_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_FileNode_propBlockIdx_const(instance: *const c_void) -> size_t;
		pub fn cv_FileNode_propBlockIdx_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_FileNode_propOfs_const(instance: *const c_void) -> size_t;
		pub fn cv_FileNode_propOfs_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_FileNode_delete(instance: *mut c_void);
		pub fn cv_FileNodeIterator_FileNodeIterator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_FileNodeIterator_const_FileNodeR_bool(node: *const c_void, seek_end: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_FileNodeIterator_const_FileNodeIteratorR(it: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_operatorST_const_FileNodeIteratorR(instance: *mut c_void, it: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FileNodeIterator_operatorX_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_operatorAA(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_readRaw_const_StringR_voidX_size_t(instance: *mut c_void, fmt: *const c_char, vec: *mut c_void, len: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_readRaw_const_StringR_voidX(instance: *mut c_void, fmt: *const c_char, vec: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_remaining_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_FileNodeIterator_equalTo_const_const_FileNodeIteratorR(instance: *const c_void, it: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNodeIterator_delete(instance: *mut c_void);
		pub fn cv_FileStorage_FileStorage(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_FileStorage_const_StringR_int_const_StringR(filename: *const c_char, flags: i32, encoding: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_FileStorage_const_StringR_int(filename: *const c_char, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_open_const_StringR_int_const_StringR(instance: *mut c_void, filename: *const c_char, flags: i32, encoding: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileStorage_open_const_StringR_int(instance: *mut c_void, filename: *const c_char, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileStorage_isOpened_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileStorage_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_releaseAndGetString(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_getFirstTopLevelNode_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_root_const_int(instance: *const c_void, streamidx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_root_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_operator___const_const_StringR(instance: *const c_void, nodename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_operator___const_const_charX(instance: *const c_void, nodename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_write_const_StringR_int(instance: *mut c_void, name: *const c_char, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_write_const_StringR_double(instance: *mut c_void, name: *const c_char, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_write_const_StringR_const_StringR(instance: *mut c_void, name: *const c_char, val: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_write_const_StringR_const_MatR(instance: *mut c_void, name: *const c_char, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_write_const_StringR_const_vectorLStringGR(instance: *mut c_void, name: *const c_char, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_writeRaw_const_StringR_const_voidX_size_t(instance: *mut c_void, fmt: *const c_char, vec: *const c_void, len: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_writeComment_const_StringR_bool(instance: *mut c_void, comment: *const c_char, append: bool, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_writeComment_const_StringR(instance: *mut c_void, comment: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_startWriteStruct_const_StringR_int_const_StringR(instance: *mut c_void, name: *const c_char, flags: i32, type_name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_startWriteStruct_const_StringR_int(instance: *mut c_void, name: *const c_char, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_endWriteStruct(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FileStorage_getDefaultObjectName_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_getFormat_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FileStorage_propState_const(instance: *const c_void) -> i32;
		pub fn cv_FileStorage_propState_int(instance: *mut c_void, val: i32);
		pub fn cv_FileStorage_propElname_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_FileStorage_propElname_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_FileStorage_delete(instance: *mut c_void);
		pub fn cv_Formatted_next(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Formatted_reset(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Formatted_delete(instance: *mut c_void);
		pub fn cv_Formatter_format_const_const_MatR(instance: *const c_void, mtx: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Formatter_set16fPrecision_int(instance: *mut c_void, p: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Formatter_set16fPrecision(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Formatter_set32fPrecision_int(instance: *mut c_void, p: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Formatter_set32fPrecision(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Formatter_set64fPrecision_int(instance: *mut c_void, p: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Formatter_set64fPrecision(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Formatter_setMultiline_bool(instance: *mut c_void, ml: bool, ocvrs_return: *mut Result_void);
		pub fn cv_Formatter_setMultiline(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Formatter_get_FormatType(fmt: core::Formatter_FormatType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Formatter_get(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Formatter_delete(instance: *mut c_void);
		pub fn cv_Hamming_operator___const_const_unsigned_charX_const_unsigned_charX_int(instance: *const c_void, a: *const u8, b: *const u8, size: i32, ocvrs_return: *mut Result<core::Hamming_result_type>);
		pub fn cv_Hamming_delete(instance: *mut c_void);
		pub fn cv_KeyPoint_KeyPoint(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KeyPoint_KeyPoint_Point2f_float_float_float_int_int(pt: *const core::Point2f, size: f32, angle: f32, response: f32, octave: i32, class_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KeyPoint_KeyPoint_Point2f_float(pt: *const core::Point2f, size: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KeyPoint_KeyPoint_float_float_float_float_float_int_int(x: f32, y: f32, size: f32, angle: f32, response: f32, octave: i32, class_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KeyPoint_KeyPoint_float_float_float(x: f32, y: f32, size: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KeyPoint_hash_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_KeyPoint_convert_const_vectorLKeyPointGR_vectorLPoint2fGR_const_vectorLintGR(keypoints: *const c_void, points2f: *mut c_void, keypoint_indexes: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPoint_convert_const_vectorLKeyPointGR_vectorLPoint2fGR(keypoints: *const c_void, points2f: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPoint_convert_const_vectorLPoint2fGR_vectorLKeyPointGR_float_float_int_int(points2f: *const c_void, keypoints: *mut c_void, size: f32, response: f32, octave: i32, class_id: i32, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPoint_convert_const_vectorLPoint2fGR_vectorLKeyPointGR(points2f: *const c_void, keypoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPoint_overlap_const_KeyPointR_const_KeyPointR(kp1: *const c_void, kp2: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_KeyPoint_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KeyPoint_propPt_const(instance: *const c_void, ocvrs_return: *mut core::Point2f);
		pub fn cv_KeyPoint_propPt_Point2f(instance: *mut c_void, val: *const core::Point2f);
		pub fn cv_KeyPoint_propSize_const(instance: *const c_void) -> f32;
		pub fn cv_KeyPoint_propSize_float(instance: *mut c_void, val: f32);
		pub fn cv_KeyPoint_propAngle_const(instance: *const c_void) -> f32;
		pub fn cv_KeyPoint_propAngle_float(instance: *mut c_void, val: f32);
		pub fn cv_KeyPoint_propResponse_const(instance: *const c_void) -> f32;
		pub fn cv_KeyPoint_propResponse_float(instance: *mut c_void, val: f32);
		pub fn cv_KeyPoint_propOctave_const(instance: *const c_void) -> i32;
		pub fn cv_KeyPoint_propOctave_int(instance: *mut c_void, val: i32);
		pub fn cv_KeyPoint_propClass_id_const(instance: *const c_void) -> i32;
		pub fn cv_KeyPoint_propClass_id_int(instance: *mut c_void, val: i32);
		pub fn cv_KeyPoint_delete(instance: *mut c_void);
		pub fn cv_LDA_LDA_int(num_components: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_LDA(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_LDA_const__InputArrayR_const__InputArrayR_int(src: *const c_void, labels: *const c_void, num_components: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_LDA_const__InputArrayR_const__InputArrayR(src: *const c_void, labels: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_save_const_const_StringR(instance: *const c_void, filename: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_LDA_load_const_StringR(instance: *mut c_void, filename: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_LDA_save_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_LDA_load_const_FileStorageR(instance: *mut c_void, node: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_LDA_compute_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, labels: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_LDA_project_const__InputArrayR(instance: *mut c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_reconstruct_const__InputArrayR(instance: *mut c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_eigenvectors_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_eigenvalues_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_subspaceProject_const__InputArrayR_const__InputArrayR_const__InputArrayR(w: *const c_void, mean: *const c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_subspaceReconstruct_const__InputArrayR_const__InputArrayR_const__InputArrayR(w: *const c_void, mean: *const c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_delete(instance: *mut c_void);
		pub fn cv_Mat_Mat() -> *mut c_void;
		pub fn cv_Mat_Mat_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_int_int_const_ScalarR(rows: i32, cols: i32, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_Size_int_const_ScalarR(size: *const core::Size, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_const_intX_int(ndims: i32, sizes: *const i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_vectorLintGR_int(sizes: *const c_void, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_const_intX_int_const_ScalarR(ndims: i32, sizes: *const i32, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_vectorLintGR_int_const_ScalarR(sizes: *const c_void, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_int_int_voidX_size_t(rows: i32, cols: i32, typ: i32, data: *mut c_void, step: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_int_int_voidX(rows: i32, cols: i32, typ: i32, data: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_Size_int_voidX_size_t(size: *const core::Size, typ: i32, data: *mut c_void, step: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_Size_int_voidX(size: *const core::Size, typ: i32, data: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_const_intX_int_voidX_const_size_tX(ndims: i32, sizes: *const i32, typ: i32, data: *mut c_void, steps: *const size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_const_intX_int_voidX(ndims: i32, sizes: *const i32, typ: i32, data: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_vectorLintGR_int_voidX_const_size_tX(sizes: *const c_void, typ: i32, data: *mut c_void, steps: *const size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_vectorLintGR_int_voidX(sizes: *const c_void, typ: i32, data: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_MatR_const_RangeR_const_RangeR(m: *const c_void, row_range: *const c_void, col_range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_MatR_const_RangeR(m: *const c_void, row_range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_MatR_const_RectR(m: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_MatR_const_vectorLRangeGR(m: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_GpuMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_operatorST_const_MatR(instance: *mut c_void, m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_operatorST_const_MatExprR(instance: *mut c_void, expr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_getUMat_const_AccessFlag_UMatUsageFlags(instance: *const c_void, access_flags: core::AccessFlag, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_getUMat_const_AccessFlag(instance: *const c_void, access_flags: core::AccessFlag, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_row_const_int(instance: *const c_void, y: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_col_const_int(instance: *const c_void, x: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_rowRange_const_int_int(instance: *const c_void, startrow: i32, endrow: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_rowRange_const_const_RangeR(instance: *const c_void, r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_colRange_const_int_int(instance: *const c_void, startcol: i32, endcol: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_colRange_const_const_RangeR(instance: *const c_void, r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_diag_const_int(instance: *const c_void, d: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_diag_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_diag_const_MatR(d: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_copyTo_const_const__OutputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_copyTo_const_const__OutputArrayR_const__InputArrayR(instance: *const c_void, m: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_convertTo_const_const__OutputArrayR_int_double_double(instance: *const c_void, m: *const c_void, rtype: i32, alpha: f64, beta: f64, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_convertTo_const_const__OutputArrayR_int(instance: *const c_void, m: *const c_void, rtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_assignTo_const_MatR_int(instance: *const c_void, m: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_assignTo_const_MatR(instance: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_operatorST_const_ScalarR(instance: *mut c_void, s: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_setTo_const__InputArrayR_const__InputArrayR(instance: *mut c_void, value: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_setTo_const__InputArrayR(instance: *mut c_void, value: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_reshape_const_int_int(instance: *const c_void, cn: i32, rows: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_reshape_const_int(instance: *const c_void, cn: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_reshape_const_int_int_const_intX(instance: *const c_void, cn: i32, newndims: i32, newsz: *const i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_reshape_const_int_const_vectorLintGR(instance: *const c_void, cn: i32, newshape: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_t_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_inv_const_int(instance: *const c_void, method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_inv_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_mul_const_const__InputArrayR_double(instance: *const c_void, m: *const c_void, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_mul_const_const__InputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_cross_const_const__InputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_dot_const_const__InputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_Mat_zeros_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_zeros_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_zeros_int_const_intX_int(ndims: i32, sz: *const i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_ones_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_ones_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_ones_int_const_intX_int(ndims: i32, sz: *const i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_eye_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_eye_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_create_int_int_int(instance: *mut c_void, rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_create_Size_int(instance: *mut c_void, size: *const core::Size, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_create_int_const_intX_int(instance: *mut c_void, ndims: i32, sizes: *const i32, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_create_const_vectorLintGR_int(instance: *mut c_void, sizes: *const c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_addref(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_deallocate(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_reserve_size_t(instance: *mut c_void, sz: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_reserveBuffer_size_t(instance: *mut c_void, sz: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_resize_size_t(instance: *mut c_void, sz: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_resize_size_t_const_ScalarR(instance: *mut c_void, sz: size_t, s: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_push_back_const_MatR(instance: *mut c_void, m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_pop_back_size_t(instance: *mut c_void, nelems: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_pop_back(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_locateROI_const_SizeR_PointR(instance: *const c_void, whole_size: *mut core::Size, ofs: *mut core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_adjustROI_int_int_int_int(instance: *mut c_void, dtop: i32, dbottom: i32, dleft: i32, dright: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_operator___const_Range_Range(instance: *const c_void, row_range: *mut c_void, col_range: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_operator___const_const_RectR(instance: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_operator___const_const_RangeX(instance: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_operator___const_const_vectorLRangeGR(instance: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_isContinuous_const(instance: *const c_void) -> bool;
		pub fn cv_Mat_isSubmatrix_const(instance: *const c_void) -> bool;
		pub fn cv_Mat_elemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_Mat_elemSize1_const(instance: *const c_void) -> size_t;
		pub fn cv_Mat_type_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_depth_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_channels_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_step1_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_Mat_step1_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_Mat_empty_const(instance: *const c_void) -> bool;
		pub fn cv_Mat_total_const(instance: *const c_void) -> size_t;
		pub fn cv_Mat_total_const_int_int(instance: *const c_void, start_dim: i32, end_dim: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_Mat_total_const_int(instance: *const c_void, start_dim: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_Mat_checkVector_const_int_int_bool(instance: *const c_void, elem_channels: i32, depth: i32, require_continuous: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_Mat_checkVector_const_int(instance: *const c_void, elem_channels: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Mat_ptr_int(instance: *mut c_void, i0: i32, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_Mat_ptr(instance: *mut c_void, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_Mat_ptr_const_int(instance: *const c_void, i0: i32, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_Mat_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_Mat_ptr_int_int(instance: *mut c_void, row: i32, col: i32, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_Mat_ptr_const_int_int(instance: *const c_void, row: i32, col: i32, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_Mat_ptr_int_int_int(instance: *mut c_void, i0: i32, i1: i32, i2: i32, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_Mat_ptr_const_int_int_int(instance: *const c_void, i0: i32, i1: i32, i2: i32, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_Mat_ptr_const_intX(instance: *mut c_void, idx: *const i32, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_Mat_ptr_const_const_intX(instance: *const c_void, idx: *const i32, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_Mat_Mat_MatRR(m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_operatorST_MatRR(instance: *mut c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_updateContinuityFlag(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Mat_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_Mat_data_const(instance: *const c_void) -> *const u8;
		pub fn cv_Mat_propFlags_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_propFlags_int(instance: *mut c_void, val: i32);
		pub fn cv_Mat_propDims_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_propDims_int(instance: *mut c_void, val: i32);
		pub fn cv_Mat_propRows_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_propRows_int(instance: *mut c_void, val: i32);
		pub fn cv_Mat_propCols_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_propCols_int(instance: *mut c_void, val: i32);
		pub fn cv_Mat_propData(instance: *mut c_void) -> *mut u8;
		pub fn cv_Mat_propData_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_Mat_propDatastart_const(instance: *const c_void) -> *const u8;
		pub fn cv_Mat_propDataend_const(instance: *const c_void) -> *const u8;
		pub fn cv_Mat_propDatalimit_const(instance: *const c_void) -> *const u8;
		pub fn cv_Mat_propU(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Mat_propU_UMatDataX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_Mat_propSize_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Mat_propStep_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Mat_delete(instance: *mut c_void);
		pub fn cv_MatConstIterator_MatConstIterator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_MatConstIterator_const_MatX(_m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_MatConstIterator_const_MatX_int_int(_m: *const c_void, _row: i32, _col: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_MatConstIterator_const_MatX_int(_m: *const c_void, _row: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_MatConstIterator_const_MatX_Point(_m: *const c_void, _pt: *const core::Point, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_MatConstIterator_const_MatConstIteratorR(it: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_operatorST_const_MatConstIteratorR(instance: *mut c_void, it: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatConstIterator_operatorX_const(instance: *const c_void, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_MatConstIterator_operator___const_ptrdiff_t(instance: *const c_void, i: ptrdiff_t, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_MatConstIterator_operatorSS(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_operatorAA(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_pos_const(instance: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_MatConstIterator_pos_const_intX(instance: *const c_void, _idx: *mut i32, ocvrs_return: *mut Result_void);
		pub fn cv_MatConstIterator_lpos_const(instance: *const c_void, ocvrs_return: *mut Result<ptrdiff_t>);
		pub fn cv_MatConstIterator_seek_ptrdiff_t_bool(instance: *mut c_void, ofs: ptrdiff_t, relative: bool, ocvrs_return: *mut Result_void);
		pub fn cv_MatConstIterator_seek_ptrdiff_t(instance: *mut c_void, ofs: ptrdiff_t, ocvrs_return: *mut Result_void);
		pub fn cv_MatConstIterator_seek_const_intX_bool(instance: *mut c_void, _idx: *const i32, relative: bool, ocvrs_return: *mut Result_void);
		pub fn cv_MatConstIterator_seek_const_intX(instance: *mut c_void, _idx: *const i32, ocvrs_return: *mut Result_void);
		pub fn cv_MatConstIterator_hasElements_const(instance: *const c_void) -> bool;
		pub fn cv_MatConstIterator_type_const(instance: *const c_void) -> i32;
		pub fn cv_MatConstIterator_propM_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_MatConstIterator_propElemSize_const(instance: *const c_void) -> size_t;
		pub fn cv_MatConstIterator_propElemSize_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_MatConstIterator_propPtr_const(instance: *const c_void) -> *const u8;
		pub fn cv_MatConstIterator_propSliceStart_const(instance: *const c_void) -> *const u8;
		pub fn cv_MatConstIterator_propSliceEnd_const(instance: *const c_void) -> *const u8;
		pub fn cv_MatConstIterator_delete(instance: *mut c_void);
		pub fn cv_MatExpr_MatExpr(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_MatExpr_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_MatExpr_const_MatOpX_int_const_MatR_const_MatR_const_MatR_double_double_const_ScalarR(_op: *const c_void, _flags: i32, _a: *const c_void, _b: *const c_void, _c: *const c_void, _alpha: f64, _beta: f64, _s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_MatExpr_const_MatOpX_int(_op: *const c_void, _flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_operator_cv_Mat_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_MatExpr_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_MatExpr_row_const_int(instance: *const c_void, y: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_col_const_int(instance: *const c_void, x: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_diag_const_int(instance: *const c_void, d: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_diag_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_operator___const_const_RangeR_const_RangeR(instance: *const c_void, row_range: *const c_void, col_range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_operator___const_const_RectR(instance: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_t_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_inv_const_int(instance: *const c_void, method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_inv_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_mul_const_const_MatExprR_double(instance: *const c_void, e: *const c_void, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_mul_const_const_MatExprR(instance: *const c_void, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_mul_const_const_MatR_double(instance: *const c_void, m: *const c_void, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_mul_const_const_MatR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_cross_const_const_MatR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_dot_const_const_MatR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_MatExpr_swap_MatExprR(instance: *mut c_void, b: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatExpr_propFlags_const(instance: *const c_void) -> i32;
		pub fn cv_MatExpr_propFlags_int(instance: *mut c_void, val: i32);
		pub fn cv_MatExpr_propA_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_MatExpr_propA_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_MatExpr_propB_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_MatExpr_propB_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_MatExpr_propC_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_MatExpr_propC_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_MatExpr_propAlpha_const(instance: *const c_void) -> f64;
		pub fn cv_MatExpr_propAlpha_double(instance: *mut c_void, val: f64);
		pub fn cv_MatExpr_propBeta_const(instance: *const c_void) -> f64;
		pub fn cv_MatExpr_propBeta_double(instance: *mut c_void, val: f64);
		pub fn cv_MatExpr_propS_const(instance: *const c_void, ocvrs_return: *mut core::Scalar);
		pub fn cv_MatExpr_propS_Scalar(instance: *mut c_void, val: *const core::Scalar);
		pub fn cv_MatExpr_delete(instance: *mut c_void);
		pub fn cv_MatOp_elementWise_const_const_MatExprR(instance: *const c_void, expr: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_MatOp_assign_const_const_MatExprR_MatR_int(instance: *const c_void, expr: *const c_void, m: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_assign_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_roi_const_const_MatExprR_const_RangeR_const_RangeR_MatExprR(instance: *const c_void, expr: *const c_void, row_range: *const c_void, col_range: *const c_void, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_diag_const_const_MatExprR_int_MatExprR(instance: *const c_void, expr: *const c_void, d: i32, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_augAssignAdd_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_augAssignSubtract_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_augAssignMultiply_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_augAssignDivide_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_augAssignAnd_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_augAssignOr_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_augAssignXor_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_add_const_const_MatExprR_const_MatExprR_MatExprR(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_add_const_const_MatExprR_const_ScalarR_MatExprR(instance: *const c_void, expr1: *const c_void, s: *const core::Scalar, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_subtract_const_const_MatExprR_const_MatExprR_MatExprR(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_subtract_const_const_ScalarR_const_MatExprR_MatExprR(instance: *const c_void, s: *const core::Scalar, expr: *const c_void, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_multiply_const_const_MatExprR_const_MatExprR_MatExprR_double(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_multiply_const_const_MatExprR_const_MatExprR_MatExprR(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_multiply_const_const_MatExprR_double_MatExprR(instance: *const c_void, expr1: *const c_void, s: f64, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_divide_const_const_MatExprR_const_MatExprR_MatExprR_double(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_divide_const_const_MatExprR_const_MatExprR_MatExprR(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_divide_const_double_const_MatExprR_MatExprR(instance: *const c_void, s: f64, expr: *const c_void, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_abs_const_const_MatExprR_MatExprR(instance: *const c_void, expr: *const c_void, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_transpose_const_const_MatExprR_MatExprR(instance: *const c_void, expr: *const c_void, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_matmul_const_const_MatExprR_const_MatExprR_MatExprR(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_invert_const_const_MatExprR_int_MatExprR(instance: *const c_void, expr: *const c_void, method: i32, res: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MatOp_size_const_const_MatExprR(instance: *const c_void, expr: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_MatOp_type_const_const_MatExprR(instance: *const c_void, expr: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_MatOp_delete(instance: *mut c_void);
		pub fn cv_MatSize_MatSize_intX(_p: *mut i32) -> *mut c_void;
		pub fn cv_MatSize_dims_const(instance: *const c_void) -> i32;
		pub fn cv_MatSize_operator___const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_MatSize_operator___const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_MatSize_operator___int(instance: *mut c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_MatSize_operator_const_intX_const(instance: *const c_void) -> *const i32;
		pub fn cv_MatSize_operatorEQ_const_const_MatSizeR(instance: *const c_void, sz: *const c_void) -> bool;
		pub fn cv_MatSize_operatorNE_const_const_MatSizeR(instance: *const c_void, sz: *const c_void) -> bool;
		pub fn cv_MatSize_propP(instance: *mut c_void) -> *mut i32;
		pub fn cv_MatSize_propP_intX(instance: *mut c_void, val: *mut i32);
		pub fn cv_MatSize_delete(instance: *mut c_void);
		pub fn cv_MatStep_MatStep() -> *mut c_void;
		pub fn cv_MatStep_MatStep_size_t(s: size_t) -> *mut c_void;
		pub fn cv_MatStep_operator___const_int(instance: *const c_void, i: i32) -> size_t;
		pub fn cv_MatStep_operator___int(instance: *mut c_void, i: i32) -> size_t;
		pub fn cv_MatStep_operator_size_t_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_MatStep_operatorST_size_t(instance: *mut c_void, s: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_MatStep_propP(instance: *mut c_void) -> *mut size_t;
		pub fn cv_MatStep_propP_size_tX(instance: *mut c_void, val: *mut size_t);
		pub fn cv_MatStep_propBuf(instance: *mut c_void) -> *mut [size_t; 2];
		pub fn cv_MatStep_delete(instance: *mut c_void);
		pub fn cv_Matx_AddOp_Matx_AddOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_AddOp_Matx_AddOp_const_Matx_AddOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_AddOp_delete(instance: *mut c_void);
		pub fn cv_Matx_DivOp_Matx_DivOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_DivOp_Matx_DivOp_const_Matx_DivOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_DivOp_delete(instance: *mut c_void);
		pub fn cv_Matx_MatMulOp_Matx_MatMulOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_MatMulOp_Matx_MatMulOp_const_Matx_MatMulOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_MatMulOp_delete(instance: *mut c_void);
		pub fn cv_Matx_MulOp_Matx_MulOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_MulOp_Matx_MulOp_const_Matx_MulOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_MulOp_delete(instance: *mut c_void);
		pub fn cv_Matx_ScaleOp_Matx_ScaleOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_ScaleOp_Matx_ScaleOp_const_Matx_ScaleOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_ScaleOp_delete(instance: *mut c_void);
		pub fn cv_Matx_SubOp_Matx_SubOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_SubOp_Matx_SubOp_const_Matx_SubOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_SubOp_delete(instance: *mut c_void);
		pub fn cv_Matx_TOp_Matx_TOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_TOp_Matx_TOp_const_Matx_TOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_TOp_delete(instance: *mut c_void);
		pub fn cv_MinProblemSolver_getFunction_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MinProblemSolver_setFunction_const_PtrLFunctionGR(instance: *mut c_void, f: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MinProblemSolver_getTermCriteria_const(instance: *const c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_MinProblemSolver_setTermCriteria_const_TermCriteriaR(instance: *mut c_void, termcrit: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_MinProblemSolver_minimize_const__InputOutputArrayR(instance: *mut c_void, x: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_MinProblemSolver_to_ConjGradSolver(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MinProblemSolver_to_DownhillSolver(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MinProblemSolver_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MinProblemSolver_delete(instance: *mut c_void);
		pub fn cv_MinProblemSolver_Function_getDims_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_MinProblemSolver_Function_getGradientEps_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_MinProblemSolver_Function_calc_const_const_doubleX(instance: *const c_void, x: *const f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_MinProblemSolver_Function_getGradient_const_doubleX_doubleX(instance: *mut c_void, x: *const f64, grad: *mut f64, ocvrs_return: *mut Result_void);
		pub fn cv_MinProblemSolver_Function_delete(instance: *mut c_void);
		pub fn cv_Moments_Moments(ocvrs_return: *mut Result<core::Moments>);
		pub fn cv_Moments_Moments_double_double_double_double_double_double_double_double_double_double(m00: f64, m10: f64, m01: f64, m20: f64, m11: f64, m02: f64, m30: f64, m21: f64, m12: f64, m03: f64, ocvrs_return: *mut Result<core::Moments>);
		pub fn cv_PCA_PCA(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_PCA_const__InputArrayR_const__InputArrayR_int_int(data: *const c_void, mean: *const c_void, flags: i32, max_components: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_PCA_const__InputArrayR_const__InputArrayR_int(data: *const c_void, mean: *const c_void, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_PCA_const__InputArrayR_const__InputArrayR_int_double(data: *const c_void, mean: *const c_void, flags: i32, retained_variance: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_operator___const__InputArrayR_const__InputArrayR_int_int(instance: *mut c_void, data: *const c_void, mean: *const c_void, flags: i32, max_components: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_operator___const__InputArrayR_const__InputArrayR_int(instance: *mut c_void, data: *const c_void, mean: *const c_void, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_operator___const__InputArrayR_const__InputArrayR_int_double(instance: *mut c_void, data: *const c_void, mean: *const c_void, flags: i32, retained_variance: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_project_const_const__InputArrayR(instance: *const c_void, vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_project_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, vec: *const c_void, result: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_PCA_backProject_const_const__InputArrayR(instance: *const c_void, vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_backProject_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, vec: *const c_void, result: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_PCA_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_PCA_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_PCA_propEigenvectors_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PCA_propEigenvectors_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_PCA_propEigenvalues_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PCA_propEigenvalues_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_PCA_propMean_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PCA_propMean_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_PCA_delete(instance: *mut c_void);
		pub fn cv_ParallelLoopBody_operator___const_const_RangeR(instance: *const c_void, range: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ParallelLoopBody_delete(instance: *mut c_void);
		pub fn cv_RNG_RNG(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RNG_RNG_uint64_t(state: u64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RNG_next(instance: *mut c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_operator_unsigned_char(instance: *mut c_void, ocvrs_return: *mut Result<u8>);
		pub fn cv_RNG_operator_signed_char(instance: *mut c_void, ocvrs_return: *mut Result<i8>);
		pub fn cv_RNG_operator_unsigned_short(instance: *mut c_void, ocvrs_return: *mut Result<u16>);
		pub fn cv_RNG_operator_short(instance: *mut c_void, ocvrs_return: *mut Result<i16>);
		pub fn cv_RNG_operator_unsigned_int(instance: *mut c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_operator_int(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_RNG_operator_float(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_RNG_operator_double(instance: *mut c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_RNG_operator__(instance: *mut c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_operator___unsigned_int(instance: *mut c_void, n: u32, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_uniform_int_int(instance: *mut c_void, a: i32, b: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_RNG_uniform_float_float(instance: *mut c_void, a: f32, b: f32, ocvrs_return: *mut Result<f32>);
		pub fn cv_RNG_uniform_double_double(instance: *mut c_void, a: f64, b: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_RNG_fill_const__InputOutputArrayR_int_const__InputArrayR_const__InputArrayR_bool(instance: *mut c_void, mat: *const c_void, dist_type: i32, a: *const c_void, b: *const c_void, saturate_range: bool, ocvrs_return: *mut Result_void);
		pub fn cv_RNG_fill_const__InputOutputArrayR_int_const__InputArrayR_const__InputArrayR(instance: *mut c_void, mat: *const c_void, dist_type: i32, a: *const c_void, b: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_RNG_gaussian_double(instance: *mut c_void, sigma: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_RNG_operatorEQ_const_const_RNGR(instance: *const c_void, other: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_RNG_propState_const(instance: *const c_void) -> u64;
		pub fn cv_RNG_propState_uint64_t(instance: *mut c_void, val: u64);
		pub fn cv_RNG_delete(instance: *mut c_void);
		pub fn cv_RNG_MT19937_RNG_MT19937(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RNG_MT19937_RNG_MT19937_unsigned_int(s: u32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RNG_MT19937_seed_unsigned_int(instance: *mut c_void, s: u32, ocvrs_return: *mut Result_void);
		pub fn cv_RNG_MT19937_next(instance: *mut c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_MT19937_operator_int(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_RNG_MT19937_operator_unsigned_int(instance: *mut c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_MT19937_operator_float(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_RNG_MT19937_operator_double(instance: *mut c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_RNG_MT19937_operator___unsigned_int(instance: *mut c_void, n: u32, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_MT19937_operator__(instance: *mut c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_MT19937_uniform_int_int(instance: *mut c_void, a: i32, b: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_RNG_MT19937_uniform_float_float(instance: *mut c_void, a: f32, b: f32, ocvrs_return: *mut Result<f32>);
		pub fn cv_RNG_MT19937_uniform_double_double(instance: *mut c_void, a: f64, b: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_RNG_MT19937_delete(instance: *mut c_void);
		pub fn cv_Range_Range(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Range_Range_int_int(_start: i32, _end: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Range_size_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_Range_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_Range_all(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Range_propStart_const(instance: *const c_void) -> i32;
		pub fn cv_Range_propStart_int(instance: *mut c_void, val: i32);
		pub fn cv_Range_propEnd_const(instance: *const c_void) -> i32;
		pub fn cv_Range_propEnd_int(instance: *mut c_void, val: i32);
		pub fn cv_Range_delete(instance: *mut c_void);
		pub fn cv_RotatedRect_RotatedRect(ocvrs_return: *mut Result<core::RotatedRect>);
		pub fn cv_RotatedRect_RotatedRect_const_Point2fR_const_Size2fR_float(center: *const core::Point2f, size: *const core::Size2f, angle: f32, ocvrs_return: *mut Result<core::RotatedRect>);
		pub fn cv_RotatedRect_RotatedRect_const_Point2fR_const_Point2fR_const_Point2fR(point1: *const core::Point2f, point2: *const core::Point2f, point3: *const core::Point2f, ocvrs_return: *mut Result<core::RotatedRect>);
		pub fn cv_RotatedRect_points_const_Point2fX(instance: *const core::RotatedRect, pts: *mut core::Point2f, ocvrs_return: *mut Result_void);
		pub fn cv_RotatedRect_points_const_vectorLPoint2fGR(instance: *const core::RotatedRect, pts: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_RotatedRect_boundingRect_const(instance: *const core::RotatedRect, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_RotatedRect_boundingRect2f_const(instance: *const core::RotatedRect, ocvrs_return: *mut Result<core::Rect_<f32>>);
		pub fn cv_SVD_SVD(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SVD_SVD_const__InputArrayR_int(src: *const c_void, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SVD_SVD_const__InputArrayR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SVD_operator___const__InputArrayR_int(instance: *mut c_void, src: *const c_void, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SVD_operator___const__InputArrayR(instance: *mut c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SVD_compute_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int(src: *const c_void, w: *const c_void, u: *const c_void, vt: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_SVD_compute_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, w: *const c_void, u: *const c_void, vt: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SVD_compute_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, w: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_SVD_compute_const__InputArrayR_const__OutputArrayR(src: *const c_void, w: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SVD_backSubst_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(w: *const c_void, u: *const c_void, vt: *const c_void, rhs: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SVD_solveZ_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SVD_backSubst_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, rhs: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SVD_propU_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_SVD_propU_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_SVD_propW_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_SVD_propW_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_SVD_propVt_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_SVD_propVt_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_SVD_delete(instance: *mut c_void);
		pub fn cv_SparseMat_SparseMat(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_SparseMat_int_const_intX_int(dims: i32, _sizes: *const i32, _type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_SparseMat_const_SparseMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_SparseMat_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_operatorST_const_SparseMatR(instance: *mut c_void, m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_operatorST_const_MatR(instance: *mut c_void, m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_copyTo_const_SparseMatR(instance: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_copyTo_const_MatR(instance: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_convertTo_const_SparseMatR_int_double(instance: *const c_void, m: *mut c_void, rtype: i32, alpha: f64, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_convertTo_const_SparseMatR_int(instance: *const c_void, m: *mut c_void, rtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_convertTo_const_MatR_int_double_double(instance: *const c_void, m: *mut c_void, rtype: i32, alpha: f64, beta: f64, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_convertTo_const_MatR_int(instance: *const c_void, m: *mut c_void, rtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_assignTo_const_SparseMatR_int(instance: *const c_void, m: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_assignTo_const_SparseMatR(instance: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_create_int_const_intX_int(instance: *mut c_void, dims: i32, _sizes: *const i32, _type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_addref(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_elemSize_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_elemSize1_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_type_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_depth_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_channels_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_size_const(instance: *const c_void, ocvrs_return: *mut Result<*const i32>);
		pub fn cv_SparseMat_size_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_SparseMat_dims_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_SparseMat_nzcount_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_SparseMat_hash_const_int(instance: *const c_void, i0: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_SparseMat_hash_const_int_int(instance: *const c_void, i0: i32, i1: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_SparseMat_hash_const_int_int_int(instance: *const c_void, i0: i32, i1: i32, i2: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_SparseMat_hash_const_const_intX(instance: *const c_void, idx: *const i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_SparseMat_ptr_int_bool_size_tX(instance: *mut c_void, i0: i32, create_missing: bool, hashval: *mut size_t, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_ptr_int_bool(instance: *mut c_void, i0: i32, create_missing: bool, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_ptr_int_int_bool_size_tX(instance: *mut c_void, i0: i32, i1: i32, create_missing: bool, hashval: *mut size_t, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_ptr_int_int_bool(instance: *mut c_void, i0: i32, i1: i32, create_missing: bool, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_ptr_int_int_int_bool_size_tX(instance: *mut c_void, i0: i32, i1: i32, i2: i32, create_missing: bool, hashval: *mut size_t, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_ptr_int_int_int_bool(instance: *mut c_void, i0: i32, i1: i32, i2: i32, create_missing: bool, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_ptr_const_intX_bool_size_tX(instance: *mut c_void, idx: *const i32, create_missing: bool, hashval: *mut size_t, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_ptr_const_intX_bool(instance: *mut c_void, idx: *const i32, create_missing: bool, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_erase_int_int_size_tX(instance: *mut c_void, i0: i32, i1: i32, hashval: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_erase_int_int(instance: *mut c_void, i0: i32, i1: i32, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_erase_int_int_int_size_tX(instance: *mut c_void, i0: i32, i1: i32, i2: i32, hashval: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_erase_int_int_int(instance: *mut c_void, i0: i32, i1: i32, i2: i32, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_erase_const_intX_size_tX(instance: *mut c_void, idx: *const i32, hashval: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_erase_const_intX(instance: *mut c_void, idx: *const i32, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_begin(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_begin_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_end(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_end_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_node_size_t(instance: *mut c_void, nidx: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_node_const_size_t(instance: *const c_void, nidx: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_newNode_const_intX_size_t(instance: *mut c_void, idx: *const i32, hashval: size_t, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_removeNode_size_t_size_t_size_t(instance: *mut c_void, hidx: size_t, nidx: size_t, previdx: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_resizeHashTab_size_t(instance: *mut c_void, newsize: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_propFlags_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_propFlags_int(instance: *mut c_void, val: i32);
		pub fn cv_SparseMat_propHdr(instance: *mut c_void) -> *mut c_void;
		pub fn cv_SparseMat_propHdr_HdrX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_SparseMat_delete(instance: *mut c_void);
		pub fn cv_SparseMat_Hdr_Hdr_int_const_intX_int(_dims: i32, _sizes: *const i32, _type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_Hdr_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMat_Hdr_propRefcount_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_Hdr_propRefcount_int(instance: *mut c_void, val: i32);
		pub fn cv_SparseMat_Hdr_propDims_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_Hdr_propDims_int(instance: *mut c_void, val: i32);
		pub fn cv_SparseMat_Hdr_propValueOffset_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_Hdr_propValueOffset_int(instance: *mut c_void, val: i32);
		pub fn cv_SparseMat_Hdr_propNodeSize_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_Hdr_propNodeSize_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_SparseMat_Hdr_propNodeCount_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_Hdr_propNodeCount_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_SparseMat_Hdr_propFreeList_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_Hdr_propFreeList_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_SparseMat_Hdr_propPool_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_SparseMat_Hdr_propPool_vectorLunsigned_charG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_SparseMat_Hdr_propHashtab_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_SparseMat_Hdr_propHashtab_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_SparseMat_Hdr_propSize(instance: *mut c_void) -> *mut [i32; 32];
		pub fn cv_SparseMat_Hdr_delete(instance: *mut c_void);
		pub fn cv_SparseMat_Node_propHashval_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_Node_propHashval_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_SparseMat_Node_propNext_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_Node_propNext_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_SparseMat_Node_propIdx(instance: *mut c_void) -> *mut [i32; 32];
		pub fn cv_SparseMat_Node_delete(instance: *mut c_void);
		pub fn cv_SparseMatConstIterator_SparseMatConstIterator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatConstIterator_SparseMatConstIterator_const_SparseMatX(_m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatConstIterator_SparseMatConstIterator_const_SparseMatConstIteratorR(it: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatConstIterator_operatorST_const_SparseMatConstIteratorR(instance: *mut c_void, it: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMatConstIterator_node_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatConstIterator_operatorAA(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatConstIterator_seekEnd(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMatConstIterator_propM_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_SparseMatConstIterator_propHashidx_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMatConstIterator_propHashidx_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_SparseMatConstIterator_propPtr(instance: *mut c_void) -> *mut u8;
		pub fn cv_SparseMatConstIterator_propPtr_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_SparseMatConstIterator_delete(instance: *mut c_void);
		pub fn cv_SparseMatIterator_SparseMatIterator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatIterator_SparseMatIterator_SparseMatX(_m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatIterator_SparseMatIterator_const_SparseMatIteratorR(it: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatIterator_operatorST_const_SparseMatIteratorR(instance: *mut c_void, it: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseMatIterator_node_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatIterator_operatorAA(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatIterator_to_SparseMatConstIterator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_SparseMatIterator_delete(instance: *mut c_void);
		pub fn cv_TermCriteria_TermCriteria(ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_TermCriteria_TermCriteria_int_int_double(typ: i32, max_count: i32, epsilon: f64, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_TermCriteria_isValid_const(instance: *const core::TermCriteria, ocvrs_return: *mut Result<bool>);
		pub fn cv_TickMeter_TickMeter(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TickMeter_start(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_TickMeter_stop(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_TickMeter_getTimeTicks_const(instance: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_TickMeter_getTimeMicro_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_getTimeMilli_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_getTimeSec_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_getCounter_const(instance: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_TickMeter_getFPS_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_getAvgTimeSec_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_getAvgTimeMilli_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_reset(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_TickMeter_delete(instance: *mut c_void);
		pub fn cv_UMat_UMat_UMatUsageFlags(usage_flags: core::UMatUsageFlags) -> *mut c_void;
		pub fn cv_UMat_UMat() -> *mut c_void;
		pub fn cv_UMat_UMat_int_int_int_UMatUsageFlags(rows: i32, cols: i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_Size_int_UMatUsageFlags(size: *const core::Size, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_int_int_int_const_ScalarR_UMatUsageFlags(rows: i32, cols: i32, typ: i32, s: *const core::Scalar, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_int_int_int_const_ScalarR(rows: i32, cols: i32, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_Size_int_const_ScalarR_UMatUsageFlags(size: *const core::Size, typ: i32, s: *const core::Scalar, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_Size_int_const_ScalarR(size: *const core::Size, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_int_const_intX_int_UMatUsageFlags(ndims: i32, sizes: *const i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_int_const_intX_int(ndims: i32, sizes: *const i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_int_const_intX_int_const_ScalarR_UMatUsageFlags(ndims: i32, sizes: *const i32, typ: i32, s: *const core::Scalar, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_int_const_intX_int_const_ScalarR(ndims: i32, sizes: *const i32, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_const_UMatR_const_RangeR_const_RangeR(m: *const c_void, row_range: *const c_void, col_range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_const_UMatR_const_RangeR(m: *const c_void, row_range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_const_UMatR_const_RectR(m: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_const_UMatR_const_vectorLRangeGR(m: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_operatorST_const_UMatR(instance: *mut c_void, m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_getMat_const_AccessFlag(instance: *const c_void, flags: core::AccessFlag, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_row_const_int(instance: *const c_void, y: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_col_const_int(instance: *const c_void, x: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_rowRange_const_int_int(instance: *const c_void, startrow: i32, endrow: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_rowRange_const_const_RangeR(instance: *const c_void, r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_colRange_const_int_int(instance: *const c_void, startcol: i32, endcol: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_colRange_const_const_RangeR(instance: *const c_void, r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_diag_const_int(instance: *const c_void, d: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_diag_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_diag_const_UMatR_UMatUsageFlags(d: *const c_void, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_diag_const_UMatR(d: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_copyTo_const_const__OutputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_copyTo_const_const__OutputArrayR_const__InputArrayR(instance: *const c_void, m: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_convertTo_const_const__OutputArrayR_int_double_double(instance: *const c_void, m: *const c_void, rtype: i32, alpha: f64, beta: f64, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_convertTo_const_const__OutputArrayR_int(instance: *const c_void, m: *const c_void, rtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_assignTo_const_UMatR_int(instance: *const c_void, m: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_assignTo_const_UMatR(instance: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_operatorST_const_ScalarR(instance: *mut c_void, s: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_setTo_const__InputArrayR_const__InputArrayR(instance: *mut c_void, value: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_setTo_const__InputArrayR(instance: *mut c_void, value: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_reshape_const_int_int(instance: *const c_void, cn: i32, rows: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_reshape_const_int(instance: *const c_void, cn: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_reshape_const_int_int_const_intX(instance: *const c_void, cn: i32, newndims: i32, newsz: *const i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_t_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_inv_const_int(instance: *const c_void, method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_inv_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_mul_const_const__InputArrayR_double(instance: *const c_void, m: *const c_void, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_mul_const_const__InputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_dot_const_const__InputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_UMat_zeros_int_int_int_UMatUsageFlags(rows: i32, cols: i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_zeros_Size_int_UMatUsageFlags(size: *const core::Size, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_zeros_int_const_intX_int_UMatUsageFlags(ndims: i32, sz: *const i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_zeros_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_zeros_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_zeros_int_const_intX_int(ndims: i32, sz: *const i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ones_int_int_int_UMatUsageFlags(rows: i32, cols: i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ones_Size_int_UMatUsageFlags(size: *const core::Size, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ones_int_const_intX_int_UMatUsageFlags(ndims: i32, sz: *const i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ones_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ones_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ones_int_const_intX_int(ndims: i32, sz: *const i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_eye_int_int_int_UMatUsageFlags(rows: i32, cols: i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_eye_Size_int_UMatUsageFlags(size: *const core::Size, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_eye_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_eye_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_create_int_int_int_UMatUsageFlags(instance: *mut c_void, rows: i32, cols: i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_create_int_int_int(instance: *mut c_void, rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_create_Size_int_UMatUsageFlags(instance: *mut c_void, size: *const core::Size, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_create_Size_int(instance: *mut c_void, size: *const core::Size, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_create_int_const_intX_int_UMatUsageFlags(instance: *mut c_void, ndims: i32, sizes: *const i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_create_int_const_intX_int(instance: *mut c_void, ndims: i32, sizes: *const i32, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_create_const_vectorLintGR_int_UMatUsageFlags(instance: *mut c_void, sizes: *const c_void, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_create_const_vectorLintGR_int(instance: *mut c_void, sizes: *const c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_addref(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_deallocate(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_locateROI_const_SizeR_PointR(instance: *const c_void, whole_size: *mut core::Size, ofs: *mut core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_adjustROI_int_int_int_int(instance: *mut c_void, dtop: i32, dbottom: i32, dleft: i32, dright: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_operator___const_Range_Range(instance: *const c_void, row_range: *mut c_void, col_range: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_operator___const_const_RectR(instance: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_operator___const_const_RangeX(instance: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_operator___const_const_vectorLRangeGR(instance: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_isContinuous_const(instance: *const c_void) -> bool;
		pub fn cv_UMat_isSubmatrix_const(instance: *const c_void) -> bool;
		pub fn cv_UMat_elemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_UMat_elemSize1_const(instance: *const c_void) -> size_t;
		pub fn cv_UMat_type_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_depth_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_channels_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_step1_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_UMat_step1_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_UMat_empty_const(instance: *const c_void) -> bool;
		pub fn cv_UMat_total_const(instance: *const c_void) -> size_t;
		pub fn cv_UMat_checkVector_const_int_int_bool(instance: *const c_void, elem_channels: i32, depth: i32, require_continuous: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_UMat_checkVector_const_int(instance: *const c_void, elem_channels: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_UMat_UMat_UMatRR(m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_operatorST_UMatRR(instance: *mut c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_handle_const_AccessFlag(instance: *const c_void, access_flags: core::AccessFlag, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ndoffset_const_size_tX(instance: *const c_void, ofs: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_updateContinuityFlag(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMat_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_UMat_propFlags_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_propFlags_int(instance: *mut c_void, val: i32);
		pub fn cv_UMat_propDims_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_propDims_int(instance: *mut c_void, val: i32);
		pub fn cv_UMat_propRows_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_propRows_int(instance: *mut c_void, val: i32);
		pub fn cv_UMat_propCols_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_propCols_int(instance: *mut c_void, val: i32);
		pub fn cv_UMat_propUsageFlags_const(instance: *const c_void, ocvrs_return: *mut core::UMatUsageFlags);
		pub fn cv_UMat_propUsageFlags_UMatUsageFlags(instance: *mut c_void, val: core::UMatUsageFlags);
		pub fn cv_UMat_propU(instance: *mut c_void) -> *mut c_void;
		pub fn cv_UMat_propU_UMatDataX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_UMat_propOffset_const(instance: *const c_void) -> size_t;
		pub fn cv_UMat_propOffset_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_UMat_propSize_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_UMat_propStep_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_UMat_delete(instance: *mut c_void);
		pub fn cv_UMatData_lock(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMatData_unlock(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_UMatData_hostCopyObsolete_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_UMatData_deviceCopyObsolete_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_UMatData_deviceMemMapped_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_UMatData_copyOnMap_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_UMatData_tempUMat_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_UMatData_tempCopiedUMat_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_UMatData_markHostCopyObsolete_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_UMatData_markDeviceCopyObsolete_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_UMatData_markDeviceMemMapped_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_UMatData_propUrefcount_const(instance: *const c_void) -> i32;
		pub fn cv_UMatData_propUrefcount_int(instance: *mut c_void, val: i32);
		pub fn cv_UMatData_propRefcount_const(instance: *const c_void) -> i32;
		pub fn cv_UMatData_propRefcount_int(instance: *mut c_void, val: i32);
		pub fn cv_UMatData_propData(instance: *mut c_void) -> *mut u8;
		pub fn cv_UMatData_propData_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_UMatData_propOrigdata(instance: *mut c_void) -> *mut u8;
		pub fn cv_UMatData_propOrigdata_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_UMatData_propSize_const(instance: *const c_void) -> size_t;
		pub fn cv_UMatData_propSize_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_UMatData_propFlags_const(instance: *const c_void, ocvrs_return: *mut core::UMatData_MemoryFlag);
		pub fn cv_UMatData_propFlags_MemoryFlag(instance: *mut c_void, val: core::UMatData_MemoryFlag);
		pub fn cv_UMatData_propHandle(instance: *mut c_void) -> *mut c_void;
		pub fn cv_UMatData_propHandle_voidX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_UMatData_propUserdata(instance: *mut c_void) -> *mut c_void;
		pub fn cv_UMatData_propUserdata_voidX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_UMatData_propAllocatorFlags__const(instance: *const c_void) -> i32;
		pub fn cv_UMatData_propAllocatorFlags__int(instance: *mut c_void, val: i32);
		pub fn cv_UMatData_propMapcount_const(instance: *const c_void) -> i32;
		pub fn cv_UMatData_propMapcount_int(instance: *mut c_void, val: i32);
		pub fn cv_UMatData_propOriginalUMatData(instance: *mut c_void) -> *mut c_void;
		pub fn cv_UMatData_propOriginalUMatData_UMatDataX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_UMatData_delete(instance: *mut c_void);
		pub fn cv__InputArray__InputArray(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_int_voidX(_flags: i32, _obj: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_MatExprR(expr: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_vectorLMatGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_vectorLboolGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_doubleR(val: *const f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_GpuMatR(d_mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_vectorLGpuMatGR(d_mat_array: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_BufferR(buf: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_HostMemR(cuda_mem: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_UMatR(um: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_vectorLUMatGR(umv: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getMat_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getMat_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getMat__const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getMat__const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getUMat_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getUMat_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getMatVector_const_vectorLMatGR(instance: *const c_void, mv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv__InputArray_getUMatVector_const_vectorLUMatGR(instance: *const c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv__InputArray_getGpuMatVector_const_vectorLGpuMatGR(instance: *const c_void, gpumv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv__InputArray_getGpuMat_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getOGlBuffer_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getFlags_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_getObj_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getSz_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv__InputArray_kind_const(instance: *const c_void, ocvrs_return: *mut Result<core::_InputArray_KindFlag>);
		pub fn cv__InputArray_dims_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_dims_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_cols_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_cols_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_rows_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_rows_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_size_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<core::Size>);
		pub fn cv__InputArray_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv__InputArray_sizend_const_intX_int(instance: *const c_void, sz: *mut i32, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_sizend_const_intX(instance: *const c_void, sz: *mut i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_sameSize_const_const__InputArrayR(instance: *const c_void, arr: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_total_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv__InputArray_total_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv__InputArray_type_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_depth_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_depth_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_channels_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_channels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_isContinuous_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isContinuous_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isSubmatrix_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isSubmatrix_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_copyTo_const_const__OutputArrayR(instance: *const c_void, arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__InputArray_copyTo_const_const__OutputArrayR_const__InputArrayR(instance: *const c_void, arr: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__InputArray_offset_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv__InputArray_offset_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv__InputArray_step_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv__InputArray_step_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv__InputArray_isMat_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isUMat_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isMatVector_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isUMatVector_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isMatx_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isVector_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isGpuMat_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isGpuMatVector_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_delete(instance: *mut c_void);
		pub fn cv__InputOutputArray__InputOutputArray(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_int_voidX(_flags: i32, _obj: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_MatR(m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_vectorLMatGR(vec: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_GpuMatR(d_mat: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_BufferR(buf: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_HostMemR(cuda_mem: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_UMatR(m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_vectorLUMatGR(vec: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_vectorLMatGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_GpuMatR(d_mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_vectorLGpuMatGR(d_mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_BufferR(buf: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_HostMemR(cuda_mem: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_vectorLUMatGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray_to__InputArray(instance: *mut c_void) -> *mut c_void;
		pub fn cv__InputOutputArray_to__OutputArray(instance: *mut c_void) -> *mut c_void;
		pub fn cv__InputOutputArray_delete(instance: *mut c_void);
		pub fn cv__OutputArray__OutputArray(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_int_voidX(_flags: i32, _obj: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_MatR(m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_vectorLMatGR(vec: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_GpuMatR(d_mat: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_vectorLGpuMatGR(d_mat: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_BufferR(buf: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_HostMemR(cuda_mem: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_UMatR(m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_vectorLUMatGR(vec: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_const_vectorLMatGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_const_GpuMatR(d_mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_const_BufferR(buf: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_const_HostMemR(cuda_mem: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_const_vectorLUMatGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_fixedSize_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__OutputArray_fixedType_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__OutputArray_needed_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__OutputArray_getMatRef_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_getMatRef_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_getUMatRef_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_getUMatRef_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_getGpuMatRef_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_getGpuMatVecRef_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_getOGlBufferRef_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_getHostMemRef_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_create_const_Size_int_int_bool_DepthMask(instance: *const c_void, sz: *const core::Size, typ: i32, i: i32, allow_transposed: bool, fixed_depth_mask: core::_OutputArray_DepthMask, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_create_const_Size_int(instance: *const c_void, sz: *const core::Size, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_create_const_int_int_int_int_bool_DepthMask(instance: *const c_void, rows: i32, cols: i32, typ: i32, i: i32, allow_transposed: bool, fixed_depth_mask: core::_OutputArray_DepthMask, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_create_const_int_int_int(instance: *const c_void, rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_create_const_int_const_intX_int_int_bool_DepthMask(instance: *const c_void, dims: i32, size: *const i32, typ: i32, i: i32, allow_transposed: bool, fixed_depth_mask: core::_OutputArray_DepthMask, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_create_const_int_const_intX_int(instance: *const c_void, dims: i32, size: *const i32, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_createSameSize_const_const__InputArrayR_int(instance: *const c_void, arr: *const c_void, mtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_release_const(instance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_clear_const(instance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_setTo_const_const__InputArrayR_const__InputArrayR(instance: *const c_void, value: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_setTo_const_const__InputArrayR(instance: *const c_void, value: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_assign_const_const_UMatR(instance: *const c_void, u: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_assign_const_const_MatR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_assign_const_const_vectorLUMatGR(instance: *const c_void, v: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_assign_const_const_vectorLMatGR(instance: *const c_void, v: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_move_const_UMatR(instance: *const c_void, u: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_move_const_MatR(instance: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv__OutputArray_to__InputArray(instance: *mut c_void) -> *mut c_void;
		pub fn cv__OutputArray_delete(instance: *mut c_void);
		pub fn cv_cuda_BufferPool_BufferPool_StreamR(stream: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_BufferPool_getBuffer_int_int_int(instance: *mut c_void, rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_BufferPool_getBuffer_Size_int(instance: *mut c_void, size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_BufferPool_getAllocator_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_BufferPool_delete(instance: *mut c_void);
		pub fn cv_cuda_DeviceInfo_DeviceInfo(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_DeviceInfo_DeviceInfo_int(device_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_DeviceInfo_deviceID_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_name_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_DeviceInfo_totalGlobalMem_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_DeviceInfo_sharedMemPerBlock_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_DeviceInfo_regsPerBlock_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_warpSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_memPitch_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_DeviceInfo_maxThreadsPerBlock_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_maxThreadsDim_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec3i>);
		pub fn cv_cuda_DeviceInfo_maxGridSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec3i>);
		pub fn cv_cuda_DeviceInfo_clockRate_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_totalConstMem_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_DeviceInfo_majorVersion_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_minorVersion_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_textureAlignment_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_DeviceInfo_texturePitchAlignment_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_DeviceInfo_multiProcessorCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_kernelExecTimeoutEnabled_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DeviceInfo_integrated_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DeviceInfo_canMapHostMemory_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DeviceInfo_computeMode_const(instance: *const c_void, ocvrs_return: *mut Result<core::DeviceInfo_ComputeMode>);
		pub fn cv_cuda_DeviceInfo_maxTexture1D_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_maxTexture1DMipmap_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_maxTexture1DLinear_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_maxTexture2D_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2i>);
		pub fn cv_cuda_DeviceInfo_maxTexture2DMipmap_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2i>);
		pub fn cv_cuda_DeviceInfo_maxTexture2DLinear_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec3i>);
		pub fn cv_cuda_DeviceInfo_maxTexture2DGather_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2i>);
		pub fn cv_cuda_DeviceInfo_maxTexture3D_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec3i>);
		pub fn cv_cuda_DeviceInfo_maxTextureCubemap_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_maxTexture1DLayered_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2i>);
		pub fn cv_cuda_DeviceInfo_maxTexture2DLayered_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec3i>);
		pub fn cv_cuda_DeviceInfo_maxTextureCubemapLayered_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2i>);
		pub fn cv_cuda_DeviceInfo_maxSurface1D_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_maxSurface2D_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2i>);
		pub fn cv_cuda_DeviceInfo_maxSurface3D_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec3i>);
		pub fn cv_cuda_DeviceInfo_maxSurface1DLayered_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2i>);
		pub fn cv_cuda_DeviceInfo_maxSurface2DLayered_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec3i>);
		pub fn cv_cuda_DeviceInfo_maxSurfaceCubemap_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_maxSurfaceCubemapLayered_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2i>);
		pub fn cv_cuda_DeviceInfo_surfaceAlignment_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_DeviceInfo_concurrentKernels_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DeviceInfo_ECCEnabled_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DeviceInfo_pciBusID_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_pciDeviceID_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_pciDomainID_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_tccDriver_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DeviceInfo_asyncEngineCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_unifiedAddressing_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DeviceInfo_memoryClockRate_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_memoryBusWidth_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_l2CacheSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_maxThreadsPerMultiProcessor_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DeviceInfo_queryMemory_const_size_tR_size_tR(instance: *const c_void, total_memory: *mut size_t, free_memory: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DeviceInfo_freeMemory_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_DeviceInfo_totalMemory_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_DeviceInfo_supports_const_FeatureSet(instance: *const c_void, feature_set: core::FeatureSet, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DeviceInfo_isCompatible_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DeviceInfo_delete(instance: *mut c_void);
		pub fn cv_cuda_Event_Event_const_CreateFlags(flags: core::Event_CreateFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_Event_Event(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_Event_record_StreamR(instance: *mut c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Event_record(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Event_queryIfComplete_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_Event_waitForCompletion(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Event_elapsedTime_const_EventR_const_EventR(start: *const c_void, end: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_cuda_Event_delete(instance: *mut c_void);
		pub fn cv_cuda_GpuData_GpuData_size_t(_size: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuData_propData(instance: *mut c_void) -> *mut u8;
		pub fn cv_cuda_GpuData_propData_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_cuda_GpuData_propSize_const(instance: *const c_void) -> size_t;
		pub fn cv_cuda_GpuData_propSize_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_cuda_GpuData_delete(instance: *mut c_void);
		pub fn cv_cuda_GpuMat_defaultAllocator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_setDefaultAllocator_AllocatorX(allocator: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_GpuMat_AllocatorX(allocator: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_int_int_int_AllocatorX(rows: i32, cols: i32, typ: i32, allocator: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_Size_int_AllocatorX(size: *const core::Size, typ: i32, allocator: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_int_int_int_Scalar_AllocatorX(rows: i32, cols: i32, typ: i32, s: *const core::Scalar, allocator: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_int_int_int_Scalar(rows: i32, cols: i32, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_Size_int_Scalar_AllocatorX(size: *const core::Size, typ: i32, s: *const core::Scalar, allocator: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_Size_int_Scalar(size: *const core::Size, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_const_GpuMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_int_int_int_voidX_size_t(rows: i32, cols: i32, typ: i32, data: *mut c_void, step: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_int_int_int_voidX(rows: i32, cols: i32, typ: i32, data: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_Size_int_voidX_size_t(size: *const core::Size, typ: i32, data: *mut c_void, step: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_Size_int_voidX(size: *const core::Size, typ: i32, data: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_const_GpuMatR_Range_Range(m: *const c_void, row_range: *mut c_void, col_range: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_const_GpuMatR_Rect(m: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_const__InputArrayR_AllocatorX(arr: *const c_void, allocator: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_GpuMat_const__InputArrayR(arr: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_operatorST_const_GpuMatR(instance: *mut c_void, m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_create_int_int_int(instance: *mut c_void, rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_create_Size_int(instance: *mut c_void, size: *const core::Size, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_swap_GpuMatR(instance: *mut c_void, mat: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_upload_const__InputArrayR(instance: *mut c_void, arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_upload_const__InputArrayR_StreamR(instance: *mut c_void, arr: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_download_const_const__OutputArrayR(instance: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_download_const_const__OutputArrayR_StreamR(instance: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_copyTo_const_const__OutputArrayR(instance: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_copyTo_const_const__OutputArrayR_StreamR(instance: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_copyTo_const_const__OutputArrayR_const__InputArrayR(instance: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_copyTo_const_const__OutputArrayR_const__InputArrayR_StreamR(instance: *const c_void, dst: *const c_void, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_setTo_Scalar(instance: *mut c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_setTo_Scalar_StreamR(instance: *mut c_void, s: *const core::Scalar, stream: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_setTo_Scalar_const__InputArrayR(instance: *mut c_void, s: *const core::Scalar, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_setTo_Scalar_const__InputArrayR_StreamR(instance: *mut c_void, s: *const core::Scalar, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_convertTo_const_const__OutputArrayR_int(instance: *const c_void, dst: *const c_void, rtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_convertTo_const_const__OutputArrayR_int_StreamR(instance: *const c_void, dst: *const c_void, rtype: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_convertTo_const_const__OutputArrayR_int_double_double(instance: *const c_void, dst: *const c_void, rtype: i32, alpha: f64, beta: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_convertTo_const_const__OutputArrayR_int_double(instance: *const c_void, dst: *const c_void, rtype: i32, alpha: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_convertTo_const_const__OutputArrayR_int_double_StreamR(instance: *const c_void, dst: *const c_void, rtype: i32, alpha: f64, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_convertTo_const_const__OutputArrayR_int_double_double_StreamR(instance: *const c_void, dst: *const c_void, rtype: i32, alpha: f64, beta: f64, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_assignTo_const_GpuMatR_int(instance: *const c_void, m: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_assignTo_const_GpuMatR(instance: *const c_void, m: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_ptr_int(instance: *mut c_void, y: i32, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_cuda_GpuMat_ptr(instance: *mut c_void, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_cuda_GpuMat_ptr_const_int(instance: *const c_void, y: i32, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_cuda_GpuMat_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_cuda_GpuMat_row_const_int(instance: *const c_void, y: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_col_const_int(instance: *const c_void, x: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_rowRange_const_int_int(instance: *const c_void, startrow: i32, endrow: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_rowRange_const_Range(instance: *const c_void, r: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_colRange_const_int_int(instance: *const c_void, startcol: i32, endcol: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_colRange_const_Range(instance: *const c_void, r: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_operator___const_Range_Range(instance: *const c_void, row_range: *mut c_void, col_range: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_operator___const_Rect(instance: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_reshape_const_int_int(instance: *const c_void, cn: i32, rows: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_reshape_const_int(instance: *const c_void, cn: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_locateROI_const_SizeR_PointR(instance: *const c_void, whole_size: *mut core::Size, ofs: *mut core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_adjustROI_int_int_int_int(instance: *mut c_void, dtop: i32, dbottom: i32, dleft: i32, dright: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_isContinuous_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_GpuMat_elemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_GpuMat_elemSize1_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_GpuMat_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_GpuMat_depth_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_GpuMat_channels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_GpuMat_step1_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_GpuMat_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_cuda_GpuMat_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_GpuMat_cudaPtr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMat_updateContinuityFlag(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_propFlags_const(instance: *const c_void) -> i32;
		pub fn cv_cuda_GpuMat_propFlags_int(instance: *mut c_void, val: i32);
		pub fn cv_cuda_GpuMat_propRows_const(instance: *const c_void) -> i32;
		pub fn cv_cuda_GpuMat_propRows_int(instance: *mut c_void, val: i32);
		pub fn cv_cuda_GpuMat_propCols_const(instance: *const c_void) -> i32;
		pub fn cv_cuda_GpuMat_propCols_int(instance: *mut c_void, val: i32);
		pub fn cv_cuda_GpuMat_propStep_const(instance: *const c_void) -> size_t;
		pub fn cv_cuda_GpuMat_propStep_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_cuda_GpuMat_propData(instance: *mut c_void) -> *mut u8;
		pub fn cv_cuda_GpuMat_propData_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_cuda_GpuMat_propRefcount(instance: *mut c_void) -> *mut i32;
		pub fn cv_cuda_GpuMat_propRefcount_intX(instance: *mut c_void, val: *mut i32);
		pub fn cv_cuda_GpuMat_propDatastart(instance: *mut c_void) -> *mut u8;
		pub fn cv_cuda_GpuMat_propDatastart_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_cuda_GpuMat_propDataend_const(instance: *const c_void) -> *const u8;
		pub fn cv_cuda_GpuMat_propAllocator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_GpuMat_propAllocator_AllocatorX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_cuda_GpuMat_delete(instance: *mut c_void);
		pub fn cv_cuda_GpuMat_Allocator_allocate_GpuMatX_int_int_size_t(instance: *mut c_void, mat: *mut c_void, rows: i32, cols: i32, elem_size: size_t, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_GpuMat_Allocator_free_GpuMatX(instance: *mut c_void, mat: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMat_Allocator_delete(instance: *mut c_void);
		pub fn cv_cuda_GpuMatND_GpuMatND(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_GpuMatND_SizeArray_int(size: *mut c_void, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_GpuMatND_SizeArray_int_voidX_StepArray(size: *mut c_void, typ: i32, data: *mut c_void, step: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_GpuMatND_SizeArray_int_voidX(size: *mut c_void, typ: i32, data: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_create_SizeArray_int(instance: *mut c_void, size: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMatND_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMatND_swap_GpuMatNDR(instance: *mut c_void, m: *mut c_void);
		pub fn cv_cuda_GpuMatND_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_clone_const_StreamR(instance: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_operator___const_const_vectorLRangeGR(instance: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_createGpuMatHeader_const_IndexArray_Range_Range(instance: *const c_void, idx: *mut c_void, row_range: *mut c_void, col_range: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_createGpuMatHeader_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_operator___const_IndexArray_Range_Range(instance: *const c_void, idx: *mut c_void, row_range: *mut c_void, col_range: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_operator_cv_cuda_GpuMat_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_GpuMatND_GpuMatND_const_GpuMatNDR(unnamed: *const c_void) -> *mut c_void;
		pub fn cv_cuda_GpuMatND_operatorST_const_GpuMatNDR(instance: *mut c_void, unnamed: *const c_void);
		pub fn cv_cuda_GpuMatND_GpuMatND_GpuMatNDRR(unnamed: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_GpuMatND_operatorST_GpuMatNDRR(instance: *mut c_void, unnamed: *mut c_void);
		pub fn cv_cuda_GpuMatND_upload_const__InputArrayR(instance: *mut c_void, src: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMatND_upload_const__InputArrayR_StreamR(instance: *mut c_void, src: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMatND_download_const_const__OutputArrayR(instance: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMatND_download_const_const__OutputArrayR_StreamR(instance: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_GpuMatND_isContinuous_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_GpuMatND_isSubmatrix_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_GpuMatND_elemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_GpuMatND_elemSize1_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_GpuMatND_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_GpuMatND_external_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_GpuMatND_getDevicePtr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_cuda_GpuMatND_total_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_GpuMatND_totalMemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_GpuMatND_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_GpuMatND_propFlags_const(instance: *const c_void) -> i32;
		pub fn cv_cuda_GpuMatND_propFlags_int(instance: *mut c_void, val: i32);
		pub fn cv_cuda_GpuMatND_propDims_const(instance: *const c_void) -> i32;
		pub fn cv_cuda_GpuMatND_propDims_int(instance: *mut c_void, val: i32);
		pub fn cv_cuda_GpuMatND_propSize_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_cuda_GpuMatND_propSize_SizeArray(instance: *mut c_void, val: *mut c_void);
		pub fn cv_cuda_GpuMatND_propStep_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_cuda_GpuMatND_propStep_StepArray(instance: *mut c_void, val: *mut c_void);
		pub fn cv_cuda_GpuMatND_delete(instance: *mut c_void);
		pub fn cv_cuda_HostMem_HostMem_AllocType(alloc_type: core::HostMem_AllocType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_HostMem(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_HostMem_const_HostMemR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_HostMem_int_int_int_AllocType(rows: i32, cols: i32, typ: i32, alloc_type: core::HostMem_AllocType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_HostMem_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_HostMem_Size_int_AllocType(size: *const core::Size, typ: i32, alloc_type: core::HostMem_AllocType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_HostMem_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_HostMem_const__InputArrayR_AllocType(arr: *const c_void, alloc_type: core::HostMem_AllocType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_HostMem_const__InputArrayR(arr: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_operatorST_const_HostMemR(instance: *mut c_void, m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HostMem_swap_HostMemR(instance: *mut c_void, b: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HostMem_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_create_int_int_int(instance: *mut c_void, rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HostMem_create_Size_int(instance: *mut c_void, size: *const core::Size, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HostMem_reshape_const_int_int(instance: *const c_void, cn: i32, rows: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_reshape_const_int(instance: *const c_void, cn: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HostMem_createMatHeader_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_createGpuMatHeader_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HostMem_isContinuous_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_HostMem_elemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_HostMem_elemSize1_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_HostMem_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HostMem_depth_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HostMem_channels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HostMem_step1_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_HostMem_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_cuda_HostMem_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_HostMem_propFlags_const(instance: *const c_void) -> i32;
		pub fn cv_cuda_HostMem_propFlags_int(instance: *mut c_void, val: i32);
		pub fn cv_cuda_HostMem_propRows_const(instance: *const c_void) -> i32;
		pub fn cv_cuda_HostMem_propRows_int(instance: *mut c_void, val: i32);
		pub fn cv_cuda_HostMem_propCols_const(instance: *const c_void) -> i32;
		pub fn cv_cuda_HostMem_propCols_int(instance: *mut c_void, val: i32);
		pub fn cv_cuda_HostMem_propStep_const(instance: *const c_void) -> size_t;
		pub fn cv_cuda_HostMem_propStep_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_cuda_HostMem_propData(instance: *mut c_void) -> *mut u8;
		pub fn cv_cuda_HostMem_propData_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_cuda_HostMem_propRefcount(instance: *mut c_void) -> *mut i32;
		pub fn cv_cuda_HostMem_propRefcount_intX(instance: *mut c_void, val: *mut i32);
		pub fn cv_cuda_HostMem_propDatastart(instance: *mut c_void) -> *mut u8;
		pub fn cv_cuda_HostMem_propDatastart_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_cuda_HostMem_propDataend_const(instance: *const c_void) -> *const u8;
		pub fn cv_cuda_HostMem_propAlloc_type_const(instance: *const c_void, ocvrs_return: *mut core::HostMem_AllocType);
		pub fn cv_cuda_HostMem_propAlloc_type_AllocType(instance: *mut c_void, val: core::HostMem_AllocType);
		pub fn cv_cuda_HostMem_delete(instance: *mut c_void);
		pub fn cv_cuda_Stream_Stream(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_Stream_Stream_const_PtrLAllocatorGR(allocator: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_Stream_Stream_const_size_t(cuda_flags: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_Stream_queryIfComplete_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_Stream_waitForCompletion(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Stream_waitEvent_const_EventR(instance: *mut c_void, event: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Stream_enqueueHostCallback_StreamCallback_voidX(instance: *mut c_void, callback: Option<unsafe extern "C" fn(i32, *mut c_void) -> ()>, user_data: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Stream_Null(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_Stream_cudaPtr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_Stream_delete(instance: *mut c_void);
		pub fn cv_cuda_TargetArchs_builtWith_FeatureSet(feature_set: core::FeatureSet, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_TargetArchs_has_int_int(major: i32, minor: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_TargetArchs_hasPtx_int_int(major: i32, minor: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_TargetArchs_hasBin_int_int(major: i32, minor: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_TargetArchs_hasEqualOrLessPtx_int_int(major: i32, minor: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_TargetArchs_hasEqualOrGreater_int_int(major: i32, minor: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_TargetArchs_hasEqualOrGreaterPtx_int_int(major: i32, minor: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_TargetArchs_hasEqualOrGreaterBin_int_int(major: i32, minor: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_TargetArchs_delete(instance: *mut c_void);
		pub fn cv_detail_CheckContext_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CheckContext_defaultNew_const() -> *mut c_void;
		pub fn cv_detail_CheckContext_propFunc_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CheckContext_propFile_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CheckContext_propLine_const(instance: *const c_void) -> i32;
		pub fn cv_detail_CheckContext_propLine_int(instance: *mut c_void, val: i32);
		pub fn cv_detail_CheckContext_propTestOp_const(instance: *const c_void, ocvrs_return: *mut core::Detail_TestOp);
		pub fn cv_detail_CheckContext_propTestOp_TestOp(instance: *mut c_void, val: core::Detail_TestOp);
		pub fn cv_detail_CheckContext_propMessage_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CheckContext_propP1_str_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CheckContext_propP2_str_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CheckContext_delete(instance: *mut c_void);
		pub fn cv_instr_NodeData_NodeData_const_charX_const_charX_int_voidX_bool_TYPE_IMPL(fun_name: *const c_char, file_name: *const c_char, line_num: i32, ret_address: *mut c_void, always_expand: bool, instr_type: core::TYPE, impl_type: core::IMPL, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_instr_NodeData_NodeData(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_instr_NodeData_NodeData_NodeDataR(ref_: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_instr_NodeData_operatorST_const_NodeDataR(instance: *mut c_void, unnamed: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_instr_NodeData_getTotalMs_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_instr_NodeData_getMeanMs_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_instr_NodeData_propM_funName_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_instr_NodeData_propM_funName_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_instr_NodeData_propM_instrType_const(instance: *const c_void, ocvrs_return: *mut core::TYPE);
		pub fn cv_instr_NodeData_propM_instrType_TYPE(instance: *mut c_void, val: core::TYPE);
		pub fn cv_instr_NodeData_propM_implType_const(instance: *const c_void, ocvrs_return: *mut core::IMPL);
		pub fn cv_instr_NodeData_propM_implType_IMPL(instance: *mut c_void, val: core::IMPL);
		pub fn cv_instr_NodeData_propM_fileName_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_instr_NodeData_propM_lineNum_const(instance: *const c_void) -> i32;
		pub fn cv_instr_NodeData_propM_lineNum_int(instance: *mut c_void, val: i32);
		pub fn cv_instr_NodeData_propM_retAddress(instance: *mut c_void) -> *mut c_void;
		pub fn cv_instr_NodeData_propM_retAddress_voidX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_instr_NodeData_propM_alwaysExpand_const(instance: *const c_void) -> bool;
		pub fn cv_instr_NodeData_propM_alwaysExpand_bool(instance: *mut c_void, val: bool);
		pub fn cv_instr_NodeData_propM_funError_const(instance: *const c_void) -> bool;
		pub fn cv_instr_NodeData_propM_funError_bool(instance: *mut c_void, val: bool);
		pub fn cv_instr_NodeData_propM_counter_const(instance: *const c_void) -> i32;
		pub fn cv_instr_NodeData_propM_counter_int(instance: *mut c_void, val: i32);
		pub fn cv_instr_NodeData_propM_ticksTotal_const(instance: *const c_void) -> u64;
		pub fn cv_instr_NodeData_propM_ticksTotal_uint64_t(instance: *mut c_void, val: u64);
		pub fn cv_instr_NodeData_propM_threads_const(instance: *const c_void) -> i32;
		pub fn cv_instr_NodeData_propM_threads_int(instance: *mut c_void, val: i32);
		pub fn cv_instr_NodeData_delete(instance: *mut c_void);
		pub fn cv_internal_WriteStructContext_WriteStructContext_FileStorageR_const_StringR_int_const_StringR(_fs: *mut c_void, name: *const c_char, flags: i32, type_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_internal_WriteStructContext_WriteStructContext_FileStorageR_const_StringR_int(_fs: *mut c_void, name: *const c_char, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_internal_WriteStructContext_delete(instance: *mut c_void);
		pub fn cv_ocl_Context_Context() -> *mut c_void;
		pub fn cv_ocl_Context_Context_int(dtype: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_Context_const_ContextR(c: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_operatorST_const_ContextR(instance: *mut c_void, c: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Context_Context_ContextRR(c: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Context_operatorST_ContextRR(instance: *mut c_void, c: *mut c_void);
		pub fn cv_ocl_Context_create(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Context_create_int(instance: *mut c_void, dtype: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Context_ndevices_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Context_device_const_size_t(instance: *const c_void, idx: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_getProg_const_ProgramSourceR_const_StringR_StringR(instance: *mut c_void, prog: *const c_void, buildopt: *const c_char, errmsg: *mut *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_unloadProg_ProgramR(instance: *mut c_void, prog: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Context_getDefault_bool(initialize: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_getDefault(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_getOpenCLContextProperty_const_int(instance: *const c_void, property_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_useSVM_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Context_setUseSVM_bool(instance: *mut c_void, enabled: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Context_fromHandle_voidX(context: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_fromDevice_const_DeviceR(device: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_create_const_stringR(configuration: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Context_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Context_delete(instance: *mut c_void);
		pub fn cv_ocl_Context_UserContext_delete(instance: *mut c_void);
		pub fn cv_ocl_Device_Device() -> *mut c_void;
		pub fn cv_ocl_Device_Device_voidX(d: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_Device_const_DeviceR(d: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_operatorST_const_DeviceR(instance: *mut c_void, d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Device_Device_DeviceRR(d: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Device_operatorST_DeviceRR(instance: *mut c_void, d: *mut c_void);
		pub fn cv_ocl_Device_set_voidX(instance: *mut c_void, d: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Device_name_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_extensions_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_isExtensionSupported_const_const_StringR(instance: *const c_void, extension_name: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_version_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_vendorName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_OpenCL_C_Version_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_OpenCLVersion_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_deviceVersionMajor_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_deviceVersionMinor_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_driverVersion_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_addressBits_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_available_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_compilerAvailable_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_linkerAvailable_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_doubleFPConfig_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_singleFPConfig_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_halfFPConfig_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_endianLittle_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_errorCorrectionSupport_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_executionCapabilities_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_globalMemCacheSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_globalMemCacheType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_globalMemCacheLineSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_globalMemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_localMemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_localMemType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_hostUnifiedMemory_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_imageSupport_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_imageFromBufferSupport_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_imagePitchAlignment_const(instance: *const c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_ocl_Device_imageBaseAddressAlignment_const(instance: *const c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_ocl_Device_intelSubgroupsSupport_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_image2DMaxWidth_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_image2DMaxHeight_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_image3DMaxWidth_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_image3DMaxHeight_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_image3DMaxDepth_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_imageMaxBufferSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_imageMaxArraySize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_vendorID_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_isAMD_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_isIntel_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_isNVidia_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_maxClockFrequency_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxComputeUnits_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxConstantArgs_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxConstantBufferSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_maxMemAllocSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_maxParameterSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_maxReadImageArgs_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxWriteImageArgs_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxSamplers_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxWorkGroupSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_maxWorkItemDims_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxWorkItemSizes_const_size_tX(instance: *const c_void, unnamed: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Device_memBaseAddrAlign_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthChar_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthShort_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthInt_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthLong_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthFloat_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthDouble_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthHalf_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthChar_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthShort_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthInt_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthLong_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthFloat_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthDouble_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthHalf_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_printfBufferSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_profilingTimerResolution_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_getDefault(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_fromHandle_voidX(d: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_ocl_Device_delete(instance: *mut c_void);
		pub fn cv_ocl_Image2D_Image2D() -> *mut c_void;
		pub fn cv_ocl_Image2D_Image2D_const_UMatR_bool_bool(src: *const c_void, norm: bool, alias: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Image2D_Image2D_const_UMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Image2D_Image2D_const_Image2DR(i: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Image2D_operatorST_const_Image2DR(instance: *mut c_void, i: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Image2D_Image2D_Image2DRR(unnamed: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Image2D_operatorST_Image2DRR(instance: *mut c_void, unnamed: *mut c_void);
		pub fn cv_ocl_Image2D_canCreateAlias_const_UMatR(u: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Image2D_isFormatSupported_int_int_bool(depth: i32, cn: i32, norm: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Image2D_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Image2D_delete(instance: *mut c_void);
		pub fn cv_ocl_Kernel_Kernel() -> *mut c_void;
		pub fn cv_ocl_Kernel_Kernel_const_charX_const_ProgramR(kname: *const c_char, prog: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Kernel_Kernel_const_charX_const_ProgramSourceR_const_StringR_StringX(kname: *const c_char, prog: *const c_void, buildopts: *const c_char, errmsg: *mut *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Kernel_Kernel_const_charX_const_ProgramSourceR(kname: *const c_char, prog: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Kernel_Kernel_const_KernelR(k: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Kernel_operatorST_const_KernelR(instance: *mut c_void, k: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Kernel_Kernel_KernelRR(k: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Kernel_operatorST_KernelRR(instance: *mut c_void, k: *mut c_void);
		pub fn cv_ocl_Kernel_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_create_const_charX_const_ProgramR(instance: *mut c_void, kname: *const c_char, prog: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_create_const_charX_const_ProgramSourceR_const_StringR_StringX(instance: *mut c_void, kname: *const c_char, prog: *const c_void, buildopts: *const c_char, errmsg: *mut *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_create_const_charX_const_ProgramSourceR_const_StringR(instance: *mut c_void, kname: *const c_char, prog: *const c_void, buildopts: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_set_int_const_voidX_size_t(instance: *mut c_void, i: i32, value: *const c_void, sz: size_t, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Kernel_set_int_const_Image2DR(instance: *mut c_void, i: i32, image_2d: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Kernel_set_int_const_UMatR(instance: *mut c_void, i: i32, m: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Kernel_set_int_const_KernelArgR(instance: *mut c_void, i: i32, arg: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Kernel_run_int_size_tX_size_tX_bool_const_QueueR(instance: *mut c_void, dims: i32, globalsize: *mut size_t, localsize: *mut size_t, sync: bool, q: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_run_int_size_tX_size_tX_bool(instance: *mut c_void, dims: i32, globalsize: *mut size_t, localsize: *mut size_t, sync: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_run__int_size_tX_size_tX_bool_const_QueueR(instance: *mut c_void, dims: i32, globalsize: *mut size_t, localsize: *mut size_t, sync: bool, q: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_run__int_size_tX_size_tX_bool(instance: *mut c_void, dims: i32, globalsize: *mut size_t, localsize: *mut size_t, sync: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_runTask_bool_const_QueueR(instance: *mut c_void, sync: bool, q: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_runTask_bool(instance: *mut c_void, sync: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_runProfiling_int_size_tX_size_tX_const_QueueR(instance: *mut c_void, dims: i32, globalsize: *mut size_t, localsize: *mut size_t, q: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_ocl_Kernel_runProfiling_int_size_tX_size_tX(instance: *mut c_void, dims: i32, globalsize: *mut size_t, localsize: *mut size_t, ocvrs_return: *mut Result<i64>);
		pub fn cv_ocl_Kernel_workGroupSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Kernel_preferedWorkGroupSizeMultiple_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Kernel_compileWorkGroupSize_const_size_tX(instance: *const c_void, wsz: *mut size_t, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_localMemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Kernel_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Kernel_delete(instance: *mut c_void);
		pub fn cv_ocl_KernelArg_KernelArg_int_UMatX_int_int_const_voidX_size_t(_flags: i32, _m: *mut c_void, wscale: i32, iwscale: i32, _obj: *const c_void, _sz: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_KernelArg_int_UMatX(_flags: i32, _m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_KernelArg() -> *mut c_void;
		pub fn cv_ocl_KernelArg_Local_size_t(local_mem_size: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_PtrWriteOnly_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_PtrReadOnly_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_PtrReadWrite_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadWrite_const_UMatR_int_int(m: *const c_void, wscale: i32, iwscale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadWrite_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadWriteNoSize_const_UMatR_int_int(m: *const c_void, wscale: i32, iwscale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadWriteNoSize_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadOnly_const_UMatR_int_int(m: *const c_void, wscale: i32, iwscale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadOnly_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_WriteOnly_const_UMatR_int_int(m: *const c_void, wscale: i32, iwscale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_WriteOnly_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadOnlyNoSize_const_UMatR_int_int(m: *const c_void, wscale: i32, iwscale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadOnlyNoSize_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_WriteOnlyNoSize_const_UMatR_int_int(m: *const c_void, wscale: i32, iwscale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_WriteOnlyNoSize_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_Constant_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_propFlags_const(instance: *const c_void) -> i32;
		pub fn cv_ocl_KernelArg_propFlags_int(instance: *mut c_void, val: i32);
		pub fn cv_ocl_KernelArg_propM(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_KernelArg_propM_UMatX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_ocl_KernelArg_propObj_const(instance: *const c_void) -> *const c_void;
		pub fn cv_ocl_KernelArg_propSz_const(instance: *const c_void) -> size_t;
		pub fn cv_ocl_KernelArg_propSz_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_ocl_KernelArg_propWscale_const(instance: *const c_void) -> i32;
		pub fn cv_ocl_KernelArg_propWscale_int(instance: *mut c_void, val: i32);
		pub fn cv_ocl_KernelArg_propIwscale_const(instance: *const c_void) -> i32;
		pub fn cv_ocl_KernelArg_propIwscale_int(instance: *mut c_void, val: i32);
		pub fn cv_ocl_KernelArg_delete(instance: *mut c_void);
		pub fn cv_ocl_OpenCLExecutionContext_OpenCLExecutionContext() -> *mut c_void;
		pub fn cv_ocl_OpenCLExecutionContext_OpenCLExecutionContext_const_OpenCLExecutionContextR(unnamed: *const c_void) -> *mut c_void;
		pub fn cv_ocl_OpenCLExecutionContext_OpenCLExecutionContext_OpenCLExecutionContextRR(unnamed: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_OpenCLExecutionContext_operatorST_const_OpenCLExecutionContextR(instance: *mut c_void, unnamed: *const c_void);
		pub fn cv_ocl_OpenCLExecutionContext_operatorST_OpenCLExecutionContextRR(instance: *mut c_void, unnamed: *mut c_void);
		pub fn cv_ocl_OpenCLExecutionContext_getContext_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_getDevice_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_getQueue_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_useOpenCL_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_OpenCLExecutionContext_setUseOpenCL_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_OpenCLExecutionContext_getCurrent(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_getCurrentRef(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_bind_const(instance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_OpenCLExecutionContext_cloneWithNewQueue_const_const_QueueR(instance: *const c_void, q: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_cloneWithNewQueue_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_create_const_stringR_voidX_voidX_voidX(platform_name: *const c_char, platform_id: *mut c_void, context: *mut c_void, device_id: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_create_const_ContextR_const_DeviceR_const_QueueR(context: *const c_void, device: *const c_void, queue: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_create_const_ContextR_const_DeviceR(context: *const c_void, device: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_OpenCLExecutionContext_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_OpenCLExecutionContext_delete(instance: *mut c_void);
		pub fn cv_ocl_Platform_Platform() -> *mut c_void;
		pub fn cv_ocl_Platform_Platform_const_PlatformR(p: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Platform_operatorST_const_PlatformR(instance: *mut c_void, p: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Platform_Platform_PlatformRR(p: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Platform_operatorST_PlatformRR(instance: *mut c_void, p: *mut c_void);
		pub fn cv_ocl_Platform_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Platform_getDefault(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Platform_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Platform_delete(instance: *mut c_void);
		pub fn cv_ocl_PlatformInfo_PlatformInfo() -> *mut c_void;
		pub fn cv_ocl_PlatformInfo_PlatformInfo_voidX(id: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_PlatformInfo_PlatformInfo_const_PlatformInfoR(i: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_PlatformInfo_operatorST_const_PlatformInfoR(instance: *mut c_void, i: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_PlatformInfo_PlatformInfo_PlatformInfoRR(i: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_PlatformInfo_operatorST_PlatformInfoRR(instance: *mut c_void, i: *mut c_void);
		pub fn cv_ocl_PlatformInfo_name_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_PlatformInfo_vendor_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_PlatformInfo_version_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_PlatformInfo_versionMajor_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_PlatformInfo_versionMinor_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_PlatformInfo_deviceNumber_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_PlatformInfo_getDevice_const_DeviceR_int(instance: *const c_void, device: *mut c_void, d: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_PlatformInfo_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_PlatformInfo_delete(instance: *mut c_void);
		pub fn cv_ocl_Program_Program() -> *mut c_void;
		pub fn cv_ocl_Program_Program_const_ProgramSourceR_const_StringR_StringR(src: *const c_void, buildflags: *const c_char, errmsg: *mut *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Program_Program_const_ProgramR(prog: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Program_operatorST_const_ProgramR(instance: *mut c_void, prog: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Program_Program_ProgramRR(prog: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Program_operatorST_ProgramRR(instance: *mut c_void, prog: *mut c_void);
		pub fn cv_ocl_Program_create_const_ProgramSourceR_const_StringR_StringR(instance: *mut c_void, src: *const c_void, buildflags: *const c_char, errmsg: *mut *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Program_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Program_getBinary_const_vectorLcharGR(instance: *const c_void, binary: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Program_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Program_read_const_StringR_const_StringR(instance: *mut c_void, buf: *const c_char, buildflags: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Program_write_const_StringR(instance: *const c_void, buf: *mut *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Program_source_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Program_getPrefix_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Program_getPrefix_const_StringR(buildflags: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Program_delete(instance: *mut c_void);
		pub fn cv_ocl_ProgramSource_ProgramSource() -> *mut c_void;
		pub fn cv_ocl_ProgramSource_ProgramSource_const_StringR_const_StringR_const_StringR_const_StringR(module: *const c_char, name: *const c_char, code_str: *const c_char, code_hash: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_ProgramSource_const_StringR(prog: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_ProgramSource_const_ProgramSourceR(prog: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_operatorST_const_ProgramSourceR(instance: *mut c_void, prog: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_ProgramSource_ProgramSource_ProgramSourceRR(prog: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_ProgramSource_operatorST_ProgramSourceRR(instance: *mut c_void, prog: *mut c_void);
		pub fn cv_ocl_ProgramSource_source_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_hash_const(instance: *const c_void, ocvrs_return: *mut Result<core::ProgramSource_hash_t>);
		pub fn cv_ocl_ProgramSource_fromBinary_const_StringR_const_StringR_const_unsigned_charX_const_size_t_const_StringR(module: *const c_char, name: *const c_char, binary: *const u8, size: size_t, build_options: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_fromBinary_const_StringR_const_StringR_const_unsigned_charX_const_size_t(module: *const c_char, name: *const c_char, binary: *const u8, size: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_fromSPIR_const_StringR_const_StringR_const_unsigned_charX_const_size_t_const_StringR(module: *const c_char, name: *const c_char, binary: *const u8, size: size_t, build_options: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_fromSPIR_const_StringR_const_StringR_const_unsigned_charX_const_size_t(module: *const c_char, name: *const c_char, binary: *const u8, size: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_ProgramSource_delete(instance: *mut c_void);
		pub fn cv_ocl_Queue_Queue() -> *mut c_void;
		pub fn cv_ocl_Queue_Queue_const_ContextR_const_DeviceR(c: *const c_void, d: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Queue_Queue_const_ContextR(c: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Queue_Queue_const_QueueR(q: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Queue_operatorST_const_QueueR(instance: *mut c_void, q: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Queue_Queue_QueueRR(q: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Queue_operatorST_QueueRR(instance: *mut c_void, q: *mut c_void);
		pub fn cv_ocl_Queue_create_const_ContextR_const_DeviceR(instance: *mut c_void, c: *const c_void, d: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Queue_create(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Queue_finish(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Queue_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Queue_getDefault(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Queue_getProfilingQueue_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Queue_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Queue_delete(instance: *mut c_void);
		pub fn cv_ocl_Timer_Timer_const_QueueR(q: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Timer_start(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Timer_stop(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ocl_Timer_durationNS_const(instance: *const c_void, ocvrs_return: *mut Result<u64>);
		pub fn cv_ocl_Timer_delete(instance: *mut c_void);
		pub fn cv_ogl_Arrays_Arrays(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Arrays_setVertexArray_const__InputArrayR(instance: *mut c_void, vertex: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_resetVertexArray(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_setColorArray_const__InputArrayR(instance: *mut c_void, color: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_resetColorArray(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_setNormalArray_const__InputArrayR(instance: *mut c_void, normal: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_resetNormalArray(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_setTexCoordArray_const__InputArrayR(instance: *mut c_void, tex_coord: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_resetTexCoordArray(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_setAutoRelease_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_bind_const(instance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Arrays_size_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Arrays_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ogl_Arrays_delete(instance: *mut c_void);
		pub fn cv_ogl_Buffer_Buffer(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_Buffer_int_int_int_unsigned_int_bool(arows: i32, acols: i32, atype: i32, abuf_id: u32, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_Buffer_int_int_int_unsigned_int(arows: i32, acols: i32, atype: i32, abuf_id: u32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_Buffer_Size_int_unsigned_int_bool(asize: *const core::Size, atype: i32, abuf_id: u32, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_Buffer_Size_int_unsigned_int(asize: *const core::Size, atype: i32, abuf_id: u32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_Buffer_int_int_int_Target_bool(arows: i32, acols: i32, atype: i32, target: core::Buffer_Target, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_Buffer_int_int_int(arows: i32, acols: i32, atype: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_Buffer_Size_int_Target_bool(asize: *const core::Size, atype: i32, target: core::Buffer_Target, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_Buffer_Size_int(asize: *const core::Size, atype: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_Buffer_const__InputArrayR_Target_bool(arr: *const c_void, target: core::Buffer_Target, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_Buffer_const__InputArrayR(arr: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_create_int_int_int_Target_bool(instance: *mut c_void, arows: i32, acols: i32, atype: i32, target: core::Buffer_Target, auto_release: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_create_int_int_int(instance: *mut c_void, arows: i32, acols: i32, atype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_create_Size_int_Target_bool(instance: *mut c_void, asize: *const core::Size, atype: i32, target: core::Buffer_Target, auto_release: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_create_Size_int(instance: *mut c_void, asize: *const core::Size, atype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_setAutoRelease_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_copyFrom_const__InputArrayR_Target_bool(instance: *mut c_void, arr: *const c_void, target: core::Buffer_Target, auto_release: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_copyFrom_const__InputArrayR(instance: *mut c_void, arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_copyFrom_const__InputArrayR_StreamR_Target_bool(instance: *mut c_void, arr: *const c_void, stream: *mut c_void, target: core::Buffer_Target, auto_release: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_copyFrom_const__InputArrayR_StreamR(instance: *mut c_void, arr: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_copyTo_const_const__OutputArrayR(instance: *const c_void, arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_copyTo_const_const__OutputArrayR_StreamR(instance: *const c_void, arr: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_clone_const_Target_bool(instance: *const c_void, target: core::Buffer_Target, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_bind_const_Target(instance: *const c_void, target: core::Buffer_Target, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_unbind_Target(target: core::Buffer_Target, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_mapHost_Access(instance: *mut c_void, access: core::Buffer_Access, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_unmapHost(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_mapDevice(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_unmapDevice(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_mapDevice_StreamR(instance: *mut c_void, stream: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Buffer_unmapDevice_StreamR(instance: *mut c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Buffer_rows_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Buffer_cols_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Buffer_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_ogl_Buffer_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ogl_Buffer_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Buffer_depth_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Buffer_channels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Buffer_elemSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Buffer_elemSize1_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Buffer_bufId_const(instance: *const c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_ogl_Buffer_delete(instance: *mut c_void);
		pub fn cv_ogl_Texture2D_Texture2D(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Texture2D_Texture2D_int_int_Format_unsigned_int_bool(arows: i32, acols: i32, aformat: core::Texture2D_Format, atex_id: u32, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Texture2D_Texture2D_int_int_Format_unsigned_int(arows: i32, acols: i32, aformat: core::Texture2D_Format, atex_id: u32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Texture2D_Texture2D_Size_Format_unsigned_int_bool(asize: *const core::Size, aformat: core::Texture2D_Format, atex_id: u32, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Texture2D_Texture2D_Size_Format_unsigned_int(asize: *const core::Size, aformat: core::Texture2D_Format, atex_id: u32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Texture2D_Texture2D_int_int_Format_bool(arows: i32, acols: i32, aformat: core::Texture2D_Format, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Texture2D_Texture2D_int_int_Format(arows: i32, acols: i32, aformat: core::Texture2D_Format, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Texture2D_Texture2D_Size_Format_bool(asize: *const core::Size, aformat: core::Texture2D_Format, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Texture2D_Texture2D_Size_Format(asize: *const core::Size, aformat: core::Texture2D_Format, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Texture2D_Texture2D_const__InputArrayR_bool(arr: *const c_void, auto_release: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Texture2D_Texture2D_const__InputArrayR(arr: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ogl_Texture2D_create_int_int_Format_bool(instance: *mut c_void, arows: i32, acols: i32, aformat: core::Texture2D_Format, auto_release: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Texture2D_create_int_int_Format(instance: *mut c_void, arows: i32, acols: i32, aformat: core::Texture2D_Format, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Texture2D_create_Size_Format_bool(instance: *mut c_void, asize: *const core::Size, aformat: core::Texture2D_Format, auto_release: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Texture2D_create_Size_Format(instance: *mut c_void, asize: *const core::Size, aformat: core::Texture2D_Format, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Texture2D_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Texture2D_setAutoRelease_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Texture2D_copyFrom_const__InputArrayR_bool(instance: *mut c_void, arr: *const c_void, auto_release: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Texture2D_copyFrom_const__InputArrayR(instance: *mut c_void, arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Texture2D_copyTo_const_const__OutputArrayR_int_bool(instance: *const c_void, arr: *const c_void, ddepth: i32, auto_release: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Texture2D_copyTo_const_const__OutputArrayR(instance: *const c_void, arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Texture2D_bind_const(instance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ogl_Texture2D_rows_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Texture2D_cols_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ogl_Texture2D_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_ogl_Texture2D_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ogl_Texture2D_format_const(instance: *const c_void, ocvrs_return: *mut Result<core::Texture2D_Format>);
		pub fn cv_ogl_Texture2D_texId_const(instance: *const c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_ogl_Texture2D_delete(instance: *mut c_void);
		pub fn cv_utils_ClassWithKeywordProperties_ClassWithKeywordProperties_int_int(lambda_arg: i32, except_arg: i32, ocvrs_return: *mut Result<core::ClassWithKeywordProperties>);
		pub fn cv_utils_ClassWithKeywordProperties_ClassWithKeywordProperties(ocvrs_return: *mut Result<core::ClassWithKeywordProperties>);
		pub fn cv_utils_FunctionParams_setLambda_int(instance: *mut c_void, value: i32) -> *mut c_void;
		pub fn cv_utils_FunctionParams_setSigma_float(instance: *mut c_void, value: f32) -> *mut c_void;
		pub fn cv_utils_FunctionParams_propLambda_const(instance: *const c_void) -> i32;
		pub fn cv_utils_FunctionParams_propLambda_int(instance: *mut c_void, val: i32);
		pub fn cv_utils_FunctionParams_propSigma_const(instance: *const c_void) -> f32;
		pub fn cv_utils_FunctionParams_propSigma_float(instance: *mut c_void, val: f32);
		pub fn cv_utils_FunctionParams_delete(instance: *mut c_void);
		pub fn cv_utils_logging_LogTag_LogTag_const_charX_LogLevel(_name: *const c_char, _level: core::LogLevel, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_logging_LogTag_propName_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_utils_logging_LogTag_propLevel_const(instance: *const c_void, ocvrs_return: *mut core::LogLevel);
		pub fn cv_utils_logging_LogTag_propLevel_LogLevel(instance: *mut c_void, val: core::LogLevel);
		pub fn cv_utils_logging_LogTag_delete(instance: *mut c_void);
		pub fn cv_utils_nested_OriginalClassName_OriginalClassName_const_ParamsR(params: *const core::OriginalClassName_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_nested_OriginalClassName_OriginalClassName(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_nested_OriginalClassName_getIntParam_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_utils_nested_OriginalClassName_getFloatParam_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_utils_nested_OriginalClassName_originalName(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_nested_OriginalClassName_create_const_ParamsR(params: *const core::OriginalClassName_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_nested_OriginalClassName_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_nested_OriginalClassName_delete(instance: *mut c_void);
		pub fn cv_utils_nested_OriginalClassName_Params_Params_int_float(int_param: i32, float_param: f32, ocvrs_return: *mut Result<core::OriginalClassName_Params>);
		pub fn cv_utils_nested_OriginalClassName_Params_Params(ocvrs_return: *mut Result<core::OriginalClassName_Params>);
		pub fn cv_PtrLcv_AlgorithmG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AlgorithmG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AlgorithmG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_AlgorithmG_new_const_Algorithm(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ConjGradSolverG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ConjGradSolverG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ConjGradSolverG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ConjGradSolverG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ConjGradSolverG_to_PtrOfMinProblemSolver(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DownhillSolverG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DownhillSolverG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DownhillSolverG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_DownhillSolverG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DownhillSolverG_to_PtrOfMinProblemSolver(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FileStorageG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FileStorageG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FileStorageG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_FileStorageG_new_const_FileStorage(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FormattedG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FormattedG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FormattedG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_FormatterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FormatterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FormatterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_GpuMat_AllocatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_GpuMat_AllocatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_GpuMat_AllocatorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_MinProblemSolverG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MinProblemSolverG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MinProblemSolverG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_MinProblemSolverG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MinProblemSolver_FunctionG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MinProblemSolver_FunctionG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MinProblemSolver_FunctionG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_utils_nested_OriginalClassNameG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_utils_nested_OriginalClassNameG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_utils_nested_OriginalClassNameG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_utils_nested_OriginalClassNameG_new_const_OriginalClassName(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLfloatG_getInnerPtr_const(instance: *const c_void) -> *const f32;
		pub fn cv_PtrLfloatG_getInnerPtrMut(instance: *mut c_void) -> *mut f32;
		pub fn cv_PtrLfloatG_delete(instance: *mut c_void);
		pub fn cv_PtrLfloatG_new_const_float(val: f32) -> *mut c_void;
		pub fn std_pairLcv_Point2i__cv_Point2iG_new_const_Point2i_Point2i(arg: *const core::Point2i, arg_1: *const core::Point2i) -> *mut c_void;
		pub fn std_pairLcv_Point2i__cv_Point2iG_get_0_const(instance: *const c_void, ocvrs_return: *mut core::Point2i);
		pub fn std_pairLcv_Point2i__cv_Point2iG_get_1_const(instance: *const c_void, ocvrs_return: *mut core::Point2i);
		pub fn std_pairLcv_Point2i__cv_Point2iG_delete(instance: *mut c_void);
		pub fn std_pairLcv_Rect__intG_new_const_Rect_int(arg: *const core::Rect, arg_1: i32) -> *mut c_void;
		pub fn std_pairLcv_Rect__intG_get_0_const(instance: *const c_void, ocvrs_return: *mut core::Rect);
		pub fn std_pairLcv_Rect__intG_get_1_const(instance: *const c_void, ocvrs_return: *mut i32);
		pub fn std_pairLcv_Rect__intG_delete(instance: *mut c_void);
		pub fn std_pairLcv_UMat__unsigned_charG_new_const_UMat_unsigned_char(arg: *mut c_void, arg_1: u8) -> *mut c_void;
		pub fn std_pairLcv_UMat__unsigned_charG_get_0_const(instance: *const c_void, ocvrs_return: *mut *mut c_void);
		pub fn std_pairLcv_UMat__unsigned_charG_get_1_const(instance: *const c_void, ocvrs_return: *mut u8);
		pub fn std_pairLcv_UMat__unsigned_charG_delete(instance: *mut c_void);
		pub fn std_pairLint__floatG_new_const_int_float(arg: i32, arg_1: f32) -> *mut c_void;
		pub fn std_pairLint__floatG_get_0_const(instance: *const c_void, ocvrs_return: *mut i32);
		pub fn std_pairLint__floatG_get_1_const(instance: *const c_void, ocvrs_return: *mut f32);
		pub fn std_pairLint__floatG_delete(instance: *mut c_void);
		pub fn std_pairLint__doubleG_new_const_int_double(arg: i32, arg_1: f64) -> *mut c_void;
		pub fn std_pairLint__doubleG_get_0_const(instance: *const c_void, ocvrs_return: *mut i32);
		pub fn std_pairLint__doubleG_get_1_const(instance: *const c_void, ocvrs_return: *mut f64);
		pub fn std_pairLint__doubleG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_DMatchG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_DMatchG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_DMatchG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_DMatchG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_DMatchG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_DMatchG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_DMatchG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_DMatchG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_DMatchG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_DMatchG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_DMatchG_push_const_DMatch(instance: *mut c_void, val: *const core::DMatch);
		pub fn std_vectorLcv_DMatchG_insert_size_t_const_DMatch(instance: *mut c_void, index: size_t, val: *const core::DMatch);
		pub fn std_vectorLcv_DMatchG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::DMatch);
		pub fn std_vectorLcv_DMatchG_set_size_t_const_DMatch(instance: *mut c_void, index: size_t, val: *const core::DMatch);
		pub fn std_vectorLcv_DMatchG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_DMatchG_data_const(instance: *const c_void) -> *const core::DMatch;
		pub fn std_vectorLcv_DMatchG_dataMut(instance: *mut c_void) -> *mut core::DMatch;
		pub fn cv_fromSlice_const_const_DMatchX_size_t(data: *const core::DMatch, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_cuda_GpuMatG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_cuda_GpuMatG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_cuda_GpuMatG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_cuda_GpuMatG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_cuda_GpuMatG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_cuda_GpuMatG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_cuda_GpuMatG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_cuda_GpuMatG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_cuda_GpuMatG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_cuda_GpuMatG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_cuda_GpuMatG_push_const_GpuMat(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_cuda_GpuMatG_insert_size_t_const_GpuMat(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_cuda_GpuMatG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_cuda_GpuMatG_set_size_t_const_GpuMat(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_KeyPointG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_KeyPointG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_KeyPointG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_KeyPointG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_KeyPointG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_KeyPointG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_KeyPointG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_KeyPointG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_KeyPointG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_KeyPointG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_KeyPointG_push_const_KeyPoint(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_KeyPointG_insert_size_t_const_KeyPoint(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_KeyPointG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_KeyPointG_set_size_t_const_KeyPoint(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_MatG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_MatG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_MatG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_MatG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_MatG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_MatG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_MatG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_MatG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_MatG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_MatG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_MatG_push_const_Mat(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_MatG_insert_size_t_const_Mat(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_MatG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_MatG_set_size_t_const_Mat(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_ocl_PlatformInfoG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_ocl_PlatformInfoG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_ocl_PlatformInfoG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_ocl_PlatformInfoG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_ocl_PlatformInfoG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_ocl_PlatformInfoG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_ocl_PlatformInfoG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_ocl_PlatformInfoG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_ocl_PlatformInfoG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_ocl_PlatformInfoG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_ocl_PlatformInfoG_push_const_PlatformInfo(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_ocl_PlatformInfoG_insert_size_t_const_PlatformInfo(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_ocl_PlatformInfoG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_ocl_PlatformInfoG_set_size_t_const_PlatformInfo(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_PointG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_PointG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_PointG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_PointG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_PointG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_PointG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_PointG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_PointG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_PointG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_PointG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_PointG_push_const_Point(instance: *mut c_void, val: *const core::Point);
		pub fn std_vectorLcv_PointG_insert_size_t_const_Point(instance: *mut c_void, index: size_t, val: *const core::Point);
		pub fn std_vectorLcv_PointG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Point);
		pub fn std_vectorLcv_PointG_set_size_t_const_Point(instance: *mut c_void, index: size_t, val: *const core::Point);
		pub fn std_vectorLcv_PointG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_PointG_data_const(instance: *const c_void) -> *const core::Point;
		pub fn std_vectorLcv_PointG_dataMut(instance: *mut c_void) -> *mut core::Point;
		pub fn cv_fromSlice_const_const_PointX_size_t(data: *const core::Point, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_PointG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_PointG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_PointG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point2dG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Point2dG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Point2dG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Point2dG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Point2dG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Point2dG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Point2dG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Point2dG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Point2dG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Point2dG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Point2dG_push_const_Point2d(instance: *mut c_void, val: *const core::Point2d);
		pub fn std_vectorLcv_Point2dG_insert_size_t_const_Point2d(instance: *mut c_void, index: size_t, val: *const core::Point2d);
		pub fn std_vectorLcv_Point2dG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Point2d);
		pub fn std_vectorLcv_Point2dG_set_size_t_const_Point2d(instance: *mut c_void, index: size_t, val: *const core::Point2d);
		pub fn std_vectorLcv_Point2dG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Point2dG_data_const(instance: *const c_void) -> *const core::Point2d;
		pub fn std_vectorLcv_Point2dG_dataMut(instance: *mut c_void) -> *mut core::Point2d;
		pub fn cv_fromSlice_const_const_Point2dX_size_t(data: *const core::Point2d, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Point2dG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point2dG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point2dG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point2fG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Point2fG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Point2fG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Point2fG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Point2fG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Point2fG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Point2fG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Point2fG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Point2fG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Point2fG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Point2fG_push_const_Point2f(instance: *mut c_void, val: *const core::Point2f);
		pub fn std_vectorLcv_Point2fG_insert_size_t_const_Point2f(instance: *mut c_void, index: size_t, val: *const core::Point2f);
		pub fn std_vectorLcv_Point2fG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Point2f);
		pub fn std_vectorLcv_Point2fG_set_size_t_const_Point2f(instance: *mut c_void, index: size_t, val: *const core::Point2f);
		pub fn std_vectorLcv_Point2fG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Point2fG_data_const(instance: *const c_void) -> *const core::Point2f;
		pub fn std_vectorLcv_Point2fG_dataMut(instance: *mut c_void) -> *mut core::Point2f;
		pub fn cv_fromSlice_const_const_Point2fX_size_t(data: *const core::Point2f, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Point2fG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point2fG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point2fG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point3dG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Point3dG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Point3dG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Point3dG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Point3dG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Point3dG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Point3dG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Point3dG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Point3dG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Point3dG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Point3dG_push_const_Point3d(instance: *mut c_void, val: *const core::Point3d);
		pub fn std_vectorLcv_Point3dG_insert_size_t_const_Point3d(instance: *mut c_void, index: size_t, val: *const core::Point3d);
		pub fn std_vectorLcv_Point3dG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Point3d);
		pub fn std_vectorLcv_Point3dG_set_size_t_const_Point3d(instance: *mut c_void, index: size_t, val: *const core::Point3d);
		pub fn std_vectorLcv_Point3dG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Point3dG_data_const(instance: *const c_void) -> *const core::Point3d;
		pub fn std_vectorLcv_Point3dG_dataMut(instance: *mut c_void) -> *mut core::Point3d;
		pub fn cv_fromSlice_const_const_Point3dX_size_t(data: *const core::Point3d, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Point3dG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point3dG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point3dG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point3fG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Point3fG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Point3fG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Point3fG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Point3fG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Point3fG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Point3fG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Point3fG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Point3fG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Point3fG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Point3fG_push_const_Point3f(instance: *mut c_void, val: *const core::Point3f);
		pub fn std_vectorLcv_Point3fG_insert_size_t_const_Point3f(instance: *mut c_void, index: size_t, val: *const core::Point3f);
		pub fn std_vectorLcv_Point3fG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Point3f);
		pub fn std_vectorLcv_Point3fG_set_size_t_const_Point3f(instance: *mut c_void, index: size_t, val: *const core::Point3f);
		pub fn std_vectorLcv_Point3fG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Point3fG_data_const(instance: *const c_void) -> *const core::Point3f;
		pub fn std_vectorLcv_Point3fG_dataMut(instance: *mut c_void) -> *mut core::Point3f;
		pub fn cv_fromSlice_const_const_Point3fX_size_t(data: *const core::Point3f, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Point3fG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point3fG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point3fG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point3iG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Point3iG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Point3iG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Point3iG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Point3iG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Point3iG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Point3iG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Point3iG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Point3iG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Point3iG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Point3iG_push_const_Point3i(instance: *mut c_void, val: *const core::Point3i);
		pub fn std_vectorLcv_Point3iG_insert_size_t_const_Point3i(instance: *mut c_void, index: size_t, val: *const core::Point3i);
		pub fn std_vectorLcv_Point3iG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Point3i);
		pub fn std_vectorLcv_Point3iG_set_size_t_const_Point3i(instance: *mut c_void, index: size_t, val: *const core::Point3i);
		pub fn std_vectorLcv_Point3iG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Point3iG_data_const(instance: *const c_void) -> *const core::Point3i;
		pub fn std_vectorLcv_Point3iG_dataMut(instance: *mut c_void) -> *mut core::Point3i;
		pub fn cv_fromSlice_const_const_Point3iX_size_t(data: *const core::Point3i, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Point3iG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point3iG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point3iG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_RangeG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_RangeG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_RangeG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_RangeG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_RangeG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_RangeG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_RangeG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_RangeG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_RangeG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_RangeG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_RangeG_push_const_Range(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_RangeG_insert_size_t_const_Range(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_RangeG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_RangeG_set_size_t_const_Range(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_RectG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_RectG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_RectG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_RectG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_RectG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_RectG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_RectG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_RectG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_RectG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_RectG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_RectG_push_const_Rect(instance: *mut c_void, val: *const core::Rect);
		pub fn std_vectorLcv_RectG_insert_size_t_const_Rect(instance: *mut c_void, index: size_t, val: *const core::Rect);
		pub fn std_vectorLcv_RectG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Rect);
		pub fn std_vectorLcv_RectG_set_size_t_const_Rect(instance: *mut c_void, index: size_t, val: *const core::Rect);
		pub fn std_vectorLcv_RectG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_RectG_data_const(instance: *const c_void) -> *const core::Rect;
		pub fn std_vectorLcv_RectG_dataMut(instance: *mut c_void) -> *mut core::Rect;
		pub fn cv_fromSlice_const_const_RectX_size_t(data: *const core::Rect, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_RectG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_RectG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_RectG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Rect2dG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Rect2dG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Rect2dG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Rect2dG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Rect2dG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Rect2dG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Rect2dG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Rect2dG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Rect2dG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Rect2dG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Rect2dG_push_const_Rect2d(instance: *mut c_void, val: *const core::Rect2d);
		pub fn std_vectorLcv_Rect2dG_insert_size_t_const_Rect2d(instance: *mut c_void, index: size_t, val: *const core::Rect2d);
		pub fn std_vectorLcv_Rect2dG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Rect2d);
		pub fn std_vectorLcv_Rect2dG_set_size_t_const_Rect2d(instance: *mut c_void, index: size_t, val: *const core::Rect2d);
		pub fn std_vectorLcv_Rect2dG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Rect2dG_data_const(instance: *const c_void) -> *const core::Rect2d;
		pub fn std_vectorLcv_Rect2dG_dataMut(instance: *mut c_void) -> *mut core::Rect2d;
		pub fn cv_fromSlice_const_const_Rect2dX_size_t(data: *const core::Rect2d, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Rect2dG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Rect2dG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Rect2dG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_RotatedRectG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_RotatedRectG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_RotatedRectG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_RotatedRectG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_RotatedRectG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_RotatedRectG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_RotatedRectG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_RotatedRectG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_RotatedRectG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_RotatedRectG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_RotatedRectG_push_const_RotatedRect(instance: *mut c_void, val: *const core::RotatedRect);
		pub fn std_vectorLcv_RotatedRectG_insert_size_t_const_RotatedRect(instance: *mut c_void, index: size_t, val: *const core::RotatedRect);
		pub fn std_vectorLcv_RotatedRectG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::RotatedRect);
		pub fn std_vectorLcv_RotatedRectG_set_size_t_const_RotatedRect(instance: *mut c_void, index: size_t, val: *const core::RotatedRect);
		pub fn std_vectorLcv_RotatedRectG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_RotatedRectG_data_const(instance: *const c_void) -> *const core::RotatedRect;
		pub fn std_vectorLcv_RotatedRectG_dataMut(instance: *mut c_void) -> *mut core::RotatedRect;
		pub fn cv_fromSlice_const_const_RotatedRectX_size_t(data: *const core::RotatedRect, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_ScalarG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_ScalarG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_ScalarG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_ScalarG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_ScalarG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_ScalarG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_ScalarG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_ScalarG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_ScalarG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_ScalarG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_ScalarG_push_const_Scalar(instance: *mut c_void, val: *const core::Scalar);
		pub fn std_vectorLcv_ScalarG_insert_size_t_const_Scalar(instance: *mut c_void, index: size_t, val: *const core::Scalar);
		pub fn std_vectorLcv_ScalarG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Scalar);
		pub fn std_vectorLcv_ScalarG_set_size_t_const_Scalar(instance: *mut c_void, index: size_t, val: *const core::Scalar);
		pub fn std_vectorLcv_ScalarG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_ScalarG_data_const(instance: *const c_void) -> *const core::Scalar;
		pub fn std_vectorLcv_ScalarG_dataMut(instance: *mut c_void) -> *mut core::Scalar;
		pub fn cv_fromSlice_const_const_ScalarX_size_t(data: *const core::Scalar, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_ScalarG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_ScalarG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_ScalarG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_SizeG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_SizeG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_SizeG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_SizeG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_SizeG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_SizeG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_SizeG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_SizeG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_SizeG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_SizeG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_SizeG_push_const_Size(instance: *mut c_void, val: *const core::Size);
		pub fn std_vectorLcv_SizeG_insert_size_t_const_Size(instance: *mut c_void, index: size_t, val: *const core::Size);
		pub fn std_vectorLcv_SizeG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Size);
		pub fn std_vectorLcv_SizeG_set_size_t_const_Size(instance: *mut c_void, index: size_t, val: *const core::Size);
		pub fn std_vectorLcv_SizeG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_SizeG_data_const(instance: *const c_void) -> *const core::Size;
		pub fn std_vectorLcv_SizeG_dataMut(instance: *mut c_void) -> *mut core::Size;
		pub fn cv_fromSlice_const_const_SizeX_size_t(data: *const core::Size, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_SizeG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_SizeG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_SizeG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_StringG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_StringG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_StringG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_StringG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_StringG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_StringG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_StringG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_StringG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_StringG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_StringG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_StringG_push_const_String(instance: *mut c_void, val: *const c_char);
		pub fn std_vectorLcv_StringG_insert_size_t_const_String(instance: *mut c_void, index: size_t, val: *const c_char);
		pub fn std_vectorLcv_StringG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_StringG_set_size_t_const_String(instance: *mut c_void, index: size_t, val: *const c_char);
		pub fn std_vectorLstd_pairLcv_Point2i__cv_Point2iGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_pairLcv_Point2i__cv_Point2iGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_pairLcv_Point2i__cv_Point2iGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_pairLcv_Point2i__cv_Point2iGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_pairLcv_Point2i__cv_Point2iGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_pairLcv_Point2i__cv_Point2iGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_pairLcv_Point2i__cv_Point2iGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_pairLcv_Point2i__cv_Point2iGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_pairLcv_Point2i__cv_Point2iGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_pairLcv_Point2i__cv_Point2iGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_pairLcv_Point2i__cv_Point2iGG_push_const_pairLcv_Point2i__cv_Point2iG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_pairLcv_Point2i__cv_Point2iGG_insert_size_t_const_pairLcv_Point2i__cv_Point2iG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_pairLcv_Point2i__cv_Point2iGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_pairLcv_Point2i__cv_Point2iGG_set_size_t_const_pairLcv_Point2i__cv_Point2iG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_pairLcv_UMat__unsigned_charGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_pairLcv_UMat__unsigned_charGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_pairLcv_UMat__unsigned_charGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_pairLcv_UMat__unsigned_charGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_pairLcv_UMat__unsigned_charGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_pairLcv_UMat__unsigned_charGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_pairLcv_UMat__unsigned_charGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_pairLcv_UMat__unsigned_charGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_pairLcv_UMat__unsigned_charGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_pairLcv_UMat__unsigned_charGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_pairLcv_UMat__unsigned_charGG_push_const_pairLcv_UMat__unsigned_charG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_pairLcv_UMat__unsigned_charGG_insert_size_t_const_pairLcv_UMat__unsigned_charG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_pairLcv_UMat__unsigned_charGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_pairLcv_UMat__unsigned_charGG_set_size_t_const_pairLcv_UMat__unsigned_charG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_pairLint__doubleGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_pairLint__doubleGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_pairLint__doubleGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_pairLint__doubleGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_pairLint__doubleGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_pairLint__doubleGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_pairLint__doubleGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_pairLint__doubleGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_pairLint__doubleGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_pairLint__doubleGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_pairLint__doubleGG_push_const_pairLint__doubleG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_pairLint__doubleGG_insert_size_t_const_pairLint__doubleG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_pairLint__doubleGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_pairLint__doubleGG_set_size_t_const_pairLint__doubleG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_UMatG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_UMatG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_UMatG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_UMatG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_UMatG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_UMatG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_UMatG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_UMatG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_UMatG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_UMatG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_UMatG_push_const_UMat(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_UMatG_insert_size_t_const_UMat(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_UMatG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_UMatG_set_size_t_const_UMat(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_Vec2dG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Vec2dG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Vec2dG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec2dG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Vec2dG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec2dG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Vec2dG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Vec2dG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Vec2dG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Vec2dG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Vec2dG_push_const_Vec2d(instance: *mut c_void, val: *const core::Vec2d);
		pub fn std_vectorLcv_Vec2dG_insert_size_t_const_Vec2d(instance: *mut c_void, index: size_t, val: *const core::Vec2d);
		pub fn std_vectorLcv_Vec2dG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Vec2d);
		pub fn std_vectorLcv_Vec2dG_set_size_t_const_Vec2d(instance: *mut c_void, index: size_t, val: *const core::Vec2d);
		pub fn std_vectorLcv_Vec2dG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Vec2dG_data_const(instance: *const c_void) -> *const core::Vec2d;
		pub fn std_vectorLcv_Vec2dG_dataMut(instance: *mut c_void) -> *mut core::Vec2d;
		pub fn cv_fromSlice_const_const_Vec2dX_size_t(data: *const core::Vec2d, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Vec2dG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec2dG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec2dG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec2fG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Vec2fG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Vec2fG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec2fG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Vec2fG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec2fG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Vec2fG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Vec2fG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Vec2fG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Vec2fG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Vec2fG_push_const_Vec2f(instance: *mut c_void, val: *const core::Vec2f);
		pub fn std_vectorLcv_Vec2fG_insert_size_t_const_Vec2f(instance: *mut c_void, index: size_t, val: *const core::Vec2f);
		pub fn std_vectorLcv_Vec2fG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Vec2f);
		pub fn std_vectorLcv_Vec2fG_set_size_t_const_Vec2f(instance: *mut c_void, index: size_t, val: *const core::Vec2f);
		pub fn std_vectorLcv_Vec2fG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Vec2fG_data_const(instance: *const c_void) -> *const core::Vec2f;
		pub fn std_vectorLcv_Vec2fG_dataMut(instance: *mut c_void) -> *mut core::Vec2f;
		pub fn cv_fromSlice_const_const_Vec2fX_size_t(data: *const core::Vec2f, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Vec2fG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec2fG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec2fG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec2iG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Vec2iG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Vec2iG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec2iG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Vec2iG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec2iG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Vec2iG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Vec2iG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Vec2iG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Vec2iG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Vec2iG_push_const_Vec2i(instance: *mut c_void, val: *const core::Vec2i);
		pub fn std_vectorLcv_Vec2iG_insert_size_t_const_Vec2i(instance: *mut c_void, index: size_t, val: *const core::Vec2i);
		pub fn std_vectorLcv_Vec2iG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Vec2i);
		pub fn std_vectorLcv_Vec2iG_set_size_t_const_Vec2i(instance: *mut c_void, index: size_t, val: *const core::Vec2i);
		pub fn std_vectorLcv_Vec2iG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Vec2iG_data_const(instance: *const c_void) -> *const core::Vec2i;
		pub fn std_vectorLcv_Vec2iG_dataMut(instance: *mut c_void) -> *mut core::Vec2i;
		pub fn cv_fromSlice_const_const_Vec2iX_size_t(data: *const core::Vec2i, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Vec2iG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec2iG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec2iG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec3dG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Vec3dG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Vec3dG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec3dG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Vec3dG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec3dG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Vec3dG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Vec3dG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Vec3dG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Vec3dG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Vec3dG_push_const_Vec3d(instance: *mut c_void, val: *const core::Vec3d);
		pub fn std_vectorLcv_Vec3dG_insert_size_t_const_Vec3d(instance: *mut c_void, index: size_t, val: *const core::Vec3d);
		pub fn std_vectorLcv_Vec3dG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Vec3d);
		pub fn std_vectorLcv_Vec3dG_set_size_t_const_Vec3d(instance: *mut c_void, index: size_t, val: *const core::Vec3d);
		pub fn std_vectorLcv_Vec3dG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Vec3dG_data_const(instance: *const c_void) -> *const core::Vec3d;
		pub fn std_vectorLcv_Vec3dG_dataMut(instance: *mut c_void) -> *mut core::Vec3d;
		pub fn cv_fromSlice_const_const_Vec3dX_size_t(data: *const core::Vec3d, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Vec3dG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec3dG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec3dG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec3fG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Vec3fG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Vec3fG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec3fG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Vec3fG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec3fG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Vec3fG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Vec3fG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Vec3fG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Vec3fG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Vec3fG_push_const_Vec3f(instance: *mut c_void, val: *const core::Vec3f);
		pub fn std_vectorLcv_Vec3fG_insert_size_t_const_Vec3f(instance: *mut c_void, index: size_t, val: *const core::Vec3f);
		pub fn std_vectorLcv_Vec3fG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Vec3f);
		pub fn std_vectorLcv_Vec3fG_set_size_t_const_Vec3f(instance: *mut c_void, index: size_t, val: *const core::Vec3f);
		pub fn std_vectorLcv_Vec3fG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Vec3fG_data_const(instance: *const c_void) -> *const core::Vec3f;
		pub fn std_vectorLcv_Vec3fG_dataMut(instance: *mut c_void) -> *mut core::Vec3f;
		pub fn cv_fromSlice_const_const_Vec3fX_size_t(data: *const core::Vec3f, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Vec3fG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec3fG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec3fG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec3iG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Vec3iG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Vec3iG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec3iG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Vec3iG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec3iG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Vec3iG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Vec3iG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Vec3iG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Vec3iG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Vec3iG_push_const_Vec3i(instance: *mut c_void, val: *const core::Vec3i);
		pub fn std_vectorLcv_Vec3iG_insert_size_t_const_Vec3i(instance: *mut c_void, index: size_t, val: *const core::Vec3i);
		pub fn std_vectorLcv_Vec3iG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Vec3i);
		pub fn std_vectorLcv_Vec3iG_set_size_t_const_Vec3i(instance: *mut c_void, index: size_t, val: *const core::Vec3i);
		pub fn std_vectorLcv_Vec3iG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Vec3iG_data_const(instance: *const c_void) -> *const core::Vec3i;
		pub fn std_vectorLcv_Vec3iG_dataMut(instance: *mut c_void) -> *mut core::Vec3i;
		pub fn cv_fromSlice_const_const_Vec3iX_size_t(data: *const core::Vec3i, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Vec3iG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec3iG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec3iG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec4fG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Vec4fG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Vec4fG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec4fG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Vec4fG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec4fG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Vec4fG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Vec4fG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Vec4fG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Vec4fG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Vec4fG_push_const_Vec4f(instance: *mut c_void, val: *const core::Vec4f);
		pub fn std_vectorLcv_Vec4fG_insert_size_t_const_Vec4f(instance: *mut c_void, index: size_t, val: *const core::Vec4f);
		pub fn std_vectorLcv_Vec4fG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Vec4f);
		pub fn std_vectorLcv_Vec4fG_set_size_t_const_Vec4f(instance: *mut c_void, index: size_t, val: *const core::Vec4f);
		pub fn std_vectorLcv_Vec4fG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Vec4fG_data_const(instance: *const c_void) -> *const core::Vec4f;
		pub fn std_vectorLcv_Vec4fG_dataMut(instance: *mut c_void) -> *mut core::Vec4f;
		pub fn cv_fromSlice_const_const_Vec4fX_size_t(data: *const core::Vec4f, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Vec4fG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec4fG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec4fG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec4iG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Vec4iG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Vec4iG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec4iG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Vec4iG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec4iG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Vec4iG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Vec4iG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Vec4iG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Vec4iG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Vec4iG_push_const_Vec4i(instance: *mut c_void, val: *const core::Vec4i);
		pub fn std_vectorLcv_Vec4iG_insert_size_t_const_Vec4i(instance: *mut c_void, index: size_t, val: *const core::Vec4i);
		pub fn std_vectorLcv_Vec4iG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Vec4i);
		pub fn std_vectorLcv_Vec4iG_set_size_t_const_Vec4i(instance: *mut c_void, index: size_t, val: *const core::Vec4i);
		pub fn std_vectorLcv_Vec4iG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Vec4iG_data_const(instance: *const c_void) -> *const core::Vec4i;
		pub fn std_vectorLcv_Vec4iG_dataMut(instance: *mut c_void) -> *mut core::Vec4i;
		pub fn cv_fromSlice_const_const_Vec4iX_size_t(data: *const core::Vec4i, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Vec4iG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec4iG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec4iG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec6fG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Vec6fG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Vec6fG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec6fG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Vec6fG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec6fG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Vec6fG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Vec6fG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Vec6fG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Vec6fG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Vec6fG_push_const_Vec6f(instance: *mut c_void, val: *const core::Vec6f);
		pub fn std_vectorLcv_Vec6fG_insert_size_t_const_Vec6f(instance: *mut c_void, index: size_t, val: *const core::Vec6f);
		pub fn std_vectorLcv_Vec6fG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Vec6f);
		pub fn std_vectorLcv_Vec6fG_set_size_t_const_Vec6f(instance: *mut c_void, index: size_t, val: *const core::Vec6f);
		pub fn std_vectorLcv_Vec6fG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Vec6fG_data_const(instance: *const c_void) -> *const core::Vec6f;
		pub fn std_vectorLcv_Vec6fG_dataMut(instance: *mut c_void) -> *mut core::Vec6f;
		pub fn cv_fromSlice_const_const_Vec6fX_size_t(data: *const core::Vec6f, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Vec6fG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec6fG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec6fG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_DMatchGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLcv_DMatchGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_DMatchGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_DMatchGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLcv_DMatchGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_DMatchGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_DMatchGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLcv_DMatchGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLcv_DMatchGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLcv_DMatchGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_DMatchGG_push_const_vectorLDMatchG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_DMatchGG_insert_size_t_const_vectorLDMatchG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_DMatchGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLcv_DMatchGG_set_size_t_const_vectorLDMatchG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_KeyPointGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLcv_KeyPointGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_KeyPointGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_KeyPointGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLcv_KeyPointGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_KeyPointGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_KeyPointGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLcv_KeyPointGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLcv_KeyPointGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLcv_KeyPointGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_KeyPointGG_push_const_vectorLKeyPointG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_KeyPointGG_insert_size_t_const_vectorLKeyPointG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_KeyPointGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLcv_KeyPointGG_set_size_t_const_vectorLKeyPointG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_MatGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLcv_MatGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_MatGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_MatGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLcv_MatGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_MatGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_MatGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLcv_MatGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLcv_MatGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLcv_MatGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_MatGG_push_const_vectorLMatG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_MatGG_insert_size_t_const_vectorLMatG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_MatGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLcv_MatGG_set_size_t_const_vectorLMatG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_PointGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLcv_PointGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_PointGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_PointGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLcv_PointGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_PointGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_PointGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLcv_PointGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLcv_PointGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLcv_PointGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_PointGG_push_const_vectorLPointG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_PointGG_insert_size_t_const_vectorLPointG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_PointGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLcv_PointGG_set_size_t_const_vectorLPointG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_PointGG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_PointGG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_PointGG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLcv_Point2fGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_Point2fGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLcv_Point2fGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_Point2fGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_push_const_vectorLPoint2fG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_insert_size_t_const_vectorLPoint2fG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_set_size_t_const_vectorLPoint2fG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Point3dGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLcv_Point3dGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point3dGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_Point3dGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLcv_Point3dGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_Point3dGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point3dGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLcv_Point3dGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLcv_Point3dGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLcv_Point3dGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point3dGG_push_const_vectorLPoint3dG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Point3dGG_insert_size_t_const_vectorLPoint3dG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Point3dGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point3dGG_set_size_t_const_vectorLPoint3dG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Point3dGG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Point3dGG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Point3dGG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLcv_Point3fGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_Point3fGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLcv_Point3fGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_Point3fGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_push_const_vectorLPoint3fG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_insert_size_t_const_vectorLPoint3fG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_set_size_t_const_vectorLPoint3fG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Point3iGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLcv_Point3iGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point3iGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_Point3iGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLcv_Point3iGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_Point3iGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point3iGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLcv_Point3iGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLcv_Point3iGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLcv_Point3iGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point3iGG_push_const_vectorLPoint3iG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Point3iGG_insert_size_t_const_vectorLPoint3iG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Point3iGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point3iGG_set_size_t_const_vectorLPoint3iG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Point3iGG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Point3iGG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Point3iGG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_RangeGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLcv_RangeGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_RangeGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_RangeGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLcv_RangeGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_RangeGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_RangeGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLcv_RangeGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLcv_RangeGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLcv_RangeGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_RangeGG_push_const_vectorLRangeG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_RangeGG_insert_size_t_const_vectorLRangeG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_RangeGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLcv_RangeGG_set_size_t_const_vectorLRangeG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Vec2iGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLcv_Vec2iGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Vec2iGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_Vec2iGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLcv_Vec2iGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_Vec2iGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Vec2iGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLcv_Vec2iGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLcv_Vec2iGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLcv_Vec2iGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Vec2iGG_push_const_vectorLVec2iG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Vec2iGG_insert_size_t_const_vectorLVec2iG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Vec2iGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Vec2iGG_set_size_t_const_vectorLVec2iG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Vec2iGG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Vec2iGG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Vec2iGG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Vec3fGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLcv_Vec3fGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Vec3fGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_Vec3fGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLcv_Vec3fGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_Vec3fGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Vec3fGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLcv_Vec3fGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLcv_Vec3fGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLcv_Vec3fGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Vec3fGG_push_const_vectorLVec3fG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Vec3fGG_insert_size_t_const_vectorLVec3fG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Vec3fGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Vec3fGG_set_size_t_const_vectorLVec3fG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Vec3fGG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Vec3fGG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Vec3fGG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLfloatGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLfloatGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLfloatGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLfloatGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLfloatGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLfloatGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLfloatGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLfloatGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLfloatGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLfloatGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLfloatGG_push_const_vectorLfloatG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLfloatGG_insert_size_t_const_vectorLfloatG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLfloatGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLfloatGG_set_size_t_const_vectorLfloatG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLfloatGG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLfloatGG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLfloatGG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLdoubleGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLdoubleGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLdoubleGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLdoubleGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLdoubleGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLdoubleGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLdoubleGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLdoubleGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLdoubleGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLdoubleGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLdoubleGG_push_const_vectorLdoubleG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLdoubleGG_insert_size_t_const_vectorLdoubleG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLdoubleGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLdoubleGG_set_size_t_const_vectorLdoubleG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLdoubleGG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLdoubleGG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLdoubleGG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLintGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLintGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLintGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLintGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLintGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLintGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLintGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLintGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLintGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLintGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLintGG_push_const_vectorLintG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLintGG_insert_size_t_const_vectorLintG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLintGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLintGG_set_size_t_const_vectorLintG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLintGG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLintGG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLintGG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLsigned_charGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLsigned_charGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLsigned_charGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLsigned_charGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLsigned_charGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLsigned_charGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLsigned_charGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLsigned_charGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLsigned_charGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLsigned_charGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLsigned_charGG_push_const_vectorLsigned_charG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLsigned_charGG_insert_size_t_const_vectorLsigned_charG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLsigned_charGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLsigned_charGG_set_size_t_const_vectorLsigned_charG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLuint8_tGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLuint8_tGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLuint8_tGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLuint8_tGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLuint8_tGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLuint8_tGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLuint8_tGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLuint8_tGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLuint8_tGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLuint8_tGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLuint8_tGG_push_const_vectorLuint8_tG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLuint8_tGG_insert_size_t_const_vectorLuint8_tG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLuint8_tGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLuint8_tGG_set_size_t_const_vectorLuint8_tG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLuint8_tGG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLuint8_tGG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLuint8_tGG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLboolG_new_const() -> *mut c_void;
		pub fn std_vectorLboolG_delete(instance: *mut c_void);
		pub fn std_vectorLboolG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLboolG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLboolG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLboolG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLboolG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLboolG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLboolG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLboolG_clear(instance: *mut c_void);
		pub fn std_vectorLboolG_push_const_bool(instance: *mut c_void, val: bool);
		pub fn std_vectorLboolG_insert_size_t_const_bool(instance: *mut c_void, index: size_t, val: bool);
		pub fn std_vectorLboolG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut bool);
		pub fn std_vectorLboolG_set_size_t_const_bool(instance: *mut c_void, index: size_t, val: bool);
		pub fn std_vectorLfloatG_new_const() -> *mut c_void;
		pub fn std_vectorLfloatG_delete(instance: *mut c_void);
		pub fn std_vectorLfloatG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLfloatG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLfloatG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLfloatG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLfloatG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLfloatG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLfloatG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLfloatG_clear(instance: *mut c_void);
		pub fn std_vectorLfloatG_push_const_float(instance: *mut c_void, val: f32);
		pub fn std_vectorLfloatG_insert_size_t_const_float(instance: *mut c_void, index: size_t, val: f32);
		pub fn std_vectorLfloatG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut f32);
		pub fn std_vectorLfloatG_set_size_t_const_float(instance: *mut c_void, index: size_t, val: f32);
		pub fn std_vectorLfloatG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLfloatG_data_const(instance: *const c_void) -> *const f32;
		pub fn std_vectorLfloatG_dataMut(instance: *mut c_void) -> *mut f32;
		pub fn cv_fromSlice_const_const_floatX_size_t(data: *const f32, len: size_t) -> *mut c_void;
		pub fn std_vectorLfloatG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLfloatG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLfloatG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLdoubleG_new_const() -> *mut c_void;
		pub fn std_vectorLdoubleG_delete(instance: *mut c_void);
		pub fn std_vectorLdoubleG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLdoubleG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLdoubleG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLdoubleG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLdoubleG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLdoubleG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLdoubleG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLdoubleG_clear(instance: *mut c_void);
		pub fn std_vectorLdoubleG_push_const_double(instance: *mut c_void, val: f64);
		pub fn std_vectorLdoubleG_insert_size_t_const_double(instance: *mut c_void, index: size_t, val: f64);
		pub fn std_vectorLdoubleG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut f64);
		pub fn std_vectorLdoubleG_set_size_t_const_double(instance: *mut c_void, index: size_t, val: f64);
		pub fn std_vectorLdoubleG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLdoubleG_data_const(instance: *const c_void) -> *const f64;
		pub fn std_vectorLdoubleG_dataMut(instance: *mut c_void) -> *mut f64;
		pub fn cv_fromSlice_const_const_doubleX_size_t(data: *const f64, len: size_t) -> *mut c_void;
		pub fn std_vectorLdoubleG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLdoubleG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLdoubleG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLintG_new_const() -> *mut c_void;
		pub fn std_vectorLintG_delete(instance: *mut c_void);
		pub fn std_vectorLintG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLintG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLintG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLintG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLintG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLintG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLintG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLintG_clear(instance: *mut c_void);
		pub fn std_vectorLintG_push_const_int(instance: *mut c_void, val: i32);
		pub fn std_vectorLintG_insert_size_t_const_int(instance: *mut c_void, index: size_t, val: i32);
		pub fn std_vectorLintG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut i32);
		pub fn std_vectorLintG_set_size_t_const_int(instance: *mut c_void, index: size_t, val: i32);
		pub fn std_vectorLintG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLintG_data_const(instance: *const c_void) -> *const i32;
		pub fn std_vectorLintG_dataMut(instance: *mut c_void) -> *mut i32;
		pub fn cv_fromSlice_const_const_intX_size_t(data: *const i32, len: size_t) -> *mut c_void;
		pub fn std_vectorLintG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLintG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLintG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLsigned_charG_new_const() -> *mut c_void;
		pub fn std_vectorLsigned_charG_delete(instance: *mut c_void);
		pub fn std_vectorLsigned_charG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLsigned_charG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLsigned_charG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLsigned_charG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLsigned_charG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLsigned_charG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLsigned_charG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLsigned_charG_clear(instance: *mut c_void);
		pub fn std_vectorLsigned_charG_push_const_signed_char(instance: *mut c_void, val: i8);
		pub fn std_vectorLsigned_charG_insert_size_t_const_signed_char(instance: *mut c_void, index: size_t, val: i8);
		pub fn std_vectorLsigned_charG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut i8);
		pub fn std_vectorLsigned_charG_set_size_t_const_signed_char(instance: *mut c_void, index: size_t, val: i8);
		pub fn std_vectorLsigned_charG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLsigned_charG_data_const(instance: *const c_void) -> *const i8;
		pub fn std_vectorLsigned_charG_dataMut(instance: *mut c_void) -> *mut i8;
		pub fn cv_fromSlice_const_const_signed_charX_size_t(data: *const i8, len: size_t) -> *mut c_void;
		pub fn std_vectorLsize_tG_new_const() -> *mut c_void;
		pub fn std_vectorLsize_tG_delete(instance: *mut c_void);
		pub fn std_vectorLsize_tG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLsize_tG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLsize_tG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLsize_tG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLsize_tG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLsize_tG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLsize_tG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLsize_tG_clear(instance: *mut c_void);
		pub fn std_vectorLsize_tG_push_const_size_t(instance: *mut c_void, val: size_t);
		pub fn std_vectorLsize_tG_insert_size_t_const_size_t(instance: *mut c_void, index: size_t, val: size_t);
		pub fn std_vectorLsize_tG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut size_t);
		pub fn std_vectorLsize_tG_set_size_t_const_size_t(instance: *mut c_void, index: size_t, val: size_t);
		pub fn std_vectorLsize_tG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLsize_tG_data_const(instance: *const c_void) -> *const size_t;
		pub fn std_vectorLsize_tG_dataMut(instance: *mut c_void) -> *mut size_t;
		pub fn cv_fromSlice_const_const_size_tX_size_t(data: *const size_t, len: size_t) -> *mut c_void;
		pub fn std_vectorLuint8_tG_new_const() -> *mut c_void;
		pub fn std_vectorLuint8_tG_delete(instance: *mut c_void);
		pub fn std_vectorLuint8_tG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLuint8_tG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLuint8_tG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLuint8_tG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLuint8_tG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLuint8_tG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLuint8_tG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLuint8_tG_clear(instance: *mut c_void);
		pub fn std_vectorLuint8_tG_push_const_uint8_t(instance: *mut c_void, val: u8);
		pub fn std_vectorLuint8_tG_insert_size_t_const_uint8_t(instance: *mut c_void, index: size_t, val: u8);
		pub fn std_vectorLuint8_tG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut u8);
		pub fn std_vectorLuint8_tG_set_size_t_const_uint8_t(instance: *mut c_void, index: size_t, val: u8);
		pub fn std_vectorLuint8_tG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLuint8_tG_data_const(instance: *const c_void) -> *const u8;
		pub fn std_vectorLuint8_tG_dataMut(instance: *mut c_void) -> *mut u8;
		pub fn cv_fromSlice_const_const_uint8_tX_size_t(data: *const u8, len: size_t) -> *mut c_void;
		pub fn std_vectorLuint8_tG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLuint8_tG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLuint8_tG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
	}
}
#[cfg(ocvrs_has_module_core)]
pub use core_sys::*;

#[cfg(ocvrs_has_module_cudaarithm)]
mod cudaarithm_sys {
	use super::*;

	extern "C" {
		pub fn cv_cuda_absSum_const__InputArrayR(src: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_cuda_absSum_const__InputArrayR_const__InputArrayR(src: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_cuda_abs_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_abs_const__InputArrayR_const__OutputArrayR_StreamR(src: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_absdiff_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_absdiff_const__InputArrayR_const__InputArrayR_const__OutputArrayR_StreamR(src1: *const c_void, src2: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_addWeighted_const__InputArrayR_double_const__InputArrayR_double_double_const__OutputArrayR(src1: *const c_void, alpha: f64, src2: *const c_void, beta: f64, gamma: f64, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_addWeighted_const__InputArrayR_double_const__InputArrayR_double_double_const__OutputArrayR_int_StreamR(src1: *const c_void, alpha: f64, src2: *const c_void, beta: f64, gamma: f64, dst: *const c_void, dtype: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_add_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_add_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR_int_StreamR(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, dtype: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_bitwise_and_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_bitwise_and_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR_StreamR(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_bitwise_not_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_bitwise_not_const__InputArrayR_const__OutputArrayR_const__InputArrayR_StreamR(src: *const c_void, dst: *const c_void, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_bitwise_or_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_bitwise_or_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR_StreamR(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_bitwise_xor_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_bitwise_xor_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR_StreamR(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_calcAbsSum_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_calcAbsSum_const__InputArrayR_const__OutputArrayR_const__InputArrayR_StreamR(src: *const c_void, dst: *const c_void, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_calcNormDiff_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_calcNormDiff_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_StreamR(src1: *const c_void, src2: *const c_void, dst: *const c_void, norm_type: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_calcNorm_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, norm_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_calcNorm_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR_StreamR(src: *const c_void, dst: *const c_void, norm_type: i32, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_calcSqrSum_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_calcSqrSum_const__InputArrayR_const__OutputArrayR_const__InputArrayR_StreamR(src: *const c_void, dst: *const c_void, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_calcSum_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_calcSum_const__InputArrayR_const__OutputArrayR_const__InputArrayR_StreamR(src: *const c_void, dst: *const c_void, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_cartToPolar_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(x: *const c_void, y: *const c_void, magnitude: *const c_void, angle: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_cartToPolar_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_bool_StreamR(x: *const c_void, y: *const c_void, magnitude: *const c_void, angle: *const c_void, angle_in_degrees: bool, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_compare_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, cmpop: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_compare_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_StreamR(src1: *const c_void, src2: *const c_void, dst: *const c_void, cmpop: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_copyMakeBorder_const__InputArrayR_const__OutputArrayR_int_int_int_int_int(src: *const c_void, dst: *const c_void, top: i32, bottom: i32, left: i32, right: i32, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_copyMakeBorder_const__InputArrayR_const__OutputArrayR_int_int_int_int_int_Scalar_StreamR(src: *const c_void, dst: *const c_void, top: i32, bottom: i32, left: i32, right: i32, border_type: i32, value: *const core::Scalar, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_countNonZero_const__InputArrayR(src: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_countNonZero_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_countNonZero_const__InputArrayR_const__OutputArrayR_StreamR(src: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_createConvolution(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createConvolution_Size(user_block_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createDFT_Size_int(dft_size: *const core::Size, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createLookUpTable_const__InputArrayR(lut: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_dft_const__InputArrayR_const__OutputArrayR_Size(src: *const c_void, dst: *const c_void, dft_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_dft_const__InputArrayR_const__OutputArrayR_Size_int_StreamR(src: *const c_void, dst: *const c_void, dft_size: *const core::Size, flags: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_divide_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_divide_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_int_StreamR(src1: *const c_void, src2: *const c_void, dst: *const c_void, scale: f64, dtype: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_exp_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_exp_const__InputArrayR_const__OutputArrayR_StreamR(src: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_findMinMaxLoc_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, min_max_vals: *const c_void, loc: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_findMinMaxLoc_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__InputArrayR_StreamR(src: *const c_void, min_max_vals: *const c_void, loc: *const c_void, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_findMinMax_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_findMinMax_const__InputArrayR_const__OutputArrayR_const__InputArrayR_StreamR(src: *const c_void, dst: *const c_void, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_flip_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flip_code: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_flip_const__InputArrayR_const__OutputArrayR_int_StreamR(src: *const c_void, dst: *const c_void, flip_code: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_gemm_const__InputArrayR_const__InputArrayR_double_const__InputArrayR_double_const__OutputArrayR(src1: *const c_void, src2: *const c_void, alpha: f64, src3: *const c_void, beta: f64, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_gemm_const__InputArrayR_const__InputArrayR_double_const__InputArrayR_double_const__OutputArrayR_int_StreamR(src1: *const c_void, src2: *const c_void, alpha: f64, src3: *const c_void, beta: f64, dst: *const c_void, flags: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_inRange_const__InputArrayR_const_ScalarR_const_ScalarR_const__OutputArrayR(src: *const c_void, lowerb: *const core::Scalar, upperb: *const core::Scalar, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_inRange_const__InputArrayR_const_ScalarR_const_ScalarR_const__OutputArrayR_StreamR(src: *const c_void, lowerb: *const core::Scalar, upperb: *const core::Scalar, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_integral_const__InputArrayR_const__OutputArrayR(src: *const c_void, sum: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_integral_const__InputArrayR_const__OutputArrayR_StreamR(src: *const c_void, sum: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_log_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_log_const__InputArrayR_const__OutputArrayR_StreamR(src: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_lshift_const__InputArrayR_Scalar_LintG_const__OutputArrayR(src: *const c_void, val: *const core::Scalar_<i32>, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_lshift_const__InputArrayR_Scalar_LintG_const__OutputArrayR_StreamR(src: *const c_void, val: *const core::Scalar_<i32>, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_lshift_const__InputArrayR_Scalar_const__OutputArrayR(src: *const c_void, val: *const core::Scalar, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_lshift_const__InputArrayR_Scalar_const__OutputArrayR_StreamR(src: *const c_void, val: *const core::Scalar, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_magnitudeSqr_const__InputArrayR_const__InputArrayR_const__OutputArrayR(x: *const c_void, y: *const c_void, magnitude: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_magnitudeSqr_const__InputArrayR_const__InputArrayR_const__OutputArrayR_StreamR(x: *const c_void, y: *const c_void, magnitude: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_magnitudeSqr_const__InputArrayR_const__OutputArrayR(xy: *const c_void, magnitude: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_magnitudeSqr_const__InputArrayR_const__OutputArrayR_StreamR(xy: *const c_void, magnitude: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_magnitude_const__InputArrayR_const__InputArrayR_const__OutputArrayR(x: *const c_void, y: *const c_void, magnitude: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_magnitude_const__InputArrayR_const__InputArrayR_const__OutputArrayR_StreamR(x: *const c_void, y: *const c_void, magnitude: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_magnitude_const__InputArrayR_const__OutputArrayR(xy: *const c_void, magnitude: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_magnitude_const__InputArrayR_const__OutputArrayR_StreamR(xy: *const c_void, magnitude: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_max_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_max_const__InputArrayR_const__InputArrayR_const__OutputArrayR_StreamR(src1: *const c_void, src2: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_meanStdDev_const__InputArrayR_ScalarR_ScalarR(mtx: *const c_void, mean: *mut core::Scalar, stddev: *mut core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_meanStdDev_const__InputArrayR_ScalarR_ScalarR_const__InputArrayR(src: *const c_void, mean: *mut core::Scalar, stddev: *mut core::Scalar, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_meanStdDev_const__InputArrayR_const__OutputArrayR(mtx: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_meanStdDev_const__InputArrayR_const__OutputArrayR_StreamR(mtx: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_meanStdDev_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_meanStdDev_const__InputArrayR_const__OutputArrayR_const__InputArrayR_StreamR(src: *const c_void, dst: *const c_void, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_merge_const_GpuMatX_size_t_const__OutputArrayR(src: *const c_void, n: size_t, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_merge_const_GpuMatX_size_t_const__OutputArrayR_StreamR(src: *const c_void, n: size_t, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_merge_const_vectorLGpuMatGR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_merge_const_vectorLGpuMatGR_const__OutputArrayR_StreamR(src: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_minMaxLoc_const__InputArrayR_doubleX_doubleX_PointX_PointX(src: *const c_void, min_val: *mut f64, max_val: *mut f64, min_loc: *mut core::Point, max_loc: *mut core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_minMaxLoc_const__InputArrayR_doubleX_doubleX_PointX_PointX_const__InputArrayR(src: *const c_void, min_val: *mut f64, max_val: *mut f64, min_loc: *mut core::Point, max_loc: *mut core::Point, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_minMax_const__InputArrayR_doubleX_doubleX(src: *const c_void, min_val: *mut f64, max_val: *mut f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_minMax_const__InputArrayR_doubleX_doubleX_const__InputArrayR(src: *const c_void, min_val: *mut f64, max_val: *mut f64, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_min_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_min_const__InputArrayR_const__InputArrayR_const__OutputArrayR_StreamR(src1: *const c_void, src2: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_mulAndScaleSpectrums_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_float(src1: *const c_void, src2: *const c_void, dst: *const c_void, flags: i32, scale: f32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_mulAndScaleSpectrums_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_float_bool_StreamR(src1: *const c_void, src2: *const c_void, dst: *const c_void, flags: i32, scale: f32, conj_b: bool, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_mulSpectrums_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_mulSpectrums_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_bool_StreamR(src1: *const c_void, src2: *const c_void, dst: *const c_void, flags: i32, conj_b: bool, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_multiply_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_multiply_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_int_StreamR(src1: *const c_void, src2: *const c_void, dst: *const c_void, scale: f64, dtype: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_norm_const__InputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_norm_const__InputArrayR_const__InputArrayR_int(src1: *const c_void, src2: *const c_void, norm_type: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_norm_const__InputArrayR_int(src1: *const c_void, norm_type: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_norm_const__InputArrayR_int_const__InputArrayR(src1: *const c_void, norm_type: i32, mask: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_normalize_const__InputArrayR_const__OutputArrayR_double_double_int_int(src: *const c_void, dst: *const c_void, alpha: f64, beta: f64, norm_type: i32, dtype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_normalize_const__InputArrayR_const__OutputArrayR_double_double_int_int_const__InputArrayR_StreamR(src: *const c_void, dst: *const c_void, alpha: f64, beta: f64, norm_type: i32, dtype: i32, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_phase_const__InputArrayR_const__InputArrayR_const__OutputArrayR(x: *const c_void, y: *const c_void, angle: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_phase_const__InputArrayR_const__InputArrayR_const__OutputArrayR_bool_StreamR(x: *const c_void, y: *const c_void, angle: *const c_void, angle_in_degrees: bool, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_polarToCart_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(magnitude: *const c_void, angle: *const c_void, x: *const c_void, y: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_polarToCart_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_bool_StreamR(magnitude: *const c_void, angle: *const c_void, x: *const c_void, y: *const c_void, angle_in_degrees: bool, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_pow_const__InputArrayR_double_const__OutputArrayR(src: *const c_void, power: f64, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_pow_const__InputArrayR_double_const__OutputArrayR_StreamR(src: *const c_void, power: f64, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_rectStdDev_const__InputArrayR_const__InputArrayR_const__OutputArrayR_Rect(src: *const c_void, sqr: *const c_void, dst: *const c_void, rect: *const core::Rect, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_rectStdDev_const__InputArrayR_const__InputArrayR_const__OutputArrayR_Rect_StreamR(src: *const c_void, sqr: *const c_void, dst: *const c_void, rect: *const core::Rect, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_reduce_const__InputArrayR_const__OutputArrayR_int_int(mtx: *const c_void, vec: *const c_void, dim: i32, reduce_op: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_reduce_const__InputArrayR_const__OutputArrayR_int_int_int_StreamR(mtx: *const c_void, vec: *const c_void, dim: i32, reduce_op: i32, dtype: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_rshift_const__InputArrayR_Scalar_LintG_const__OutputArrayR(src: *const c_void, val: *const core::Scalar_<i32>, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_rshift_const__InputArrayR_Scalar_LintG_const__OutputArrayR_StreamR(src: *const c_void, val: *const core::Scalar_<i32>, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_rshift_const__InputArrayR_Scalar_const__OutputArrayR(src: *const c_void, val: *const core::Scalar, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_rshift_const__InputArrayR_Scalar_const__OutputArrayR_StreamR(src: *const c_void, val: *const core::Scalar, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_split_const__InputArrayR_GpuMatX(src: *const c_void, dst: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_split_const__InputArrayR_GpuMatX_StreamR(src: *const c_void, dst: *mut c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_split_const__InputArrayR_vectorLGpuMatGR(src: *const c_void, dst: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_split_const__InputArrayR_vectorLGpuMatGR_StreamR(src: *const c_void, dst: *mut c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_sqrIntegral_const__InputArrayR_const__OutputArrayR(src: *const c_void, sqsum: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_sqrIntegral_const__InputArrayR_const__OutputArrayR_StreamR(src: *const c_void, sqsum: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_sqrSum_const__InputArrayR(src: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_cuda_sqrSum_const__InputArrayR_const__InputArrayR(src: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_cuda_sqr_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_sqr_const__InputArrayR_const__OutputArrayR_StreamR(src: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_sqrt_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_sqrt_const__InputArrayR_const__OutputArrayR_StreamR(src: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_subtract_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_subtract_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR_int_StreamR(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, dtype: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_sum_const__InputArrayR(src: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_cuda_sum_const__InputArrayR_const__InputArrayR(src: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_cuda_threshold_const__InputArrayR_const__OutputArrayR_double_double_int(src: *const c_void, dst: *const c_void, thresh: f64, maxval: f64, typ: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_threshold_const__InputArrayR_const__OutputArrayR_double_double_int_StreamR(src: *const c_void, dst: *const c_void, thresh: f64, maxval: f64, typ: i32, stream: *mut c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_transpose_const__InputArrayR_const__OutputArrayR(src1: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_transpose_const__InputArrayR_const__OutputArrayR_StreamR(src1: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Convolution_convolve_const__InputArrayR_const__InputArrayR_const__OutputArrayR_bool_StreamR(instance: *mut c_void, image: *const c_void, templ: *const c_void, result: *const c_void, ccorr: bool, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Convolution_convolve_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, templ: *const c_void, result: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Convolution_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_Convolution_delete(instance: *mut c_void);
		pub fn cv_cuda_DFT_compute_const__InputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, image: *const c_void, result: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DFT_compute_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, result: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DFT_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_DFT_delete(instance: *mut c_void);
		pub fn cv_cuda_LookUpTable_transform_const__InputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, src: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_LookUpTable_transform_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_LookUpTable_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_LookUpTable_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_ConvolutionG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_ConvolutionG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_ConvolutionG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_ConvolutionG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_DFTG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_DFTG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_DFTG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_DFTG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_LookUpTableG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_LookUpTableG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_LookUpTableG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_LookUpTableG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_cudaarithm)]
pub use cudaarithm_sys::*;

#[cfg(ocvrs_has_module_cudabgsegm)]
mod cudabgsegm_sys {
	use super::*;

	extern "C" {
		pub fn cv_cuda_createBackgroundSubtractorMOG(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createBackgroundSubtractorMOG2(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createBackgroundSubtractorMOG2_int_double_bool(history: i32, var_threshold: f64, detect_shadows: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createBackgroundSubtractorMOG_int_int_double_double(history: i32, nmixtures: i32, background_ratio: f64, noise_sigma: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_BackgroundSubtractorMOG_apply_const__InputArrayR_const__OutputArrayR_double_StreamR(instance: *mut c_void, image: *const c_void, fgmask: *const c_void, learning_rate: f64, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_BackgroundSubtractorMOG_getBackgroundImage_const_const__OutputArrayR_StreamR(instance: *const c_void, background_image: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_BackgroundSubtractorMOG_getBackgroundImage_GpuMatR_StreamR(instance: *mut c_void, background_image: *mut c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_BackgroundSubtractorMOG_getHistory_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_BackgroundSubtractorMOG_setHistory_int(instance: *mut c_void, nframes: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_BackgroundSubtractorMOG_getNMixtures_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_BackgroundSubtractorMOG_setNMixtures_int(instance: *mut c_void, nmix: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_BackgroundSubtractorMOG_getBackgroundRatio_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_BackgroundSubtractorMOG_setBackgroundRatio_double(instance: *mut c_void, background_ratio: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_BackgroundSubtractorMOG_getNoiseSigma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_BackgroundSubtractorMOG_setNoiseSigma_double(instance: *mut c_void, noise_sigma: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_BackgroundSubtractorMOG_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_BackgroundSubtractorMOG_to_BackgroundSubtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_BackgroundSubtractorMOG_delete(instance: *mut c_void);
		pub fn cv_cuda_BackgroundSubtractorMOG2_apply_const__InputArrayR_const__OutputArrayR_double_StreamR(instance: *mut c_void, image: *const c_void, fgmask: *const c_void, learning_rate: f64, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_BackgroundSubtractorMOG2_getBackgroundImage_const_const__OutputArrayR_StreamR(instance: *const c_void, background_image: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_BackgroundSubtractorMOG2_getBackgroundImage_GpuMatR_StreamR(instance: *mut c_void, background_image: *mut c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_BackgroundSubtractorMOG2_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_BackgroundSubtractorMOG2_to_BackgroundSubtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_BackgroundSubtractorMOG2_to_BackgroundSubtractorMOG2(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_BackgroundSubtractorMOG2_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_BackgroundSubtractorMOGG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_BackgroundSubtractorMOGG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_BackgroundSubtractorMOGG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_BackgroundSubtractorMOGG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_BackgroundSubtractorMOGG_to_PtrOfBackgroundSubtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_BackgroundSubtractorMOG2G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_BackgroundSubtractorMOG2G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_BackgroundSubtractorMOG2G_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_BackgroundSubtractorMOG2G_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_BackgroundSubtractorMOG2G_to_PtrOfBackgroundSubtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_BackgroundSubtractorMOG2G_to_PtrOfBackgroundSubtractorMOG2(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_cudabgsegm)]
pub use cudabgsegm_sys::*;

#[cfg(ocvrs_has_module_cudacodec)]
mod cudacodec_sys {
	use super::*;

	extern "C" {
		pub fn cv_cudacodec_createVideoReader_const_PtrLRawVideoSourceGR(source: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cudacodec_createVideoReader_const_PtrLRawVideoSourceGR_const_VideoReaderInitParams(source: *const c_void, params: *const crate::cudacodec::CUDA_VideoReaderInitParams, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cudacodec_createVideoReader_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cudacodec_createVideoReader_const_StringR_const_vectorLintGR_const_VideoReaderInitParams(filename: *const c_char, source_params: *const c_void, params: *const crate::cudacodec::CUDA_VideoReaderInitParams, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cudacodec_createVideoWriter_const_StringR_const_Size(file_name: *const c_char, frame_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cudacodec_createVideoWriter_const_StringR_const_Size_const_Codec_const_double_const_ColorFormat_PtrLEncoderCallbackG_const_StreamR(file_name: *const c_char, frame_size: *const core::Size, codec: crate::cudacodec::CUDA_Codec, fps: f64, color_format: crate::cudacodec::CUDA_ColorFormat, encoder_callback: *mut c_void, stream: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cudacodec_createVideoWriter_const_StringR_const_Size_const_Codec_const_double_const_ColorFormat_const_EncoderParamsR(file_name: *const c_char, frame_size: *const core::Size, codec: crate::cudacodec::CUDA_Codec, fps: f64, color_format: crate::cudacodec::CUDA_ColorFormat, params: *const crate::cudacodec::CUDA_EncoderParams, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cudacodec_createVideoWriter_const_StringR_const_Size_const_Codec_const_double_const_ColorFormat_const_EncoderParamsR_PtrLEncoderCallbackG_const_StreamR(file_name: *const c_char, frame_size: *const core::Size, codec: crate::cudacodec::CUDA_Codec, fps: f64, color_format: crate::cudacodec::CUDA_ColorFormat, params: *const crate::cudacodec::CUDA_EncoderParams, encoder_callback: *mut c_void, stream: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cudacodec_operatorEQ_const_EncoderParamsR_const_EncoderParamsR(lhs: *const crate::cudacodec::CUDA_EncoderParams, rhs: *const crate::cudacodec::CUDA_EncoderParams, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_EncoderCallback_onEncoded_vectorLvectorLuint8_tGG(instance: *mut c_void, v_packet: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cudacodec_EncoderCallback_onEncodingFinished(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cudacodec_EncoderCallback_delete(instance: *mut c_void);
		pub fn cv_cudacodec_EncoderParams_EncoderParams(ocvrs_return: *mut Result<crate::cudacodec::CUDA_EncoderParams>);
		pub fn cv_cudacodec_FormatInfo_FormatInfo(ocvrs_return: *mut Result<crate::cudacodec::CUDA_FormatInfo>);
		pub fn cv_cudacodec_RawVideoSource_getNextPacket_unsigned_charXX_size_tX(instance: *mut c_void, data: *mut *mut u8, size: *mut size_t, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_RawVideoSource_lastPacketContainsKeyFrame_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_RawVideoSource_format_const(instance: *const c_void, ocvrs_return: *mut Result<crate::cudacodec::CUDA_FormatInfo>);
		pub fn cv_cudacodec_RawVideoSource_updateFormat_const_FormatInfoR(instance: *mut c_void, video_format: *const crate::cudacodec::CUDA_FormatInfo, ocvrs_return: *mut Result_void);
		pub fn cv_cudacodec_RawVideoSource_getExtraData_const_MatR(instance: *const c_void, extra_data: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cudacodec_RawVideoSource_get_const_const_int_doubleR(instance: *const c_void, property_id: i32, property_val: *mut f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_RawVideoSource_delete(instance: *mut c_void);
		pub fn cv_cudacodec_VideoReader_nextFrame_GpuMatR_StreamR(instance: *mut c_void, frame: *mut c_void, stream: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_VideoReader_nextFrame_GpuMatR(instance: *mut c_void, frame: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_VideoReader_format_const(instance: *const c_void, ocvrs_return: *mut Result<crate::cudacodec::CUDA_FormatInfo>);
		pub fn cv_cudacodec_VideoReader_grab_StreamR(instance: *mut c_void, stream: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_VideoReader_grab(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_VideoReader_retrieve_const_const__OutputArrayR_const_size_t(instance: *const c_void, frame: *const c_void, idx: size_t, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_VideoReader_retrieve_const_const__OutputArrayR(instance: *const c_void, frame: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_VideoReader_retrieve_const_MatR_const_size_t(instance: *const c_void, frame: *mut c_void, idx: size_t, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_VideoReader_retrieve_const_GpuMatR(instance: *const c_void, frame: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_VideoReader_set_const_VideoReaderProps_const_double(instance: *mut c_void, property_id: crate::cudacodec::CUDA_VideoReaderProps, property_val: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_VideoReader_setVideoReaderProps_const_VideoReaderProps_double(instance: *mut c_void, property_id: crate::cudacodec::CUDA_VideoReaderProps, property_val: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_VideoReader_set_const_ColorFormat(instance: *mut c_void, color_format: crate::cudacodec::CUDA_ColorFormat, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_VideoReader_get_const_const_VideoReaderProps_doubleR(instance: *const c_void, property_id: crate::cudacodec::CUDA_VideoReaderProps, property_val: *mut f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_VideoReader_getVideoReaderProps_const_const_VideoReaderProps_doubleR_double(instance: *const c_void, property_id: crate::cudacodec::CUDA_VideoReaderProps, property_val_out: *mut f64, property_val_in: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_VideoReader_getVideoReaderProps_const_const_VideoReaderProps_doubleR(instance: *const c_void, property_id: crate::cudacodec::CUDA_VideoReaderProps, property_val_out: *mut f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_VideoReader_get_const_const_int_doubleR(instance: *const c_void, property_id: i32, property_val: *mut f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_cudacodec_VideoReader_delete(instance: *mut c_void);
		pub fn cv_cudacodec_VideoReaderInitParams_VideoReaderInitParams(ocvrs_return: *mut Result<crate::cudacodec::CUDA_VideoReaderInitParams>);
		pub fn cv_cudacodec_VideoWriter_write_const__InputArrayR(instance: *mut c_void, frame: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cudacodec_VideoWriter_getEncoderParams_const(instance: *const c_void, ocvrs_return: *mut Result<crate::cudacodec::CUDA_EncoderParams>);
		pub fn cv_cudacodec_VideoWriter_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cudacodec_VideoWriter_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cudacodec_EncoderCallbackG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cudacodec_EncoderCallbackG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cudacodec_EncoderCallbackG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cudacodec_RawVideoSourceG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cudacodec_RawVideoSourceG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cudacodec_RawVideoSourceG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cudacodec_VideoReaderG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cudacodec_VideoReaderG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cudacodec_VideoReaderG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cudacodec_VideoWriterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cudacodec_VideoWriterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cudacodec_VideoWriterG_delete(instance: *mut c_void);
	}
}
#[cfg(ocvrs_has_module_cudacodec)]
pub use cudacodec_sys::*;

#[cfg(ocvrs_has_module_cudafeatures2d)]
mod cudafeatures2d_sys {
	use super::*;

	extern "C" {
		pub fn cv_cuda_DescriptorMatcher_createBFMatcher_int(norm_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_DescriptorMatcher_createBFMatcher(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_DescriptorMatcher_isMaskSupported_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DescriptorMatcher_add_const_vectorLGpuMatGR(instance: *mut c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_getTrainDescriptors_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_DescriptorMatcher_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DescriptorMatcher_train(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_match_const__InputArrayR_const__InputArrayR_vectorLDMatchGR_const__InputArrayR(instance: *mut c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_match_const__InputArrayR_const__InputArrayR_vectorLDMatchGR(instance: *mut c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_match_const__InputArrayR_vectorLDMatchGR_const_vectorLGpuMatGR(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_match_const__InputArrayR_vectorLDMatchGR(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_matchAsync_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR_StreamR(instance: *mut c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *const c_void, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_matchAsync_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_matchAsync_const__InputArrayR_const__OutputArrayR_const_vectorLGpuMatGR_StreamR(instance: *mut c_void, query_descriptors: *const c_void, matches: *const c_void, masks: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_matchAsync_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, query_descriptors: *const c_void, matches: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_matchConvert_const__InputArrayR_vectorLDMatchGR(instance: *mut c_void, gpu_matches: *const c_void, matches: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_knnMatch_const__InputArrayR_const__InputArrayR_vectorLvectorLDMatchGGR_int_const__InputArrayR_bool(instance: *mut c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, k: i32, mask: *const c_void, compact_result: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_knnMatch_const__InputArrayR_const__InputArrayR_vectorLvectorLDMatchGGR_int(instance: *mut c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_knnMatch_const__InputArrayR_vectorLvectorLDMatchGGR_int_const_vectorLGpuMatGR_bool(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, k: i32, masks: *const c_void, compact_result: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_knnMatch_const__InputArrayR_vectorLvectorLDMatchGGR_int(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_knnMatchAsync_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR_StreamR(instance: *mut c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *const c_void, k: i32, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_knnMatchAsync_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(instance: *mut c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *const c_void, k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_knnMatchAsync_const__InputArrayR_const__OutputArrayR_int_const_vectorLGpuMatGR_StreamR(instance: *mut c_void, query_descriptors: *const c_void, matches: *const c_void, k: i32, masks: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_knnMatchAsync_const__InputArrayR_const__OutputArrayR_int(instance: *mut c_void, query_descriptors: *const c_void, matches: *const c_void, k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_knnMatchConvert_const__InputArrayR_vectorLvectorLDMatchGGR_bool(instance: *mut c_void, gpu_matches: *const c_void, matches: *mut c_void, compact_result: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_knnMatchConvert_const__InputArrayR_vectorLvectorLDMatchGGR(instance: *mut c_void, gpu_matches: *const c_void, matches: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_radiusMatch_const__InputArrayR_const__InputArrayR_vectorLvectorLDMatchGGR_float_const__InputArrayR_bool(instance: *mut c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, max_distance: f32, mask: *const c_void, compact_result: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_radiusMatch_const__InputArrayR_const__InputArrayR_vectorLvectorLDMatchGGR_float(instance: *mut c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, max_distance: f32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_radiusMatch_const__InputArrayR_vectorLvectorLDMatchGGR_float_const_vectorLGpuMatGR_bool(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, max_distance: f32, masks: *const c_void, compact_result: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_radiusMatch_const__InputArrayR_vectorLvectorLDMatchGGR_float(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, max_distance: f32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_radiusMatchAsync_const__InputArrayR_const__InputArrayR_const__OutputArrayR_float_const__InputArrayR_StreamR(instance: *mut c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *const c_void, max_distance: f32, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_radiusMatchAsync_const__InputArrayR_const__InputArrayR_const__OutputArrayR_float(instance: *mut c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *const c_void, max_distance: f32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_radiusMatchAsync_const__InputArrayR_const__OutputArrayR_float_const_vectorLGpuMatGR_StreamR(instance: *mut c_void, query_descriptors: *const c_void, matches: *const c_void, max_distance: f32, masks: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_radiusMatchAsync_const__InputArrayR_const__OutputArrayR_float(instance: *mut c_void, query_descriptors: *const c_void, matches: *const c_void, max_distance: f32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_radiusMatchConvert_const__InputArrayR_vectorLvectorLDMatchGGR_bool(instance: *mut c_void, gpu_matches: *const c_void, matches: *mut c_void, compact_result: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_radiusMatchConvert_const__InputArrayR_vectorLvectorLDMatchGGR(instance: *mut c_void, gpu_matches: *const c_void, matches: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DescriptorMatcher_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_DescriptorMatcher_delete(instance: *mut c_void);
		pub fn cv_cuda_FastFeatureDetector_create_int_bool_int_int(threshold: i32, nonmax_suppression: bool, typ: i32, max_npoints: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_FastFeatureDetector_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_FastFeatureDetector_setThreshold_int(instance: *mut c_void, threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_FastFeatureDetector_setMaxNumPoints_int(instance: *mut c_void, max_npoints: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_FastFeatureDetector_getMaxNumPoints_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_FastFeatureDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_FastFeatureDetector_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_FastFeatureDetector_to_CUDA_Feature2DAsync(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_FastFeatureDetector_delete(instance: *mut c_void);
		pub fn cv_cuda_Feature2DAsync_detectAsync_const__InputArrayR_const__OutputArrayR_const__InputArrayR_StreamR(instance: *mut c_void, image: *const c_void, keypoints: *const c_void, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Feature2DAsync_detectAsync_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, keypoints: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Feature2DAsync_computeAsync_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, image: *const c_void, keypoints: *const c_void, descriptors: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Feature2DAsync_computeAsync_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, keypoints: *const c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Feature2DAsync_detectAndComputeAsync_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_bool_StreamR(instance: *mut c_void, image: *const c_void, mask: *const c_void, keypoints: *const c_void, descriptors: *const c_void, use_provided_keypoints: bool, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Feature2DAsync_detectAndComputeAsync_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, mask: *const c_void, keypoints: *const c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Feature2DAsync_convert_const__InputArrayR_vectorLKeyPointGR(instance: *mut c_void, gpu_keypoints: *const c_void, keypoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Feature2DAsync_to_CUDA_FastFeatureDetector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_Feature2DAsync_to_CUDA_ORB(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_Feature2DAsync_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_Feature2DAsync_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_Feature2DAsync_delete(instance: *mut c_void);
		pub fn cv_cuda_ORB_create_int_float_int_int_int_int_int_int_int_bool(nfeatures: i32, scale_factor: f32, nlevels: i32, edge_threshold: i32, first_level: i32, wta_k: i32, score_type: i32, patch_size: i32, fast_threshold: i32, blur_for_descriptor: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_ORB_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_ORB_setMaxFeatures_int(instance: *mut c_void, max_features: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_ORB_getMaxFeatures_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_ORB_setScaleFactor_double(instance: *mut c_void, scale_factor: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_ORB_getScaleFactor_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_ORB_setNLevels_int(instance: *mut c_void, nlevels: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_ORB_getNLevels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_ORB_setEdgeThreshold_int(instance: *mut c_void, edge_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_ORB_getEdgeThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_ORB_setFirstLevel_int(instance: *mut c_void, first_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_ORB_getFirstLevel_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_ORB_setWTA_K_int(instance: *mut c_void, wta_k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_ORB_getWTA_K_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_ORB_setScoreType_int(instance: *mut c_void, score_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_ORB_getScoreType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_ORB_setPatchSize_int(instance: *mut c_void, patch_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_ORB_getPatchSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_ORB_setFastThreshold_int(instance: *mut c_void, fast_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_ORB_getFastThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_ORB_setBlurForDescriptor_bool(instance: *mut c_void, blur_for_descriptor: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_ORB_getBlurForDescriptor_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_ORB_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_ORB_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_ORB_to_CUDA_Feature2DAsync(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_ORB_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_DescriptorMatcherG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_DescriptorMatcherG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_DescriptorMatcherG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_DescriptorMatcherG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_FastFeatureDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_FastFeatureDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_FastFeatureDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_FastFeatureDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_FastFeatureDetectorG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_FastFeatureDetectorG_to_PtrOfCUDA_Feature2DAsync(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_Feature2DAsyncG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_Feature2DAsyncG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_Feature2DAsyncG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_Feature2DAsyncG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_Feature2DAsyncG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_ORBG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_ORBG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_ORBG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_ORBG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_ORBG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_ORBG_to_PtrOfCUDA_Feature2DAsync(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_cudafeatures2d)]
pub use cudafeatures2d_sys::*;

#[cfg(ocvrs_has_module_cudafilters)]
mod cudafilters_sys {
	use super::*;

	extern "C" {
		pub fn cv_cuda_createBoxFilter_int_int_Size(src_type: i32, dst_type: i32, ksize: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createBoxFilter_int_int_Size_Point_int_Scalar(src_type: i32, dst_type: i32, ksize: *const core::Size, anchor: *const core::Point, border_mode: i32, border_val: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createBoxMaxFilter_int_Size(src_type: i32, ksize: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createBoxMaxFilter_int_Size_Point_int_Scalar(src_type: i32, ksize: *const core::Size, anchor: *const core::Point, border_mode: i32, border_val: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createBoxMinFilter_int_Size(src_type: i32, ksize: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createBoxMinFilter_int_Size_Point_int_Scalar(src_type: i32, ksize: *const core::Size, anchor: *const core::Point, border_mode: i32, border_val: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createColumnSumFilter_int_int_int(src_type: i32, dst_type: i32, ksize: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createColumnSumFilter_int_int_int_int_int_Scalar(src_type: i32, dst_type: i32, ksize: i32, anchor: i32, border_mode: i32, border_val: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createDerivFilter_int_int_int_int_int(src_type: i32, dst_type: i32, dx: i32, dy: i32, ksize: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createDerivFilter_int_int_int_int_int_bool_double_int_int(src_type: i32, dst_type: i32, dx: i32, dy: i32, ksize: i32, normalize: bool, scale: f64, row_border_mode: i32, column_border_mode: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createGaussianFilter_int_int_Size_double(src_type: i32, dst_type: i32, ksize: *const core::Size, sigma1: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createGaussianFilter_int_int_Size_double_double_int_int(src_type: i32, dst_type: i32, ksize: *const core::Size, sigma1: f64, sigma2: f64, row_border_mode: i32, column_border_mode: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createLaplacianFilter_int_int(src_type: i32, dst_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createLaplacianFilter_int_int_int_double_int_Scalar(src_type: i32, dst_type: i32, ksize: i32, scale: f64, border_mode: i32, border_val: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createLinearFilter_int_int_const__InputArrayR(src_type: i32, dst_type: i32, kernel: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createLinearFilter_int_int_const__InputArrayR_Point_int_Scalar(src_type: i32, dst_type: i32, kernel: *const c_void, anchor: *const core::Point, border_mode: i32, border_val: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createMedianFilter_int_int(src_type: i32, window_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createMedianFilter_int_int_int(src_type: i32, window_size: i32, partition: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createMorphologyFilter_int_int_const__InputArrayR(op: i32, src_type: i32, kernel: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createMorphologyFilter_int_int_const__InputArrayR_Point_int(op: i32, src_type: i32, kernel: *const c_void, anchor: *const core::Point, iterations: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createRowSumFilter_int_int_int(src_type: i32, dst_type: i32, ksize: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createRowSumFilter_int_int_int_int_int_Scalar(src_type: i32, dst_type: i32, ksize: i32, anchor: i32, border_mode: i32, border_val: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createScharrFilter_int_int_int_int(src_type: i32, dst_type: i32, dx: i32, dy: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createScharrFilter_int_int_int_int_double_int_int(src_type: i32, dst_type: i32, dx: i32, dy: i32, scale: f64, row_border_mode: i32, column_border_mode: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createSeparableLinearFilter_int_int_const__InputArrayR_const__InputArrayR(src_type: i32, dst_type: i32, row_kernel: *const c_void, column_kernel: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createSeparableLinearFilter_int_int_const__InputArrayR_const__InputArrayR_Point_int_int(src_type: i32, dst_type: i32, row_kernel: *const c_void, column_kernel: *const c_void, anchor: *const core::Point, row_border_mode: i32, column_border_mode: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createSobelFilter_int_int_int_int(src_type: i32, dst_type: i32, dx: i32, dy: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createSobelFilter_int_int_int_int_int_double_int_int(src_type: i32, dst_type: i32, dx: i32, dy: i32, ksize: i32, scale: f64, row_border_mode: i32, column_border_mode: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_Filter_apply_const__InputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, src: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Filter_apply_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_Filter_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_Filter_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_FilterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_FilterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_FilterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_FilterG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_cudafilters)]
pub use cudafilters_sys::*;

#[cfg(ocvrs_has_module_cudaimgproc)]
mod cudaimgproc_sys {
	use super::*;

	extern "C" {
		pub fn cv_cuda_alphaComp_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(img1: *const c_void, img2: *const c_void, dst: *const c_void, alpha_op: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_alphaComp_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_StreamR(img1: *const c_void, img2: *const c_void, dst: *const c_void, alpha_op: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_bilateralFilter_const__InputArrayR_const__OutputArrayR_int_float_float(src: *const c_void, dst: *const c_void, kernel_size: i32, sigma_color: f32, sigma_spatial: f32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_bilateralFilter_const__InputArrayR_const__OutputArrayR_int_float_float_int_StreamR(src: *const c_void, dst: *const c_void, kernel_size: i32, sigma_color: f32, sigma_spatial: f32, border_mode: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_blendLinear_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(img1: *const c_void, img2: *const c_void, weights1: *const c_void, weights2: *const c_void, result: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_blendLinear_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_StreamR(img1: *const c_void, img2: *const c_void, weights1: *const c_void, weights2: *const c_void, result: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_calcHist_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src: *const c_void, mask: *const c_void, hist: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_calcHist_const__InputArrayR_const__InputArrayR_const__OutputArrayR_StreamR(src: *const c_void, mask: *const c_void, hist: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_calcHist_const__InputArrayR_const__OutputArrayR(src: *const c_void, hist: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_calcHist_const__InputArrayR_const__OutputArrayR_StreamR(src: *const c_void, hist: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_connectedComponents_const__InputArrayR_const__OutputArrayR(image: *const c_void, labels: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_connectedComponents_const__InputArrayR_const__OutputArrayR_int_int(image: *const c_void, labels: *const c_void, connectivity: i32, ltype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_connectedComponents_const__InputArrayR_const__OutputArrayR_int_int_ConnectedComponentsAlgorithmsTypes(image: *const c_void, labels: *const c_void, connectivity: i32, ltype: i32, ccltype: crate::cudaimgproc::CUDA_ConnectedComponentsAlgorithmsTypes, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_createCLAHE(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createCLAHE_double_Size(clip_limit: f64, tile_grid_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createCannyEdgeDetector_double_double(low_thresh: f64, high_thresh: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createCannyEdgeDetector_double_double_int_bool(low_thresh: f64, high_thresh: f64, apperture_size: i32, l2gradient: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createGeneralizedHoughBallard(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createGeneralizedHoughGuil(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createGoodFeaturesToTrackDetector_int(src_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createGoodFeaturesToTrackDetector_int_int_double_double_int_bool_double(src_type: i32, max_corners: i32, quality_level: f64, min_distance: f64, block_size: i32, use_harris_detector: bool, harris_k: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createHarrisCorner_int_int_int_double(src_type: i32, block_size: i32, ksize: i32, k: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createHarrisCorner_int_int_int_double_int(src_type: i32, block_size: i32, ksize: i32, k: f64, border_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createHoughCirclesDetector_float_float_int_int_int_int(dp: f32, min_dist: f32, canny_threshold: i32, votes_threshold: i32, min_radius: i32, max_radius: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createHoughCirclesDetector_float_float_int_int_int_int_int(dp: f32, min_dist: f32, canny_threshold: i32, votes_threshold: i32, min_radius: i32, max_radius: i32, max_circles: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createHoughLinesDetector_float_float_int(rho: f32, theta: f32, threshold: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createHoughLinesDetector_float_float_int_bool_int(rho: f32, theta: f32, threshold: i32, do_sort: bool, max_lines: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createHoughSegmentDetector_float_float_int_int(rho: f32, theta: f32, min_line_length: i32, max_line_gap: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createHoughSegmentDetector_float_float_int_int_int_int(rho: f32, theta: f32, min_line_length: i32, max_line_gap: i32, max_lines: i32, threshold: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createMinEigenValCorner_int_int_int(src_type: i32, block_size: i32, ksize: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createMinEigenValCorner_int_int_int_int(src_type: i32, block_size: i32, ksize: i32, border_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createTemplateMatching_int_int(src_type: i32, method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createTemplateMatching_int_int_Size(src_type: i32, method: i32, user_block_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_cvtColor_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, code: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_cvtColor_const__InputArrayR_const__OutputArrayR_int_int_StreamR(src: *const c_void, dst: *const c_void, code: i32, dcn: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_demosaicing_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, code: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_demosaicing_const__InputArrayR_const__OutputArrayR_int_int_StreamR(src: *const c_void, dst: *const c_void, code: i32, dcn: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_equalizeHist_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_equalizeHist_const__InputArrayR_const__OutputArrayR_StreamR(src: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_evenLevels_const__OutputArrayR_int_int_int(levels: *const c_void, n_levels: i32, lower_level: i32, upper_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_evenLevels_const__OutputArrayR_int_int_int_StreamR(levels: *const c_void, n_levels: i32, lower_level: i32, upper_level: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_gammaCorrection_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_gammaCorrection_const__InputArrayR_const__OutputArrayR_bool_StreamR(src: *const c_void, dst: *const c_void, forward: bool, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_histEven_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, hist: *const c_void, hist_size: i32, lower_level: i32, upper_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_histEven_const__InputArrayR_const__OutputArrayR_int_int_int_StreamR(src: *const c_void, hist: *const c_void, hist_size: i32, lower_level: i32, upper_level: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_histRange_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, hist: *const c_void, levels: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_histRange_const__InputArrayR_const__OutputArrayR_const__InputArrayR_StreamR(src: *const c_void, hist: *const c_void, levels: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_meanShiftFiltering_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, sp: i32, sr: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_meanShiftFiltering_const__InputArrayR_const__OutputArrayR_int_int_TermCriteria_StreamR(src: *const c_void, dst: *const c_void, sp: i32, sr: i32, criteria: *const core::TermCriteria, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_meanShiftProc_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_int(src: *const c_void, dstr: *const c_void, dstsp: *const c_void, sp: i32, sr: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_meanShiftProc_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_int_TermCriteria_StreamR(src: *const c_void, dstr: *const c_void, dstsp: *const c_void, sp: i32, sr: i32, criteria: *const core::TermCriteria, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_meanShiftSegmentation_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, sp: i32, sr: i32, minsize: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_meanShiftSegmentation_const__InputArrayR_const__OutputArrayR_int_int_int_TermCriteria_StreamR(src: *const c_void, dst: *const c_void, sp: i32, sr: i32, minsize: i32, criteria: *const core::TermCriteria, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_swapChannels_const__InputOutputArrayR_const_intXX(image: *const c_void, dst_order: *const [i32; 4], ocvrs_return: *mut Result_void);
		pub fn cv_cuda_swapChannels_const__InputOutputArrayR_const_intXX_StreamR(image: *const c_void, dst_order: *const [i32; 4], stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CLAHE_apply_const__InputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, src: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CLAHE_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_CLAHE_to_CLAHE(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_CLAHE_delete(instance: *mut c_void);
		pub fn cv_cuda_CannyEdgeDetector_detect_const__InputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, image: *const c_void, edges: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CannyEdgeDetector_detect_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, edges: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CannyEdgeDetector_detect_const__InputArrayR_const__InputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, dx: *const c_void, dy: *const c_void, edges: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CannyEdgeDetector_detect_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, dx: *const c_void, dy: *const c_void, edges: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CannyEdgeDetector_setLowThreshold_double(instance: *mut c_void, low_thresh: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CannyEdgeDetector_getLowThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_CannyEdgeDetector_setHighThreshold_double(instance: *mut c_void, high_thresh: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CannyEdgeDetector_getHighThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_CannyEdgeDetector_setAppertureSize_int(instance: *mut c_void, apperture_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CannyEdgeDetector_getAppertureSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_CannyEdgeDetector_setL2Gradient_bool(instance: *mut c_void, l2gradient: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CannyEdgeDetector_getL2Gradient_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_CannyEdgeDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_CannyEdgeDetector_delete(instance: *mut c_void);
		pub fn cv_cuda_CornernessCriteria_compute_const__InputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, src: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CornernessCriteria_compute_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CornernessCriteria_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_CornernessCriteria_delete(instance: *mut c_void);
		pub fn cv_cuda_CornersDetector_detect_const__InputArrayR_const__OutputArrayR_const__InputArrayR_StreamR(instance: *mut c_void, image: *const c_void, corners: *const c_void, mask: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CornersDetector_detect_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, corners: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CornersDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_CornersDetector_delete(instance: *mut c_void);
		pub fn cv_cuda_HoughCirclesDetector_detect_const__InputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, src: *const c_void, circles: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughCirclesDetector_detect_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, circles: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughCirclesDetector_setDp_float(instance: *mut c_void, dp: f32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughCirclesDetector_getDp_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_cuda_HoughCirclesDetector_setMinDist_float(instance: *mut c_void, min_dist: f32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughCirclesDetector_getMinDist_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_cuda_HoughCirclesDetector_setCannyThreshold_int(instance: *mut c_void, canny_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughCirclesDetector_getCannyThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HoughCirclesDetector_setVotesThreshold_int(instance: *mut c_void, votes_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughCirclesDetector_getVotesThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HoughCirclesDetector_setMinRadius_int(instance: *mut c_void, min_radius: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughCirclesDetector_getMinRadius_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HoughCirclesDetector_setMaxRadius_int(instance: *mut c_void, max_radius: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughCirclesDetector_getMaxRadius_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HoughCirclesDetector_setMaxCircles_int(instance: *mut c_void, max_circles: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughCirclesDetector_getMaxCircles_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HoughCirclesDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_HoughCirclesDetector_delete(instance: *mut c_void);
		pub fn cv_cuda_HoughLinesDetector_detect_const__InputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, src: *const c_void, lines: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughLinesDetector_detect_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, lines: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughLinesDetector_downloadResults_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, d_lines: *const c_void, h_lines: *const c_void, h_votes: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughLinesDetector_downloadResults_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, d_lines: *const c_void, h_lines: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughLinesDetector_setRho_float(instance: *mut c_void, rho: f32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughLinesDetector_getRho_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_cuda_HoughLinesDetector_setTheta_float(instance: *mut c_void, theta: f32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughLinesDetector_getTheta_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_cuda_HoughLinesDetector_setThreshold_int(instance: *mut c_void, threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughLinesDetector_getThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HoughLinesDetector_setDoSort_bool(instance: *mut c_void, do_sort: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughLinesDetector_getDoSort_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_HoughLinesDetector_setMaxLines_int(instance: *mut c_void, max_lines: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughLinesDetector_getMaxLines_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HoughLinesDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_HoughLinesDetector_delete(instance: *mut c_void);
		pub fn cv_cuda_HoughSegmentDetector_detect_const__InputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, src: *const c_void, lines: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughSegmentDetector_detect_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, lines: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughSegmentDetector_setRho_float(instance: *mut c_void, rho: f32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughSegmentDetector_getRho_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_cuda_HoughSegmentDetector_setTheta_float(instance: *mut c_void, theta: f32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughSegmentDetector_getTheta_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_cuda_HoughSegmentDetector_setMinLineLength_int(instance: *mut c_void, min_line_length: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughSegmentDetector_getMinLineLength_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HoughSegmentDetector_setMaxLineGap_int(instance: *mut c_void, max_line_gap: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughSegmentDetector_getMaxLineGap_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HoughSegmentDetector_setMaxLines_int(instance: *mut c_void, max_lines: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughSegmentDetector_getMaxLines_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HoughSegmentDetector_setThreshold_int(instance: *mut c_void, threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HoughSegmentDetector_getThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HoughSegmentDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_HoughSegmentDetector_delete(instance: *mut c_void);
		pub fn cv_cuda_TemplateMatching_match_const__InputArrayR_const__InputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, image: *const c_void, templ: *const c_void, result: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_TemplateMatching_match_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, templ: *const c_void, result: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_TemplateMatching_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_TemplateMatching_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_CLAHEG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_CLAHEG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_CLAHEG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_CLAHEG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_CLAHEG_to_PtrOfCLAHE(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_CannyEdgeDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_CannyEdgeDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_CannyEdgeDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_CannyEdgeDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_CornernessCriteriaG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_CornernessCriteriaG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_CornernessCriteriaG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_CornernessCriteriaG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_CornersDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_CornersDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_CornersDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_CornersDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_HoughCirclesDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_HoughCirclesDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_HoughCirclesDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_HoughCirclesDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_HoughLinesDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_HoughLinesDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_HoughLinesDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_HoughLinesDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_HoughSegmentDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_HoughSegmentDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_HoughSegmentDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_HoughSegmentDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_TemplateMatchingG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_TemplateMatchingG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_TemplateMatchingG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_TemplateMatchingG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_cudaimgproc)]
pub use cudaimgproc_sys::*;

#[cfg(ocvrs_has_module_cudaobjdetect)]
mod cudaobjdetect_sys {
	use super::*;

	extern "C" {
		pub fn cv_cuda_CascadeClassifier_create_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_CascadeClassifier_create_const_FileStorageR(file: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_CascadeClassifier_setMaxObjectSize_Size(instance: *mut c_void, max_object_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CascadeClassifier_getMaxObjectSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_cuda_CascadeClassifier_setMinObjectSize_Size(instance: *mut c_void, min_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CascadeClassifier_getMinObjectSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_cuda_CascadeClassifier_setScaleFactor_double(instance: *mut c_void, scale_factor: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CascadeClassifier_getScaleFactor_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_CascadeClassifier_setMinNeighbors_int(instance: *mut c_void, min_neighbors: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CascadeClassifier_getMinNeighbors_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_CascadeClassifier_setFindLargestObject_bool(instance: *mut c_void, find_largest_object: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CascadeClassifier_getFindLargestObject(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_CascadeClassifier_setMaxNumObjects_int(instance: *mut c_void, max_num_objects: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CascadeClassifier_getMaxNumObjects_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_CascadeClassifier_getClassifierSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_cuda_CascadeClassifier_detectMultiScale_const__InputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, image: *const c_void, objects: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CascadeClassifier_detectMultiScale_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, objects: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CascadeClassifier_convert_const__OutputArrayR_vectorLRectGR(instance: *mut c_void, gpu_objects: *const c_void, objects: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_CascadeClassifier_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_CascadeClassifier_delete(instance: *mut c_void);
		pub fn cv_cuda_HOG_create_Size_Size_Size_Size_int(win_size: *const core::Size, block_size: *const core::Size, block_stride: *const core::Size, cell_size: *const core::Size, nbins: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HOG_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HOG_setWinSigma_double(instance: *mut c_void, win_sigma: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_getWinSigma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_HOG_setL2HysThreshold_double(instance: *mut c_void, threshold_l2hys: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_getL2HysThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_HOG_setGammaCorrection_bool(instance: *mut c_void, gamma_correction: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_getGammaCorrection_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_HOG_setNumLevels_int(instance: *mut c_void, nlevels: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_getNumLevels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HOG_setHitThreshold_double(instance: *mut c_void, hit_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_getHitThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_HOG_setWinStride_Size(instance: *mut c_void, win_stride: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_getWinStride_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_cuda_HOG_setScaleFactor_double(instance: *mut c_void, scale0: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_getScaleFactor_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_HOG_setGroupThreshold_int(instance: *mut c_void, group_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_getGroupThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_HOG_setDescriptorFormat_DescriptorStorageFormat(instance: *mut c_void, descr_format: crate::objdetect::HOGDescriptor_DescriptorStorageFormat, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_getDescriptorFormat_const(instance: *const c_void, ocvrs_return: *mut Result<crate::objdetect::HOGDescriptor_DescriptorStorageFormat>);
		pub fn cv_cuda_HOG_getDescriptorSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_HOG_getBlockHistogramSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_cuda_HOG_setSVMDetector_const__InputArrayR(instance: *mut c_void, detector: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_getDefaultPeopleDetector_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_HOG_detect_const__InputArrayR_vectorLPointGR_vectorLdoubleGX(instance: *mut c_void, img: *const c_void, found_locations: *mut c_void, confidences: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_detect_const__InputArrayR_vectorLPointGR(instance: *mut c_void, img: *const c_void, found_locations: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_detect_const__InputArrayR_vectorLPointGR_vectorLdoubleGR(instance: *mut c_void, img: *const c_void, found_locations: *mut c_void, confidences: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_detectWithoutConf_const__InputArrayR_vectorLPointGR(instance: *mut c_void, img: *const c_void, found_locations: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_detectMultiScale_const__InputArrayR_vectorLRectGR_vectorLdoubleGX(instance: *mut c_void, img: *const c_void, found_locations: *mut c_void, confidences: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_detectMultiScale_const__InputArrayR_vectorLRectGR(instance: *mut c_void, img: *const c_void, found_locations: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_detectMultiScale_const__InputArrayR_vectorLRectGR_vectorLdoubleGR(instance: *mut c_void, img: *const c_void, found_locations: *mut c_void, confidences: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_detectMultiScaleWithoutConf_const__InputArrayR_vectorLRectGR(instance: *mut c_void, img: *const c_void, found_locations: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_compute_const__InputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, img: *const c_void, descriptors: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_compute_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, img: *const c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_HOG_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_HOG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_CascadeClassifierG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_CascadeClassifierG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_CascadeClassifierG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_CascadeClassifierG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_HOGG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_HOGG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_HOGG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_HOGG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_cudaobjdetect)]
pub use cudaobjdetect_sys::*;

#[cfg(ocvrs_has_module_cudaoptflow)]
mod cudaoptflow_sys {
	use super::*;

	extern "C" {
		pub fn cv_cuda_BroxOpticalFlow_getFlowSmoothness_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_BroxOpticalFlow_setFlowSmoothness_double(instance: *mut c_void, alpha: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_BroxOpticalFlow_getGradientConstancyImportance_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_BroxOpticalFlow_setGradientConstancyImportance_double(instance: *mut c_void, gamma: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_BroxOpticalFlow_getPyramidScaleFactor_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_BroxOpticalFlow_setPyramidScaleFactor_double(instance: *mut c_void, scale_factor: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_BroxOpticalFlow_getInnerIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_BroxOpticalFlow_setInnerIterations_int(instance: *mut c_void, inner_iterations: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_BroxOpticalFlow_getOuterIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_BroxOpticalFlow_setOuterIterations_int(instance: *mut c_void, outer_iterations: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_BroxOpticalFlow_getSolverIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_BroxOpticalFlow_setSolverIterations_int(instance: *mut c_void, solver_iterations: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_BroxOpticalFlow_create_double_double_double_int_int_int(alpha: f64, gamma: f64, scale_factor: f64, inner_iterations: i32, outer_iterations: i32, solver_iterations: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_BroxOpticalFlow_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_BroxOpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_BroxOpticalFlow_to_CUDA_DenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_BroxOpticalFlow_delete(instance: *mut c_void);
		pub fn cv_cuda_DenseOpticalFlow_calc_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_StreamR(instance: *mut c_void, i0: *const c_void, i1: *const c_void, flow: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DenseOpticalFlow_calc_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR(instance: *mut c_void, i0: *const c_void, i1: *const c_void, flow: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DenseOpticalFlow_to_CUDA_BroxOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_DenseOpticalFlow_to_CUDA_DensePyrLKOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_DenseOpticalFlow_to_CUDA_FarnebackOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_DenseOpticalFlow_to_CUDA_OpticalFlowDual_TVL1(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_DenseOpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_DenseOpticalFlow_delete(instance: *mut c_void);
		pub fn cv_cuda_DensePyrLKOpticalFlow_getWinSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_cuda_DensePyrLKOpticalFlow_setWinSize_Size(instance: *mut c_void, win_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DensePyrLKOpticalFlow_getMaxLevel_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DensePyrLKOpticalFlow_setMaxLevel_int(instance: *mut c_void, max_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DensePyrLKOpticalFlow_getNumIters_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DensePyrLKOpticalFlow_setNumIters_int(instance: *mut c_void, iters: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DensePyrLKOpticalFlow_getUseInitialFlow_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_DensePyrLKOpticalFlow_setUseInitialFlow_bool(instance: *mut c_void, use_initial_flow: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DensePyrLKOpticalFlow_create_Size_int_int_bool(win_size: *const core::Size, max_level: i32, iters: i32, use_initial_flow: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_DensePyrLKOpticalFlow_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_DensePyrLKOpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_DensePyrLKOpticalFlow_to_CUDA_DenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_DensePyrLKOpticalFlow_delete(instance: *mut c_void);
		pub fn cv_cuda_FarnebackOpticalFlow_getNumLevels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_FarnebackOpticalFlow_setNumLevels_int(instance: *mut c_void, num_levels: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_FarnebackOpticalFlow_getPyrScale_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_FarnebackOpticalFlow_setPyrScale_double(instance: *mut c_void, pyr_scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_FarnebackOpticalFlow_getFastPyramids_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_FarnebackOpticalFlow_setFastPyramids_bool(instance: *mut c_void, fast_pyramids: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_FarnebackOpticalFlow_getWinSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_FarnebackOpticalFlow_setWinSize_int(instance: *mut c_void, win_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_FarnebackOpticalFlow_getNumIters_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_FarnebackOpticalFlow_setNumIters_int(instance: *mut c_void, num_iters: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_FarnebackOpticalFlow_getPolyN_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_FarnebackOpticalFlow_setPolyN_int(instance: *mut c_void, poly_n: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_FarnebackOpticalFlow_getPolySigma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_FarnebackOpticalFlow_setPolySigma_double(instance: *mut c_void, poly_sigma: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_FarnebackOpticalFlow_getFlags_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_FarnebackOpticalFlow_setFlags_int(instance: *mut c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_FarnebackOpticalFlow_create_int_double_bool_int_int_int_double_int(num_levels: i32, pyr_scale: f64, fast_pyramids: bool, win_size: i32, num_iters: i32, poly_n: i32, poly_sigma: f64, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_FarnebackOpticalFlow_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_FarnebackOpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_FarnebackOpticalFlow_to_CUDA_DenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_FarnebackOpticalFlow_delete(instance: *mut c_void);
		pub fn cv_cuda_NvidiaHWOpticalFlow_calc_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_StreamR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, input_image: *const c_void, reference_image: *const c_void, flow: *const c_void, stream: *mut c_void, hint: *const c_void, cost: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_NvidiaHWOpticalFlow_calc_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR(instance: *mut c_void, input_image: *const c_void, reference_image: *const c_void, flow: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_NvidiaHWOpticalFlow_collectGarbage(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_NvidiaHWOpticalFlow_getGridSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_NvidiaHWOpticalFlow_to_CUDA_NvidiaOpticalFlow_1_0(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_NvidiaHWOpticalFlow_to_CUDA_NvidiaOpticalFlow_2_0(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_NvidiaHWOpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_NvidiaHWOpticalFlow_delete(instance: *mut c_void);
		pub fn cv_cuda_NvidiaOpticalFlow_1_0_upSampler_const__InputArrayR_Size_int_const__InputOutputArrayR(instance: *mut c_void, flow: *const c_void, image_size: *const core::Size, grid_size: i32, upsampled_flow: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_NvidiaOpticalFlow_1_0_create_Size_NVIDIA_OF_PERF_LEVEL_bool_bool_bool_int_StreamR_StreamR(image_size: *const core::Size, perf_preset: crate::cudaoptflow::CUDA_NvidiaOpticalFlow_1_0_NVIDIA_OF_PERF_LEVEL, enable_temporal_hints: bool, enable_external_hints: bool, enable_cost_buffer: bool, gpu_id: i32, input_stream: *mut c_void, output_stream: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_NvidiaOpticalFlow_1_0_create_Size(image_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_NvidiaOpticalFlow_1_0_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_NvidiaOpticalFlow_1_0_to_CUDA_NvidiaHWOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_NvidiaOpticalFlow_1_0_delete(instance: *mut c_void);
		pub fn cv_cuda_NvidiaOpticalFlow_2_0_convertToFloat_const__InputArrayR_const__InputOutputArrayR(instance: *mut c_void, flow: *const c_void, float_flow: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_NvidiaOpticalFlow_2_0_create_Size_NVIDIA_OF_PERF_LEVEL_NVIDIA_OF_OUTPUT_VECTOR_GRID_SIZE_NVIDIA_OF_HINT_VECTOR_GRID_SIZE_bool_bool_bool_int_StreamR_StreamR(image_size: *const core::Size, perf_preset: crate::cudaoptflow::CUDA_NvidiaOpticalFlow_2_0_NVIDIA_OF_PERF_LEVEL, output_grid_size: crate::cudaoptflow::CUDA_NvidiaOpticalFlow_2_0_NVIDIA_OF_OUTPUT_VECTOR_GRID_SIZE, hint_grid_size: crate::cudaoptflow::CUDA_NvidiaOpticalFlow_2_0_NVIDIA_OF_HINT_VECTOR_GRID_SIZE, enable_temporal_hints: bool, enable_external_hints: bool, enable_cost_buffer: bool, gpu_id: i32, input_stream: *mut c_void, output_stream: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_NvidiaOpticalFlow_2_0_create_Size(image_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_NvidiaOpticalFlow_2_0_create_Size_vectorLRectG_NVIDIA_OF_PERF_LEVEL_NVIDIA_OF_OUTPUT_VECTOR_GRID_SIZE_NVIDIA_OF_HINT_VECTOR_GRID_SIZE_bool_bool_bool_int_StreamR_StreamR(image_size: *const core::Size, roi_data: *mut c_void, perf_preset: crate::cudaoptflow::CUDA_NvidiaOpticalFlow_2_0_NVIDIA_OF_PERF_LEVEL, output_grid_size: crate::cudaoptflow::CUDA_NvidiaOpticalFlow_2_0_NVIDIA_OF_OUTPUT_VECTOR_GRID_SIZE, hint_grid_size: crate::cudaoptflow::CUDA_NvidiaOpticalFlow_2_0_NVIDIA_OF_HINT_VECTOR_GRID_SIZE, enable_temporal_hints: bool, enable_external_hints: bool, enable_cost_buffer: bool, gpu_id: i32, input_stream: *mut c_void, output_stream: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_NvidiaOpticalFlow_2_0_create_Size_vectorLRectG(image_size: *const core::Size, roi_data: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_NvidiaOpticalFlow_2_0_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_NvidiaOpticalFlow_2_0_to_CUDA_NvidiaHWOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_NvidiaOpticalFlow_2_0_delete(instance: *mut c_void);
		pub fn cv_cuda_OpticalFlowDual_TVL1_getTau_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_OpticalFlowDual_TVL1_setTau_double(instance: *mut c_void, tau: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_OpticalFlowDual_TVL1_getLambda_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_OpticalFlowDual_TVL1_setLambda_double(instance: *mut c_void, lambda: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_OpticalFlowDual_TVL1_getGamma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_OpticalFlowDual_TVL1_setGamma_double(instance: *mut c_void, gamma: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_OpticalFlowDual_TVL1_getTheta_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_OpticalFlowDual_TVL1_setTheta_double(instance: *mut c_void, theta: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_OpticalFlowDual_TVL1_getNumScales_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_OpticalFlowDual_TVL1_setNumScales_int(instance: *mut c_void, nscales: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_OpticalFlowDual_TVL1_getNumWarps_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_OpticalFlowDual_TVL1_setNumWarps_int(instance: *mut c_void, warps: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_OpticalFlowDual_TVL1_getEpsilon_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_OpticalFlowDual_TVL1_setEpsilon_double(instance: *mut c_void, epsilon: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_OpticalFlowDual_TVL1_getNumIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_OpticalFlowDual_TVL1_setNumIterations_int(instance: *mut c_void, iterations: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_OpticalFlowDual_TVL1_getScaleStep_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_OpticalFlowDual_TVL1_setScaleStep_double(instance: *mut c_void, scale_step: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_OpticalFlowDual_TVL1_getUseInitialFlow_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_OpticalFlowDual_TVL1_setUseInitialFlow_bool(instance: *mut c_void, use_initial_flow: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_OpticalFlowDual_TVL1_create_double_double_double_int_int_double_int_double_double_bool(tau: f64, lambda: f64, theta: f64, nscales: i32, warps: i32, epsilon: f64, iterations: i32, scale_step: f64, gamma: f64, use_initial_flow: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_OpticalFlowDual_TVL1_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_OpticalFlowDual_TVL1_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_OpticalFlowDual_TVL1_to_CUDA_DenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_OpticalFlowDual_TVL1_delete(instance: *mut c_void);
		pub fn cv_cuda_SparseOpticalFlow_calc_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, prev_img: *const c_void, next_img: *const c_void, prev_pts: *const c_void, next_pts: *const c_void, status: *const c_void, err: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SparseOpticalFlow_calc_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR(instance: *mut c_void, prev_img: *const c_void, next_img: *const c_void, prev_pts: *const c_void, next_pts: *const c_void, status: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SparseOpticalFlow_to_CUDA_SparsePyrLKOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_SparseOpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_SparseOpticalFlow_delete(instance: *mut c_void);
		pub fn cv_cuda_SparsePyrLKOpticalFlow_getWinSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_cuda_SparsePyrLKOpticalFlow_setWinSize_Size(instance: *mut c_void, win_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SparsePyrLKOpticalFlow_getMaxLevel_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_SparsePyrLKOpticalFlow_setMaxLevel_int(instance: *mut c_void, max_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SparsePyrLKOpticalFlow_getNumIters_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_SparsePyrLKOpticalFlow_setNumIters_int(instance: *mut c_void, iters: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SparsePyrLKOpticalFlow_getUseInitialFlow_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_SparsePyrLKOpticalFlow_setUseInitialFlow_bool(instance: *mut c_void, use_initial_flow: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SparsePyrLKOpticalFlow_create_Size_int_int_bool(win_size: *const core::Size, max_level: i32, iters: i32, use_initial_flow: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_SparsePyrLKOpticalFlow_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_SparsePyrLKOpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_SparsePyrLKOpticalFlow_to_CUDA_SparseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_SparsePyrLKOpticalFlow_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_BroxOpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_BroxOpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_BroxOpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_BroxOpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_BroxOpticalFlowG_to_PtrOfCUDA_DenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_DenseOpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_DenseOpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_DenseOpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_DenseOpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_DensePyrLKOpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_DensePyrLKOpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_DensePyrLKOpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_DensePyrLKOpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_DensePyrLKOpticalFlowG_to_PtrOfCUDA_DenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_FarnebackOpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_FarnebackOpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_FarnebackOpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_FarnebackOpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_FarnebackOpticalFlowG_to_PtrOfCUDA_DenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_NvidiaHWOpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_NvidiaHWOpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_NvidiaHWOpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_NvidiaHWOpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_NvidiaOpticalFlow_1_0G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_NvidiaOpticalFlow_1_0G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_NvidiaOpticalFlow_1_0G_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_NvidiaOpticalFlow_1_0G_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_NvidiaOpticalFlow_1_0G_to_PtrOfCUDA_NvidiaHWOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_NvidiaOpticalFlow_2_0G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_NvidiaOpticalFlow_2_0G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_NvidiaOpticalFlow_2_0G_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_NvidiaOpticalFlow_2_0G_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_NvidiaOpticalFlow_2_0G_to_PtrOfCUDA_NvidiaHWOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_OpticalFlowDual_TVL1G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_OpticalFlowDual_TVL1G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_OpticalFlowDual_TVL1G_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_OpticalFlowDual_TVL1G_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_OpticalFlowDual_TVL1G_to_PtrOfCUDA_DenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_SparseOpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_SparseOpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_SparseOpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_SparseOpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_SparsePyrLKOpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_SparsePyrLKOpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_SparsePyrLKOpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_SparsePyrLKOpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_SparsePyrLKOpticalFlowG_to_PtrOfCUDA_SparseOpticalFlow(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_cudaoptflow)]
pub use cudaoptflow_sys::*;

#[cfg(ocvrs_has_module_cudastereo)]
mod cudastereo_sys {
	use super::*;

	extern "C" {
		pub fn cv_cuda_createDisparityBilateralFilter(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createDisparityBilateralFilter_int_int_int(ndisp: i32, radius: i32, iters: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createStereoBM(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createStereoBM_int_int(num_disparities: i32, block_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createStereoBeliefPropagation(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createStereoBeliefPropagation_int_int_int_int(ndisp: i32, iters: i32, levels: i32, msg_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createStereoConstantSpaceBP(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createStereoConstantSpaceBP_int_int_int_int_int(ndisp: i32, iters: i32, levels: i32, nr_plane: i32, msg_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createStereoSGM(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_createStereoSGM_int_int_int_int_int_int(min_disparity: i32, num_disparities: i32, p1: i32, p2: i32, uniqueness_ratio: i32, mode: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_drawColorDisp_const__InputArrayR_const__OutputArrayR_int(src_disp: *const c_void, dst_disp: *const c_void, ndisp: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_drawColorDisp_const__InputArrayR_const__OutputArrayR_int_StreamR(src_disp: *const c_void, dst_disp: *const c_void, ndisp: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_reprojectImageTo3D_GpuMat_GpuMatR_Mat(disp: *mut c_void, xyzw: *mut c_void, q: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_reprojectImageTo3D_GpuMat_GpuMatR_Mat_int_StreamR(disp: *mut c_void, xyzw: *mut c_void, q: *mut c_void, dst_cn: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_reprojectImageTo3D_const__InputArrayR_const__OutputArrayR_const__InputArrayR(disp: *const c_void, xyzw: *const c_void, q: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_reprojectImageTo3D_const__InputArrayR_const__OutputArrayR_const__InputArrayR_int_StreamR(disp: *const c_void, xyzw: *const c_void, q: *const c_void, dst_cn: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DisparityBilateralFilter_apply_const__InputArrayR_const__InputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, disparity: *const c_void, image: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DisparityBilateralFilter_apply_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, disparity: *const c_void, image: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DisparityBilateralFilter_getNumDisparities_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DisparityBilateralFilter_setNumDisparities_int(instance: *mut c_void, num_disparities: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DisparityBilateralFilter_getRadius_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DisparityBilateralFilter_setRadius_int(instance: *mut c_void, radius: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DisparityBilateralFilter_getNumIters_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_DisparityBilateralFilter_setNumIters_int(instance: *mut c_void, iters: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DisparityBilateralFilter_getEdgeThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_DisparityBilateralFilter_setEdgeThreshold_double(instance: *mut c_void, edge_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DisparityBilateralFilter_getMaxDiscThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_DisparityBilateralFilter_setMaxDiscThreshold_double(instance: *mut c_void, max_disc_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DisparityBilateralFilter_getSigmaRange_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_DisparityBilateralFilter_setSigmaRange_double(instance: *mut c_void, sigma_range: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_DisparityBilateralFilter_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_DisparityBilateralFilter_delete(instance: *mut c_void);
		pub fn cv_cuda_StereoBM_compute_const__InputArrayR_const__InputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, left: *const c_void, right: *const c_void, disparity: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_StereoBM_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_StereoBM_to_StereoBM(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_StereoBM_to_StereoMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_StereoBM_delete(instance: *mut c_void);
		pub fn cv_cuda_StereoBeliefPropagation_compute_const__InputArrayR_const__InputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, left: *const c_void, right: *const c_void, disparity: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_StereoBeliefPropagation_compute_const__InputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, data: *const c_void, disparity: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_StereoBeliefPropagation_compute_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, data: *const c_void, disparity: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_StereoBeliefPropagation_getNumIters_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_StereoBeliefPropagation_setNumIters_int(instance: *mut c_void, iters: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_StereoBeliefPropagation_getNumLevels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_StereoBeliefPropagation_setNumLevels_int(instance: *mut c_void, levels: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_StereoBeliefPropagation_getMaxDataTerm_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_StereoBeliefPropagation_setMaxDataTerm_double(instance: *mut c_void, max_data_term: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_StereoBeliefPropagation_getDataWeight_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_StereoBeliefPropagation_setDataWeight_double(instance: *mut c_void, data_weight: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_StereoBeliefPropagation_getMaxDiscTerm_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_StereoBeliefPropagation_setMaxDiscTerm_double(instance: *mut c_void, max_disc_term: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_StereoBeliefPropagation_getDiscSingleJump_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_cuda_StereoBeliefPropagation_setDiscSingleJump_double(instance: *mut c_void, disc_single_jump: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_StereoBeliefPropagation_getMsgType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_StereoBeliefPropagation_setMsgType_int(instance: *mut c_void, msg_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_StereoBeliefPropagation_estimateRecommendedParams_int_int_intR_intR_intR(width: i32, height: i32, ndisp: *mut i32, iters: *mut i32, levels: *mut i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_StereoBeliefPropagation_to_CUDA_StereoConstantSpaceBP(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_StereoBeliefPropagation_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_StereoBeliefPropagation_to_StereoMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_StereoBeliefPropagation_delete(instance: *mut c_void);
		pub fn cv_cuda_StereoConstantSpaceBP_getNrPlane_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_StereoConstantSpaceBP_setNrPlane_int(instance: *mut c_void, nr_plane: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_StereoConstantSpaceBP_getUseLocalInitDataCost_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_cuda_StereoConstantSpaceBP_setUseLocalInitDataCost_bool(instance: *mut c_void, use_local_init_data_cost: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_StereoConstantSpaceBP_estimateRecommendedParams_int_int_intR_intR_intR_intR(width: i32, height: i32, ndisp: *mut i32, iters: *mut i32, levels: *mut i32, nr_plane: *mut i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_StereoConstantSpaceBP_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_StereoConstantSpaceBP_to_CUDA_StereoBeliefPropagation(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_StereoConstantSpaceBP_to_StereoMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_StereoConstantSpaceBP_delete(instance: *mut c_void);
		pub fn cv_cuda_StereoSGM_compute_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, left: *const c_void, right: *const c_void, disparity: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_StereoSGM_compute_const__InputArrayR_const__InputArrayR_const__OutputArrayR_StreamR(instance: *mut c_void, left: *const c_void, right: *const c_void, disparity: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_StereoSGM_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_StereoSGM_to_StereoMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_StereoSGM_to_StereoSGBM(instance: *mut c_void) -> *mut c_void;
		pub fn cv_cuda_StereoSGM_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_DisparityBilateralFilterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_DisparityBilateralFilterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_DisparityBilateralFilterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_DisparityBilateralFilterG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoBMG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoBMG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoBMG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_StereoBMG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoBMG_to_PtrOfStereoBM(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoBMG_to_PtrOfStereoMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoBeliefPropagationG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoBeliefPropagationG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoBeliefPropagationG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_StereoBeliefPropagationG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoBeliefPropagationG_to_PtrOfStereoMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoConstantSpaceBPG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoConstantSpaceBPG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoConstantSpaceBPG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_StereoConstantSpaceBPG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoConstantSpaceBPG_to_PtrOfStereoMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoConstantSpaceBPG_to_PtrOfCUDA_StereoBeliefPropagation(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoSGMG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoSGMG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoSGMG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_StereoSGMG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoSGMG_to_PtrOfStereoMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_StereoSGMG_to_PtrOfStereoSGBM(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_cudastereo)]
pub use cudastereo_sys::*;

#[cfg(ocvrs_has_module_cudawarping)]
mod cudawarping_sys {
	use super::*;

	extern "C" {
		pub fn cv_cuda_buildWarpAffineMaps_Mat_bool_Size_GpuMatR_GpuMatR(m: *mut c_void, inverse: bool, dsize: *const core::Size, xmap: *mut c_void, ymap: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_buildWarpAffineMaps_Mat_bool_Size_GpuMatR_GpuMatR_StreamR(m: *mut c_void, inverse: bool, dsize: *const core::Size, xmap: *mut c_void, ymap: *mut c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_buildWarpAffineMaps_UMat_bool_Size_GpuMatR_GpuMatR(m: *mut c_void, inverse: bool, dsize: *const core::Size, xmap: *mut c_void, ymap: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_buildWarpAffineMaps_UMat_bool_Size_GpuMatR_GpuMatR_StreamR(m: *mut c_void, inverse: bool, dsize: *const core::Size, xmap: *mut c_void, ymap: *mut c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_buildWarpAffineMaps_const__InputArrayR_bool_Size_const__OutputArrayR_const__OutputArrayR(m: *const c_void, inverse: bool, dsize: *const core::Size, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_buildWarpAffineMaps_const__InputArrayR_bool_Size_const__OutputArrayR_const__OutputArrayR_StreamR(m: *const c_void, inverse: bool, dsize: *const core::Size, xmap: *const c_void, ymap: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_buildWarpPerspectiveMaps_Mat_bool_Size_GpuMatR_GpuMatR(m: *mut c_void, inverse: bool, dsize: *const core::Size, xmap: *mut c_void, ymap: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_buildWarpPerspectiveMaps_Mat_bool_Size_GpuMatR_GpuMatR_StreamR(m: *mut c_void, inverse: bool, dsize: *const core::Size, xmap: *mut c_void, ymap: *mut c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_buildWarpPerspectiveMaps_UMat_bool_Size_GpuMatR_GpuMatR(m: *mut c_void, inverse: bool, dsize: *const core::Size, xmap: *mut c_void, ymap: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_buildWarpPerspectiveMaps_UMat_bool_Size_GpuMatR_GpuMatR_StreamR(m: *mut c_void, inverse: bool, dsize: *const core::Size, xmap: *mut c_void, ymap: *mut c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_buildWarpPerspectiveMaps_const__InputArrayR_bool_Size_const__OutputArrayR_const__OutputArrayR(m: *const c_void, inverse: bool, dsize: *const core::Size, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_buildWarpPerspectiveMaps_const__InputArrayR_bool_Size_const__OutputArrayR_const__OutputArrayR_StreamR(m: *const c_void, inverse: bool, dsize: *const core::Size, xmap: *const c_void, ymap: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_pyrDown_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_pyrDown_const__InputArrayR_const__OutputArrayR_StreamR(src: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_pyrUp_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_pyrUp_const__InputArrayR_const__OutputArrayR_StreamR(src: *const c_void, dst: *const c_void, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_remap_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_int(src: *const c_void, dst: *const c_void, xmap: *const c_void, ymap: *const c_void, interpolation: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_remap_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_int_int_Scalar_StreamR(src: *const c_void, dst: *const c_void, xmap: *const c_void, ymap: *const c_void, interpolation: i32, border_mode: i32, border_value: *const core::Scalar, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_resize_const__InputArrayR_const__OutputArrayR_Size(src: *const c_void, dst: *const c_void, dsize: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_resize_const__InputArrayR_const__OutputArrayR_Size_double_double_int_StreamR(src: *const c_void, dst: *const c_void, dsize: *const core::Size, fx: f64, fy: f64, interpolation: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_rotate_const__InputArrayR_const__OutputArrayR_Size_double(src: *const c_void, dst: *const c_void, dsize: *const core::Size, angle: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_rotate_const__InputArrayR_const__OutputArrayR_Size_double_double_double_int_StreamR(src: *const c_void, dst: *const c_void, dsize: *const core::Size, angle: f64, x_shift: f64, y_shift: f64, interpolation: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_warpAffine_const__InputArrayR_const__OutputArrayR_Mat_Size(src: *const c_void, dst: *const c_void, m: *mut c_void, dsize: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_warpAffine_const__InputArrayR_const__OutputArrayR_Mat_Size_int_int_Scalar_StreamR(src: *const c_void, dst: *const c_void, m: *mut c_void, dsize: *const core::Size, flags: i32, border_mode: i32, border_value: *const core::Scalar, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_warpAffine_const__InputArrayR_const__OutputArrayR_UMat_Size(src: *const c_void, dst: *const c_void, m: *mut c_void, dsize: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_warpAffine_const__InputArrayR_const__OutputArrayR_UMat_Size_int_int_Scalar_StreamR(src: *const c_void, dst: *const c_void, m: *mut c_void, dsize: *const core::Size, flags: i32, border_mode: i32, border_value: *const core::Scalar, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_warpAffine_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Size(src: *const c_void, dst: *const c_void, m: *const c_void, dsize: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_warpAffine_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Size_int_int_Scalar_StreamR(src: *const c_void, dst: *const c_void, m: *const c_void, dsize: *const core::Size, flags: i32, border_mode: i32, border_value: *const core::Scalar, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_warpPerspective_const__InputArrayR_const__OutputArrayR_Mat_Size(src: *const c_void, dst: *const c_void, m: *mut c_void, dsize: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_warpPerspective_const__InputArrayR_const__OutputArrayR_Mat_Size_int_int_Scalar_StreamR(src: *const c_void, dst: *const c_void, m: *mut c_void, dsize: *const core::Size, flags: i32, border_mode: i32, border_value: *const core::Scalar, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_warpPerspective_const__InputArrayR_const__OutputArrayR_UMat_Size(src: *const c_void, dst: *const c_void, m: *mut c_void, dsize: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_warpPerspective_const__InputArrayR_const__OutputArrayR_UMat_Size_int_int_Scalar_StreamR(src: *const c_void, dst: *const c_void, m: *mut c_void, dsize: *const core::Size, flags: i32, border_mode: i32, border_value: *const core::Scalar, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_warpPerspective_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Size(src: *const c_void, dst: *const c_void, m: *const c_void, dsize: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_warpPerspective_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Size_int_int_Scalar_StreamR(src: *const c_void, dst: *const c_void, m: *const c_void, dsize: *const core::Size, flags: i32, border_mode: i32, border_value: *const core::Scalar, stream: *mut c_void, ocvrs_return: *mut Result_void);
	}
}
#[cfg(ocvrs_has_module_cudawarping)]
pub use cudawarping_sys::*;

#[cfg(ocvrs_has_module_cvv)]
mod cvv_sys {
	use super::*;

	extern "C" {
		pub fn cvv_impl_debugDMatch_const__InputArrayR_vectorLKeyPointG_const__InputArrayR_vectorLKeyPointG_vectorLDMatchG_const_CallMetaDataR_const_charX_const_charX_bool(img1: *const c_void, keypoints1: *mut c_void, img2: *const c_void, keypoints2: *mut c_void, matches: *mut c_void, data: *const c_void, description: *const c_char, view: *const c_char, use_train_descriptor: bool, ocvrs_return: *mut Result_void);
		pub fn cvv_impl_debugFilter_const__InputArrayR_const__InputArrayR_const_CallMetaDataR_const_charX_const_charX(original: *const c_void, result: *const c_void, data: *const c_void, description: *const c_char, view: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cvv_impl_finalShow(ocvrs_return: *mut Result_void);
		pub fn cvv_impl_showImage_const__InputArrayR_const_CallMetaDataR_const_charX_const_charX(img: *const c_void, data: *const c_void, description: *const c_char, view: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cvv_impl_CallMetaData_CallMetaData(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cvv_impl_CallMetaData_CallMetaData_const_charX_size_t_const_charX(file: *const c_char, line: size_t, function: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cvv_impl_CallMetaData_operator_bool(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cvv_impl_CallMetaData_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cvv_impl_CallMetaData_propFile_const(instance: *const c_void) -> *mut c_void;
		pub fn cvv_impl_CallMetaData_propLine_const(instance: *const c_void) -> size_t;
		pub fn cvv_impl_CallMetaData_propFunction_const(instance: *const c_void) -> *mut c_void;
		pub fn cvv_impl_CallMetaData_propIsKnown_const(instance: *const c_void) -> bool;
		pub fn cvv_impl_CallMetaData_delete(instance: *mut c_void);
	}
}
#[cfg(ocvrs_has_module_cvv)]
pub use cvv_sys::*;

#[cfg(ocvrs_has_module_dnn)]
mod dnn_sys {
	use super::*;

	extern "C" {
		pub fn cv_dnn_NMSBoxesBatched_const_vectorLRect2dGR_const_vectorLfloatGR_const_vectorLintGR_const_float_const_float_vectorLintGR(bboxes: *const c_void, scores: *const c_void, class_ids: *const c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_NMSBoxesBatched_const_vectorLRect2dGR_const_vectorLfloatGR_const_vectorLintGR_const_float_const_float_vectorLintGR_const_float_const_int(bboxes: *const c_void, scores: *const c_void, class_ids: *const c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, eta: f32, top_k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_NMSBoxesBatched_const_vectorLRectGR_const_vectorLfloatGR_const_vectorLintGR_const_float_const_float_vectorLintGR(bboxes: *const c_void, scores: *const c_void, class_ids: *const c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_NMSBoxesBatched_const_vectorLRectGR_const_vectorLfloatGR_const_vectorLintGR_const_float_const_float_vectorLintGR_const_float_const_int(bboxes: *const c_void, scores: *const c_void, class_ids: *const c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, eta: f32, top_k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_NMSBoxes_const_vectorLRect2dGR_const_vectorLfloatGR_const_float_const_float_vectorLintGR(bboxes: *const c_void, scores: *const c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_NMSBoxes_const_vectorLRect2dGR_const_vectorLfloatGR_const_float_const_float_vectorLintGR_const_float_const_int(bboxes: *const c_void, scores: *const c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, eta: f32, top_k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_NMSBoxes_const_vectorLRectGR_const_vectorLfloatGR_const_float_const_float_vectorLintGR(bboxes: *const c_void, scores: *const c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_NMSBoxes_const_vectorLRectGR_const_vectorLfloatGR_const_float_const_float_vectorLintGR_const_float_const_int(bboxes: *const c_void, scores: *const c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, eta: f32, top_k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_NMSBoxes_const_vectorLRotatedRectGR_const_vectorLfloatGR_const_float_const_float_vectorLintGR(bboxes: *const c_void, scores: *const c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_NMSBoxes_const_vectorLRotatedRectGR_const_vectorLfloatGR_const_float_const_float_vectorLintGR_const_float_const_int(bboxes: *const c_void, scores: *const c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, eta: f32, top_k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_blobFromImageWithParams_const__InputArrayR(image: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_blobFromImageWithParams_const__InputArrayR_const_Image2BlobParamsR(image: *const c_void, param: *const crate::dnn::Image2BlobParams, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_blobFromImageWithParams_const__InputArrayR_const__OutputArrayR(image: *const c_void, blob: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_blobFromImageWithParams_const__InputArrayR_const__OutputArrayR_const_Image2BlobParamsR(image: *const c_void, blob: *const c_void, param: *const crate::dnn::Image2BlobParams, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_blobFromImage_const__InputArrayR(image: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_blobFromImage_const__InputArrayR_const__OutputArrayR(image: *const c_void, blob: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_blobFromImage_const__InputArrayR_const__OutputArrayR_double_const_SizeR_const_ScalarR_bool_bool_int(image: *const c_void, blob: *const c_void, scalefactor: f64, size: *const core::Size, mean: *const core::Scalar, swap_rb: bool, crop: bool, ddepth: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_blobFromImage_const__InputArrayR_double_const_SizeR_const_ScalarR_bool_bool_int(image: *const c_void, scalefactor: f64, size: *const core::Size, mean: *const core::Scalar, swap_rb: bool, crop: bool, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_blobFromImagesWithParams_const__InputArrayR(images: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_blobFromImagesWithParams_const__InputArrayR_const_Image2BlobParamsR(images: *const c_void, param: *const crate::dnn::Image2BlobParams, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_blobFromImagesWithParams_const__InputArrayR_const__OutputArrayR(images: *const c_void, blob: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_blobFromImagesWithParams_const__InputArrayR_const__OutputArrayR_const_Image2BlobParamsR(images: *const c_void, blob: *const c_void, param: *const crate::dnn::Image2BlobParams, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_blobFromImages_const__InputArrayR(images: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_blobFromImages_const__InputArrayR_const__OutputArrayR(images: *const c_void, blob: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_blobFromImages_const__InputArrayR_const__OutputArrayR_double_Size_const_ScalarR_bool_bool_int(images: *const c_void, blob: *const c_void, scalefactor: f64, size: *const core::Size, mean: *const core::Scalar, swap_rb: bool, crop: bool, ddepth: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_blobFromImages_const__InputArrayR_double_Size_const_ScalarR_bool_bool_int(images: *const c_void, scalefactor: f64, size: *const core::Size, mean: *const core::Scalar, swap_rb: bool, crop: bool, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_concat_const_MatShapeR_const_MatShapeR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_enableModelDiagnostics_bool(is_diagnostics_mode: bool, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_getAvailableBackends(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_getAvailableTargets_Backend(be: crate::dnn::Backend, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_getInferenceEngineBackendType(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_getInferenceEngineCPUType(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_getInferenceEngineVPUType(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_getPlane_const_MatR_int_int(m: *const c_void, n: i32, cn: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_imagesFromBlob_const_MatR_const__OutputArrayR(blob_: *const c_void, images_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_readNetFromCaffe_const_StringR(prototxt: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromCaffe_const_StringR_const_StringR(prototxt: *const c_char, caffe_model: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromCaffe_const_charX_size_t(buffer_proto: *const c_char, len_proto: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromCaffe_const_charX_size_t_const_charX_size_t(buffer_proto: *const c_char, len_proto: size_t, buffer_model: *const c_char, len_model: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromCaffe_const_vectorLunsigned_charGR(buffer_proto: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromCaffe_const_vectorLunsigned_charGR_const_vectorLunsigned_charGR(buffer_proto: *const c_void, buffer_model: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromDarknet_const_StringR(cfg_file: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromDarknet_const_StringR_const_StringR(cfg_file: *const c_char, darknet_model: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromDarknet_const_charX_size_t(buffer_cfg: *const c_char, len_cfg: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromDarknet_const_charX_size_t_const_charX_size_t(buffer_cfg: *const c_char, len_cfg: size_t, buffer_model: *const c_char, len_model: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromDarknet_const_vectorLunsigned_charGR(buffer_cfg: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromDarknet_const_vectorLunsigned_charGR_const_vectorLunsigned_charGR(buffer_cfg: *const c_void, buffer_model: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromModelOptimizer_const_StringR_const_StringR(xml: *const c_char, bin: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromModelOptimizer_const_unsigned_charX_size_t_const_unsigned_charX_size_t(buffer_model_config_ptr: *const u8, buffer_model_config_size: size_t, buffer_weights_ptr: *const u8, buffer_weights_size: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromModelOptimizer_const_vectorLunsigned_charGR_const_vectorLunsigned_charGR(buffer_model_config: *const c_void, buffer_weights: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromONNX_const_StringR(onnx_file: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromONNX_const_charX_size_t(buffer: *const c_char, size_buffer: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromONNX_const_vectorLunsigned_charGR(buffer: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromTFLite_const_StringR(model: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromTFLite_const_charX_size_t(buffer_model: *const c_char, len_model: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromTFLite_const_vectorLunsigned_charGR(buffer_model: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromTensorflow_const_StringR(model: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromTensorflow_const_StringR_const_StringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromTensorflow_const_charX_size_t(buffer_model: *const c_char, len_model: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromTensorflow_const_charX_size_t_const_charX_size_t(buffer_model: *const c_char, len_model: size_t, buffer_config: *const c_char, len_config: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromTensorflow_const_vectorLunsigned_charGR(buffer_model: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromTensorflow_const_vectorLunsigned_charGR_const_vectorLunsigned_charGR(buffer_model: *const c_void, buffer_config: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromTorch_const_StringR(model: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNetFromTorch_const_StringR_bool_bool(model: *const c_char, is_binary: bool, evaluate: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNet_const_StringR(model: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNet_const_StringR_const_StringR_const_StringR(model: *const c_char, config: *const c_char, framework: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNet_const_StringR_const_vectorLunsigned_charGR(framework: *const c_char, buffer_model: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readNet_const_StringR_const_vectorLunsigned_charGR_const_vectorLunsigned_charGR(framework: *const c_char, buffer_model: *const c_void, buffer_config: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readTensorFromONNX_const_StringR(path: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readTorchBlob_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_readTorchBlob_const_StringR_bool(filename: *const c_char, is_binary: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_releaseHDDLPlugin(ocvrs_return: *mut Result_void);
		pub fn cv_dnn_resetMyriadDevice(ocvrs_return: *mut Result_void);
		pub fn cv_dnn_setInferenceEngineBackendType_const_StringR(new_backend_type: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_shape_const_MatR(mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_shape_const_MatSizeR(sz: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_shape_const_UMatR(mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_shape_const_intX_const_int(dims: *const i32, n: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_shape_int(a0: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_shape_int_int_int_int(a0: i32, a1: i32, a2: i32, a3: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_shrinkCaffeModel_const_StringR_const_StringR(src: *const c_char, dst: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_shrinkCaffeModel_const_StringR_const_StringR_const_vectorLStringGR(src: *const c_char, dst: *const c_char, layers_types: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_slice_const_MatR_const__RangeR(m: *const c_void, r0: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_slice_const_MatR_const__RangeR_const__RangeR(m: *const c_void, r0: *const c_void, r1: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_slice_const_MatR_const__RangeR_const__RangeR_const__RangeR(m: *const c_void, r0: *const c_void, r1: *const c_void, r2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_slice_const_MatR_const__RangeR_const__RangeR_const__RangeR_const__RangeR(m: *const c_void, r0: *const c_void, r1: *const c_void, r2: *const c_void, r3: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_softNMSBoxes_const_vectorLRectGR_const_vectorLfloatGR_vectorLfloatGR_const_float_const_float_vectorLintGR(bboxes: *const c_void, scores: *const c_void, updated_scores: *mut c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_softNMSBoxes_const_vectorLRectGR_const_vectorLfloatGR_vectorLfloatGR_const_float_const_float_vectorLintGR_size_t_const_float_SoftNMSMethod(bboxes: *const c_void, scores: *const c_void, updated_scores: *mut c_void, score_threshold: f32, nms_threshold: f32, indices: *mut c_void, top_k: size_t, sigma: f32, method: crate::dnn::SoftNMSMethod, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_total_const_MatR(mat: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_total_const_MatR_int_int(mat: *const c_void, start: i32, end: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_total_const_MatShapeR(shape: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_total_const_MatShapeR_int_int(shape: *const c_void, start: i32, end: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_writeTextGraph_const_StringR_const_StringR(model: *const c_char, output: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_AbsLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_AbsLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AbsLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AbsLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AbsLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_AccumLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_AccumLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AccumLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AccumLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_AcosLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_AcosLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AcosLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AcosLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AcosLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_AcoshLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_AcoshLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AcoshLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AcoshLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AcoshLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ActivationLayer_forwardSlice_const_const_floatX_floatX_int_size_t_int_int(instance: *const c_void, src: *const f32, dst: *mut f32, len: i32, out_plane_size: size_t, cn0: i32, cn1: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_ActivationLayer_forwardSlice_const_const_intX_const_intX_intX_int_size_t_int_int(instance: *const c_void, src: *const i32, lut: *const i32, dst: *mut i32, len: i32, out_plane_size: size_t, cn0: i32, cn1: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_ActivationLayer_to_AbsLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_AcosLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_AcoshLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_ActivationLayerInt8(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_AsinLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_AsinhLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_AtanLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_AtanhLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_BNLLLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_BatchNormLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_BatchNormLayerInt8(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_CeilLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_CeluLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_ChannelsPReLULayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_CosLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_CoshLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_ELULayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_ErfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_ExpLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_FloorLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_GeluApproximationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_GeluLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_HardSigmoidLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_HardSwishLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_LogLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_MishLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_NotLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_PowerLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_ReLU6Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_ReLULayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_ReciprocalLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_RoundLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_SeluLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_ShrinkLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_SigmoidLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_SignLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_SinLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_SinhLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_SoftplusLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_SoftsignLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_SqrtLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_SwishLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_TanHLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_TanLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_ThresholdedReluLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ActivationLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ActivationLayerInt8_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayerInt8_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayerInt8_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ActivationLayerInt8_delete(instance: *mut c_void);
		pub fn cv_dnn_ArgLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ArgLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ArgLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ArgLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_AsinLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_AsinLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AsinLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AsinLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AsinLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_AsinhLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_AsinhLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AsinhLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AsinhLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AsinhLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_AtanLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_AtanLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AtanLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AtanLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AtanLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_AtanhLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_AtanhLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AtanhLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AtanhLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_AtanhLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_BNLLLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_BNLLLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_BNLLLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_BNLLLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_BNLLLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_BackendNode_propBackendId_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_BackendNode_propBackendId_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_BackendNode_delete(instance: *mut c_void);
		pub fn cv_dnn_BackendWrapper_copyToHost(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_BackendWrapper_setHostDirty(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_BackendWrapper_propBackendId_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_BackendWrapper_propBackendId_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_BackendWrapper_propTargetId_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_BackendWrapper_propTargetId_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_BackendWrapper_delete(instance: *mut c_void);
		pub fn cv_dnn_BaseConvolutionLayer_propKernel_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_propKernel_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_propStride_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_propStride_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_propPad_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_propPad_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_propDilation_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_propDilation_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_propAdjustPad_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_propAdjustPad_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_dnn_BaseConvolutionLayer_propAdjust_pads_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_BaseConvolutionLayer_propAdjust_pads_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_BaseConvolutionLayer_propKernel_size_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_BaseConvolutionLayer_propKernel_size_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_BaseConvolutionLayer_propStrides_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_BaseConvolutionLayer_propStrides_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_BaseConvolutionLayer_propDilations_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_BaseConvolutionLayer_propDilations_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_BaseConvolutionLayer_propPads_begin_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_BaseConvolutionLayer_propPads_begin_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_BaseConvolutionLayer_propPads_end_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_BaseConvolutionLayer_propPads_end_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_BaseConvolutionLayer_propPadMode_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_BaseConvolutionLayer_propPadMode_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_dnn_BaseConvolutionLayer_propNumOutput_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_BaseConvolutionLayer_propNumOutput_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_BaseConvolutionLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_BaseConvolutionLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_BaseConvolutionLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_BatchNormLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_BatchNormLayer_propHasWeights_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_BatchNormLayer_propHasWeights_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_BatchNormLayer_propHasBias_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_BatchNormLayer_propHasBias_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_BatchNormLayer_propEpsilon_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_BatchNormLayer_propEpsilon_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_BatchNormLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_BatchNormLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_BatchNormLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_BatchNormLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_BatchNormLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_BatchNormLayerInt8_propInput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_BatchNormLayerInt8_propInput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_BatchNormLayerInt8_propOutput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_BatchNormLayerInt8_propOutput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_BatchNormLayerInt8_propInput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_BatchNormLayerInt8_propInput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_BatchNormLayerInt8_propOutput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_BatchNormLayerInt8_propOutput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_BatchNormLayerInt8_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_BatchNormLayerInt8_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_BatchNormLayerInt8_to_BatchNormLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_BatchNormLayerInt8_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_BatchNormLayerInt8_delete(instance: *mut c_void);
		pub fn cv_dnn_BlankLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_BlankLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_BlankLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_BlankLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_CeilLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_CeilLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CeilLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CeilLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CeilLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_CeluLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_CeluLayer_propAlpha_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_CeluLayer_propAlpha_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_CeluLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CeluLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CeluLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CeluLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ChannelsPReLULayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ChannelsPReLULayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ChannelsPReLULayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ChannelsPReLULayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ChannelsPReLULayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ClassificationModel_ClassificationModel(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ClassificationModel_ClassificationModel_const_StringR_const_StringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ClassificationModel_ClassificationModel_const_StringR(model: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ClassificationModel_ClassificationModel_const_NetR(network: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ClassificationModel_setEnableSoftmaxPostProcessing_bool(instance: *mut c_void, enable: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ClassificationModel_getEnableSoftmaxPostProcessing_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_ClassificationModel_classify_const__InputArrayR(instance: *mut c_void, frame: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ClassificationModel_classify_const__InputArrayR_intR_floatR(instance: *mut c_void, frame: *const c_void, class_id: *mut i32, conf: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_ClassificationModel_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_ClassificationModel_to_Model(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ClassificationModel_delete(instance: *mut c_void);
		pub fn cv_dnn_CompareLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_CompareLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CompareLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CompareLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ConcatLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ConcatLayer_propAxis_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_ConcatLayer_propAxis_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_ConcatLayer_propPadding_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_ConcatLayer_propPadding_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_ConcatLayer_propPaddingValue_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_ConcatLayer_propPaddingValue_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_ConcatLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ConcatLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ConcatLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ConstLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ConstLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ConstLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ConstLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ConvolutionLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ConvolutionLayer_propFusedActivation_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_ConvolutionLayer_propFusedActivation_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_ConvolutionLayer_propFusedAdd_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_ConvolutionLayer_propFusedAdd_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_ConvolutionLayer_propUseWinograd_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_ConvolutionLayer_propUseWinograd_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_ConvolutionLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ConvolutionLayer_to_BaseConvolutionLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ConvolutionLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ConvolutionLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ConvolutionLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ConvolutionLayerInt8_propInput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_ConvolutionLayerInt8_propInput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_ConvolutionLayerInt8_propOutput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_ConvolutionLayerInt8_propOutput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_ConvolutionLayerInt8_propInput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ConvolutionLayerInt8_propInput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ConvolutionLayerInt8_propOutput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ConvolutionLayerInt8_propOutput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ConvolutionLayerInt8_propPer_channel_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_ConvolutionLayerInt8_propPer_channel_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_ConvolutionLayerInt8_propUseWinograd_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_ConvolutionLayerInt8_propUseWinograd_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_ConvolutionLayerInt8_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ConvolutionLayerInt8_to_BaseConvolutionLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ConvolutionLayerInt8_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ConvolutionLayerInt8_delete(instance: *mut c_void);
		pub fn cv_dnn_CorrelationLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_CorrelationLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CorrelationLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CorrelationLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_CosLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_CosLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CosLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CosLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CosLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_CoshLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_CoshLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CoshLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CoshLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CoshLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_CropAndResizeLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_CropAndResizeLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CropAndResizeLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CropAndResizeLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_CropLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_CropLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CropLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CropLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_CumSumLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_CumSumLayer_propExclusive_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_CumSumLayer_propExclusive_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_CumSumLayer_propReverse_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_CumSumLayer_propReverse_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_CumSumLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CumSumLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_CumSumLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_DataAugmentationLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DataAugmentationLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_DataAugmentationLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_DataAugmentationLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_DeconvolutionLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DeconvolutionLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_DeconvolutionLayer_to_BaseConvolutionLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_DeconvolutionLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_DeconvolutionLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_DequantizeLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DequantizeLayer_propScales_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_DequantizeLayer_propScales_vectorLfloatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_DequantizeLayer_propZeropoints_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_DequantizeLayer_propZeropoints_vectorLintG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_DequantizeLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_DequantizeLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_DequantizeLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_DetectionModel_DetectionModel_const_StringR_const_StringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DetectionModel_DetectionModel_const_StringR(model: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DetectionModel_DetectionModel_const_NetR(network: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DetectionModel_DetectionModel(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DetectionModel_setNmsAcrossClasses_bool(instance: *mut c_void, value: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DetectionModel_getNmsAcrossClasses(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_DetectionModel_detect_const__InputArrayR_vectorLintGR_vectorLfloatGR_vectorLRectGR_float_float(instance: *mut c_void, frame: *const c_void, class_ids: *mut c_void, confidences: *mut c_void, boxes: *mut c_void, conf_threshold: f32, nms_threshold: f32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_DetectionModel_detect_const__InputArrayR_vectorLintGR_vectorLfloatGR_vectorLRectGR(instance: *mut c_void, frame: *const c_void, class_ids: *mut c_void, confidences: *mut c_void, boxes: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_DetectionModel_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_DetectionModel_to_Model(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_DetectionModel_delete(instance: *mut c_void);
		pub fn cv_dnn_DetectionOutputLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DetectionOutputLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_DetectionOutputLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_DetectionOutputLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_Dict_has_const_const_StringR(instance: *const c_void, key: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_Dict_ptr_const_StringR(instance: *mut c_void, key: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Dict_ptr_const_const_StringR(instance: *const c_void, key: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Dict_get_const_const_StringR(instance: *const c_void, key: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Dict_set_const_cv_String_const_StringR_const_StringR(instance: *mut c_void, key: *const c_char, value: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Dict_set_const_cv_dnn_DictValue_const_StringR_const_DictValueR(instance: *mut c_void, key: *const c_char, value: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Dict_set_const_double_const_StringR_const_doubleR(instance: *mut c_void, key: *const c_char, value: *const f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_dnn_Dict_set_const_int64_t_const_StringR_const_int64_tR(instance: *mut c_void, key: *const c_char, value: *const i64, ocvrs_return: *mut Result<i64>);
		pub fn cv_dnn_Dict_erase_const_StringR(instance: *mut c_void, key: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Dict_delete(instance: *mut c_void);
		pub fn cv_dnn_DictValue_DictValue_const_DictValueR(r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_DictValue_bool(i: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_DictValue_int64_t(i: i64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_DictValue(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_DictValue_int(i: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_DictValue_unsigned_int(p: u32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_DictValue_double(p: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_DictValue_const_charX(s: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_get_cv_String_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_get_cv_String_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_get_double_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_dnn_DictValue_get_double_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_dnn_DictValue_get_int_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_DictValue_get_int_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_DictValue_get_int64_t_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<i64>);
		pub fn cv_dnn_DictValue_get_int64_t_const(instance: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_dnn_DictValue_size_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_DictValue_isInt_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_DictValue_isString_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_DictValue_isReal_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_DictValue_getIntValue_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_DictValue_getIntValue_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_DictValue_getRealValue_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_dnn_DictValue_getRealValue_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_dnn_DictValue_getStringValue_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_getStringValue_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_DictValue_operatorST_const_DictValueR(instance: *mut c_void, r: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_DictValue_delete(instance: *mut c_void);
		pub fn cv_dnn_ELULayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ELULayer_propAlpha_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ELULayer_propAlpha_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ELULayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ELULayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ELULayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ELULayer_delete(instance: *mut c_void);
		pub fn cv_dnn_EltwiseLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_EltwiseLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_EltwiseLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_EltwiseLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_EltwiseLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_EltwiseLayerInt8_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_EltwiseLayerInt8_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_EltwiseLayerInt8_delete(instance: *mut c_void);
		pub fn cv_dnn_ErfLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ErfLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ErfLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ErfLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ErfLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ExpLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ExpLayer_propBase_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ExpLayer_propBase_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ExpLayer_propScale_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ExpLayer_propScale_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ExpLayer_propShift_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ExpLayer_propShift_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ExpLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ExpLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ExpLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ExpLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_FlattenLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_FlattenLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_FlattenLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_FlattenLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_FloorLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_FloorLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_FloorLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_FloorLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_FloorLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_FlowWarpLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_FlowWarpLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_FlowWarpLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_FlowWarpLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_GRULayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_GRULayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_GRULayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_GRULayer_delete(instance: *mut c_void);
		pub fn cv_dnn_GatherLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_GatherLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_GatherLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_GatherLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_GeluApproximationLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_GeluApproximationLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_GeluApproximationLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_GeluApproximationLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_GeluApproximationLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_GeluLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_GeluLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_GeluLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_GeluLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_GeluLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_HardSigmoidLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_HardSigmoidLayer_propAlpha_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_HardSigmoidLayer_propAlpha_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_HardSigmoidLayer_propBeta_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_HardSigmoidLayer_propBeta_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_HardSigmoidLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_HardSigmoidLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_HardSigmoidLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_HardSigmoidLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_HardSwishLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_HardSwishLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_HardSwishLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_HardSwishLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_HardSwishLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_Image2BlobParams_Image2BlobParams(ocvrs_return: *mut Result<crate::dnn::Image2BlobParams>);
		pub fn cv_dnn_Image2BlobParams_Image2BlobParams_const_ScalarR_const_SizeR_const_ScalarR_bool_int_DataLayout_ImagePaddingMode(scalefactor: *const core::Scalar, size: *const core::Size, mean: *const core::Scalar, swap_rb: bool, ddepth: i32, datalayout: crate::dnn::DataLayout, mode: crate::dnn::ImagePaddingMode, ocvrs_return: *mut Result<crate::dnn::Image2BlobParams>);
		pub fn cv_dnn_Image2BlobParams_Image2BlobParams_const_ScalarR(scalefactor: *const core::Scalar, ocvrs_return: *mut Result<crate::dnn::Image2BlobParams>);
		pub fn cv_dnn_InnerProductLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_InnerProductLayer_propAxis_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_InnerProductLayer_propAxis_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_InnerProductLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_InnerProductLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_InnerProductLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_InnerProductLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_InnerProductLayerInt8_propInput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_InnerProductLayerInt8_propInput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_InnerProductLayerInt8_propOutput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_InnerProductLayerInt8_propOutput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_InnerProductLayerInt8_propInput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_InnerProductLayerInt8_propInput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_InnerProductLayerInt8_propOutput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_InnerProductLayerInt8_propOutput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_InnerProductLayerInt8_propPer_channel_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_InnerProductLayerInt8_propPer_channel_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_InnerProductLayerInt8_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_InnerProductLayerInt8_to_InnerProductLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_InnerProductLayerInt8_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_InnerProductLayerInt8_delete(instance: *mut c_void);
		pub fn cv_dnn_InterpLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_InterpLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_InterpLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_InterpLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_KeypointsModel_KeypointsModel_const_StringR_const_StringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_KeypointsModel_KeypointsModel_const_StringR(model: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_KeypointsModel_KeypointsModel_const_NetR(network: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_KeypointsModel_estimate_const__InputArrayR_float(instance: *mut c_void, frame: *const c_void, thresh: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_KeypointsModel_estimate_const__InputArrayR(instance: *mut c_void, frame: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_KeypointsModel_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_KeypointsModel_to_Model(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_KeypointsModel_delete(instance: *mut c_void);
		pub fn cv_dnn_LRNLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_LRNLayer_propType_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_LRNLayer_propType_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_LRNLayer_propSize_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_LRNLayer_propSize_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_LRNLayer_propAlpha_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_LRNLayer_propAlpha_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_LRNLayer_propBeta_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_LRNLayer_propBeta_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_LRNLayer_propBias_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_LRNLayer_propBias_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_LRNLayer_propNormBySize_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_LRNLayer_propNormBySize_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_LRNLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_LRNLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_LRNLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_LSTMLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_LSTMLayer_setWeights_const_MatR_const_MatR_const_MatR(instance: *mut c_void, wh: *const c_void, wx: *const c_void, b: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_LSTMLayer_setOutShape_const_MatShapeR(instance: *mut c_void, out_tail_shape: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_LSTMLayer_setOutShape(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_LSTMLayer_setUseTimstampsDim_bool(instance: *mut c_void, use_: bool, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_LSTMLayer_setUseTimstampsDim(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_LSTMLayer_setProduceCellOutput_bool(instance: *mut c_void, produce: bool, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_LSTMLayer_setProduceCellOutput(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_LSTMLayer_inputNameToIndex_String(instance: *mut c_void, input_name: *mut c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_LSTMLayer_outputNameToIndex_const_StringR(instance: *mut c_void, output_name: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_LSTMLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_LSTMLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_LSTMLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_Layer_finalize_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, inputs: *const c_void, outputs: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_forward_vectorLMatXGR_vectorLMatGR_vectorLMatGR(instance: *mut c_void, input: *mut c_void, output: *mut c_void, internals: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_forward_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, inputs: *const c_void, outputs: *const c_void, internals: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_tryQuantize_const_vectorLvectorLfloatGGR_const_vectorLvectorLintGGR_LayerParamsR(instance: *mut c_void, scales: *const c_void, zeropoints: *const c_void, params: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_Layer_forward_fallback_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, inputs: *const c_void, outputs: *const c_void, internals: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_finalize_const_vectorLMatGR_vectorLMatGR(instance: *mut c_void, inputs: *const c_void, outputs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_finalize_const_vectorLMatGR(instance: *mut c_void, inputs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_run_const_vectorLMatGR_vectorLMatGR_vectorLMatGR(instance: *mut c_void, inputs: *const c_void, outputs: *mut c_void, internals: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_inputNameToIndex_String(instance: *mut c_void, input_name: *mut c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Layer_outputNameToIndex_const_StringR(instance: *mut c_void, output_name: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Layer_supportBackend_int(instance: *mut c_void, backend_id: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_Layer_initHalide_const_vectorLPtrLBackendWrapperGGR(instance: *mut c_void, inputs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_initNgraph_const_vectorLPtrLBackendWrapperGGR_const_vectorLPtrLBackendNodeGGR(instance: *mut c_void, inputs: *const c_void, nodes: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_initVkCom_const_vectorLPtrLBackendWrapperGGR_vectorLPtrLBackendWrapperGGR(instance: *mut c_void, inputs: *const c_void, outputs: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_initWebnn_const_vectorLPtrLBackendWrapperGGR_const_vectorLPtrLBackendNodeGGR(instance: *mut c_void, inputs: *const c_void, nodes: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_initCUDA_voidX_const_vectorLPtrLBackendWrapperGGR_const_vectorLPtrLBackendWrapperGGR(instance: *mut c_void, context: *mut c_void, inputs: *const c_void, outputs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_initTimVX_voidX_const_vectorLPtrLBackendWrapperGGR_const_vectorLPtrLBackendWrapperGGR_bool(instance: *mut c_void, tim_vx_info: *mut c_void, inputs_wrapper: *const c_void, outputs_wrapper: *const c_void, is_last: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_initCann_const_vectorLPtrLBackendWrapperGGR_const_vectorLPtrLBackendWrapperGGR_const_vectorLPtrLBackendNodeGGR(instance: *mut c_void, inputs: *const c_void, outputs: *const c_void, nodes: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_applyHalideScheduler_const_PtrLBackendNodeGR_const_vectorLMatXGR_const_vectorLMatGR_int(instance: *const c_void, node: *mut c_void, inputs: *const c_void, outputs: *const c_void, target_id: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_tryAttach_const_PtrLBackendNodeGR(instance: *mut c_void, node: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_setActivation_const_PtrLActivationLayerGR(instance: *mut c_void, layer: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_Layer_tryFuse_PtrLLayerGR(instance: *mut c_void, top: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_Layer_getScaleShift_const_MatR_MatR(instance: *const c_void, scale: *mut c_void, shift: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_getScaleZeropoint_const_floatR_intR(instance: *const c_void, scale: *mut f32, zeropoint: *mut i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_unsetAttached(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_getMemoryShapes_const_const_vectorLMatShapeGR_const_int_vectorLMatShapeGR_vectorLMatShapeGR(instance: *const c_void, inputs: *const c_void, required_outputs: i32, outputs: *mut c_void, internals: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_Layer_getFLOPS_const_const_vectorLMatShapeGR_const_vectorLMatShapeGR(instance: *const c_void, inputs: *const c_void, outputs: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_dnn_Layer_updateMemoryShapes_const_vectorLMatShapeGR(instance: *mut c_void, inputs: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_Layer_Layer(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_Layer_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Layer_setParamsFrom_const_LayerParamsR(instance: *mut c_void, params: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Layer_propBlobs_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_propBlobs_vectorLMatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_Layer_propName_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_propName_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_dnn_Layer_propType_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_propType_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_dnn_Layer_propPreferableTarget_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_Layer_propPreferableTarget_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_Layer_to_AbsLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_AccumLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_AcosLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_AcoshLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ActivationLayerInt8(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ArgLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_AsinLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_AsinhLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_AtanLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_AtanhLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_BNLLLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_BaseConvolutionLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_BatchNormLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_BatchNormLayerInt8(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_BlankLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_CeilLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_CeluLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ChannelsPReLULayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_CompareLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ConcatLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ConstLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ConvolutionLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ConvolutionLayerInt8(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_CorrelationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_CosLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_CoshLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_CropAndResizeLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_CropLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_CumSumLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_DataAugmentationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_DeconvolutionLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_DequantizeLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_DetectionOutputLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ELULayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_EltwiseLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_EltwiseLayerInt8(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ErfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ExpLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_FlattenLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_FloorLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_FlowWarpLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_GRULayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_GatherLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_GeluApproximationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_GeluLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_HardSigmoidLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_HardSwishLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_InnerProductLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_InnerProductLayerInt8(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_InterpLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_LRNLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_LSTMLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_LayerNormLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_LogLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_MVNLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_MaxUnpoolLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_MishLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_NaryEltwiseLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_NormalizeBBoxLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_NotLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_PaddingLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_PermuteLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_PoolingLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_PoolingLayerInt8(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_PowerLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_PriorBoxLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ProposalLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_QuantizeLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_RNNLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ReLU6Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ReLULayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ReciprocalLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ReduceLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_RegionLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ReorgLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_RequantizeLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ReshapeLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ResizeLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_RoundLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ScaleLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ScaleLayerInt8(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ScatterLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ScatterNDLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_SeluLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ShiftLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ShiftLayerInt8(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ShrinkLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ShuffleChannelLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_SigmoidLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_SignLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_SinLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_SinhLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_SliceLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_SoftmaxLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_SoftmaxLayerInt8(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_SoftplusLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_SoftsignLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_SplitLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_SqrtLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_SwishLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_TanHLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_TanLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_ThresholdedReluLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_TileLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Layer_delete(instance: *mut c_void);
		pub fn cv_dnn_LayerFactory_registerLayer_const_StringR_Constructor(typ: *const c_char, constructor: Option<unsafe extern "C" fn(*mut c_void) -> *mut c_void>, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_LayerFactory_unregisterLayer_const_StringR(typ: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_LayerFactory_isLayerRegistered_const_stringR(typ: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_LayerFactory_createLayerInstance_const_StringR_LayerParamsR(typ: *const c_char, params: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_LayerFactory_delete(instance: *mut c_void);
		pub fn cv_dnn_LayerNormLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_LayerNormLayer_propHasBias_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_LayerNormLayer_propHasBias_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_LayerNormLayer_propAxis_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_LayerNormLayer_propAxis_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_LayerNormLayer_propEpsilon_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_LayerNormLayer_propEpsilon_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_LayerNormLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_LayerNormLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_LayerNormLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_LayerParams_new_const(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_LayerParams_propBlobs_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_LayerParams_propBlobs_vectorLMatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_LayerParams_propName_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_LayerParams_propName_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_dnn_LayerParams_propType_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_LayerParams_propType_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_dnn_LayerParams_to_Dict(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_LayerParams_delete(instance: *mut c_void);
		pub fn cv_dnn_LogLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_LogLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_LogLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_LogLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_LogLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_MVNLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_MVNLayer_propEps_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_MVNLayer_propEps_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_MVNLayer_propNormVariance_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_MVNLayer_propNormVariance_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_MVNLayer_propAcrossChannels_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_MVNLayer_propAcrossChannels_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_MVNLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_MVNLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_MVNLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_MaxUnpoolLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_MaxUnpoolLayer_propPoolKernel_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_dnn_MaxUnpoolLayer_propPoolKernel_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_dnn_MaxUnpoolLayer_propPoolPad_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_dnn_MaxUnpoolLayer_propPoolPad_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_dnn_MaxUnpoolLayer_propPoolStride_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_dnn_MaxUnpoolLayer_propPoolStride_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_dnn_MaxUnpoolLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_MaxUnpoolLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_MaxUnpoolLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_MishLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_MishLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_MishLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_MishLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_MishLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_Model_Model(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_Model_const_ModelR(unnamed: *const c_void) -> *mut c_void;
		pub fn cv_dnn_Model_Model_ModelRR(unnamed: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_Model_operatorST_const_ModelR(instance: *mut c_void, unnamed: *const c_void);
		pub fn cv_dnn_Model_operatorST_ModelRR(instance: *mut c_void, unnamed: *mut c_void);
		pub fn cv_dnn_Model_Model_const_StringR_const_StringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_Model_const_StringR(model: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_Model_const_NetR(network: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_setInputSize_const_SizeR(instance: *mut c_void, size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_setInputSize_int_int(instance: *mut c_void, width: i32, height: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_setInputMean_const_ScalarR(instance: *mut c_void, mean: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_setInputScale_const_ScalarR(instance: *mut c_void, scale: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_setInputCrop_bool(instance: *mut c_void, crop: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_setInputSwapRB_bool(instance: *mut c_void, swap_rb: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_setInputParams_double_const_SizeR_const_ScalarR_bool_bool(instance: *mut c_void, scale: f64, size: *const core::Size, mean: *const core::Scalar, swap_rb: bool, crop: bool, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Model_setInputParams(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Model_predict_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, frame: *const c_void, outs: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Model_setPreferableBackend_Backend(instance: *mut c_void, backend_id: crate::dnn::Backend, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_setPreferableTarget_Target(instance: *mut c_void, target_id: crate::dnn::Target, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_getNetwork__const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_getNetwork_(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Model_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_Model_delete(instance: *mut c_void);
		pub fn cv_dnn_NaryEltwiseLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_NaryEltwiseLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_NaryEltwiseLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_NaryEltwiseLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_Net_Net(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_readFromModelOptimizer_const_StringR_const_StringR(xml: *const c_char, bin: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_readFromModelOptimizer_const_vectorLunsigned_charGR_const_vectorLunsigned_charGR(buffer_model_config: *const c_void, buffer_weights: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_readFromModelOptimizer_const_unsigned_charX_size_t_const_unsigned_charX_size_t(buffer_model_config_ptr: *const u8, buffer_model_config_size: size_t, buffer_weights_ptr: *const u8, buffer_weights_size: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dnn_Net_dump(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_dumpToFile_const_StringR(instance: *mut c_void, path: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_addLayer_const_StringR_const_StringR_const_intR_LayerParamsR(instance: *mut c_void, name: *const c_char, typ: *const c_char, dtype: *const i32, params: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Net_addLayer_const_StringR_const_StringR_LayerParamsR(instance: *mut c_void, name: *const c_char, typ: *const c_char, params: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Net_addLayerToPrev_const_StringR_const_StringR_const_intR_LayerParamsR(instance: *mut c_void, name: *const c_char, typ: *const c_char, dtype: *const i32, params: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Net_addLayerToPrev_const_StringR_const_StringR_LayerParamsR(instance: *mut c_void, name: *const c_char, typ: *const c_char, params: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Net_getLayerId_const_const_StringR(instance: *const c_void, layer: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Net_getLayerNames_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getLayer_const_int(instance: *const c_void, layer_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getLayer_const_const_StringR(instance: *const c_void, layer_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getLayer_const_const_LayerIdR(instance: *const c_void, layer_id: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getLayerInputs_const_int(instance: *const c_void, layer_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_connect_String_String(instance: *mut c_void, out_pin: *mut c_char, inp_pin: *mut c_char, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_connect_int_int_int_int(instance: *mut c_void, out_layer_id: i32, out_num: i32, inp_layer_id: i32, inp_num: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_registerOutput_const_stringR_int_int(instance: *mut c_void, output_name: *const c_char, layer_id: i32, output_port: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Net_setInputsNames_const_vectorLStringGR(instance: *mut c_void, input_blob_names: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_setInputShape_const_StringR_const_MatShapeR(instance: *mut c_void, input_name: *const c_char, shape: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_forward_const_StringR(instance: *mut c_void, output_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_forward(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_forwardAsync_const_StringR(instance: *mut c_void, output_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_forwardAsync(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_forward_const__OutputArrayR_const_StringR(instance: *mut c_void, output_blobs: *const c_void, output_name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_forward_const__OutputArrayR(instance: *mut c_void, output_blobs: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_forward_const__OutputArrayR_const_vectorLStringGR(instance: *mut c_void, output_blobs: *const c_void, out_blob_names: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_forward_vectorLvectorLMatGGR_const_vectorLStringGR(instance: *mut c_void, output_blobs: *mut c_void, out_blob_names: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_quantize_const__InputArrayR_int_int_bool(instance: *mut c_void, calib_data: *const c_void, inputs_dtype: i32, outputs_dtype: i32, per_channel: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_quantize_const__InputArrayR_int_int(instance: *mut c_void, calib_data: *const c_void, inputs_dtype: i32, outputs_dtype: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getInputDetails_const_vectorLfloatGR_vectorLintGR(instance: *const c_void, scales: *mut c_void, zeropoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getOutputDetails_const_vectorLfloatGR_vectorLintGR(instance: *const c_void, scales: *mut c_void, zeropoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_setHalideScheduler_const_StringR(instance: *mut c_void, scheduler: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_setPreferableBackend_int(instance: *mut c_void, backend_id: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_setPreferableTarget_int(instance: *mut c_void, target_id: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_setInput_const__InputArrayR_const_StringR_double_const_ScalarR(instance: *mut c_void, blob: *const c_void, name: *const c_char, scalefactor: f64, mean: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_setInput_const__InputArrayR(instance: *mut c_void, blob: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_setParam_int_int_const_MatR(instance: *mut c_void, layer: i32, num_param: i32, blob: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_setParam_const_StringR_int_const_MatR(instance: *mut c_void, layer_name: *const c_char, num_param: i32, blob: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getParam_const_int_int(instance: *const c_void, layer: i32, num_param: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getParam_const_int(instance: *const c_void, layer: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getParam_const_const_StringR_int(instance: *const c_void, layer_name: *const c_char, num_param: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getParam_const_const_StringR(instance: *const c_void, layer_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getUnconnectedOutLayers_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getUnconnectedOutLayersNames_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_Net_getLayersShapes_const_const_vectorLMatShapeGR_vectorLintGR_vectorLvectorLMatShapeGGR_vectorLvectorLMatShapeGGR(instance: *const c_void, net_input_shapes: *const c_void, layers_ids: *mut c_void, in_layers_shapes: *mut c_void, out_layers_shapes: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getLayersShapes_const_const_MatShapeR_vectorLintGR_vectorLvectorLMatShapeGGR_vectorLvectorLMatShapeGGR(instance: *const c_void, net_input_shape: *const c_void, layers_ids: *mut c_void, in_layers_shapes: *mut c_void, out_layers_shapes: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getLayerShapes_const_const_MatShapeR_const_int_vectorLMatShapeGR_vectorLMatShapeGR(instance: *const c_void, net_input_shape: *const c_void, layer_id: i32, in_layer_shapes: *mut c_void, out_layer_shapes: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getLayerShapes_const_const_vectorLMatShapeGR_const_int_vectorLMatShapeGR_vectorLMatShapeGR(instance: *const c_void, net_input_shapes: *const c_void, layer_id: i32, in_layer_shapes: *mut c_void, out_layer_shapes: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getFLOPS_const_const_vectorLMatShapeGR(instance: *const c_void, net_input_shapes: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_dnn_Net_getFLOPS_const_const_MatShapeR(instance: *const c_void, net_input_shape: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_dnn_Net_getFLOPS_const_const_int_const_vectorLMatShapeGR(instance: *const c_void, layer_id: i32, net_input_shapes: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_dnn_Net_getFLOPS_const_const_int_const_MatShapeR(instance: *const c_void, layer_id: i32, net_input_shape: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_dnn_Net_getLayerTypes_const_vectorLStringGR(instance: *const c_void, layers_types: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getLayersCount_const_const_StringR(instance: *const c_void, layer_type: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_Net_getMemoryConsumption_const_const_vectorLMatShapeGR_size_tR_size_tR(instance: *const c_void, net_input_shapes: *const c_void, weights: *mut size_t, blobs: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getMemoryConsumption_const_const_MatShapeR_size_tR_size_tR(instance: *const c_void, net_input_shape: *const c_void, weights: *mut size_t, blobs: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getMemoryConsumption_const_const_int_const_vectorLMatShapeGR_size_tR_size_tR(instance: *const c_void, layer_id: i32, net_input_shapes: *const c_void, weights: *mut size_t, blobs: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getMemoryConsumption_const_const_int_const_MatShapeR_size_tR_size_tR(instance: *const c_void, layer_id: i32, net_input_shape: *const c_void, weights: *mut size_t, blobs: *mut size_t, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getMemoryConsumption_const_const_vectorLMatShapeGR_vectorLintGR_vectorLsize_tGR_vectorLsize_tGR(instance: *const c_void, net_input_shapes: *const c_void, layer_ids: *mut c_void, weights: *mut c_void, blobs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getMemoryConsumption_const_const_MatShapeR_vectorLintGR_vectorLsize_tGR_vectorLsize_tGR(instance: *const c_void, net_input_shape: *const c_void, layer_ids: *mut c_void, weights: *mut c_void, blobs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_enableFusion_bool(instance: *mut c_void, fusion: bool, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_enableWinograd_bool(instance: *mut c_void, use_winograd: bool, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_Net_getPerfProfile_vectorLdoubleGR(instance: *mut c_void, timings: *mut c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_dnn_Net_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_Net_delete(instance: *mut c_void);
		pub fn cv_dnn_NormalizeBBoxLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_NormalizeBBoxLayer_propPnorm_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_NormalizeBBoxLayer_propPnorm_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_NormalizeBBoxLayer_propEpsilon_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_NormalizeBBoxLayer_propEpsilon_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_NormalizeBBoxLayer_propAcrossSpatial_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_NormalizeBBoxLayer_propAcrossSpatial_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_NormalizeBBoxLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_NormalizeBBoxLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_NormalizeBBoxLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_NotLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_NotLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_NotLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_NotLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_NotLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_PaddingLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_PaddingLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_PaddingLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_PaddingLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_PermuteLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_PermuteLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_PermuteLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_PermuteLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_PoolingLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_PoolingLayer_propType_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_PoolingLayer_propType_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_PoolingLayer_propKernel_size_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_PoolingLayer_propKernel_size_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_PoolingLayer_propStrides_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_PoolingLayer_propStrides_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_PoolingLayer_propPads_begin_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_PoolingLayer_propPads_begin_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_PoolingLayer_propPads_end_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_PoolingLayer_propPads_end_vectorLsize_tG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_PoolingLayer_propGlobalPooling_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_PoolingLayer_propGlobalPooling_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_PoolingLayer_propIsGlobalPooling_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_PoolingLayer_propIsGlobalPooling_vectorLboolG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_PoolingLayer_propComputeMaxIdx_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_PoolingLayer_propComputeMaxIdx_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_PoolingLayer_propPadMode_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_PoolingLayer_propPadMode_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_dnn_PoolingLayer_propCeilMode_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_PoolingLayer_propCeilMode_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_PoolingLayer_propAvePoolPaddedArea_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_PoolingLayer_propAvePoolPaddedArea_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_PoolingLayer_propPooledSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_dnn_PoolingLayer_propPooledSize_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_dnn_PoolingLayer_propSpatialScale_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_PoolingLayer_propSpatialScale_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_PoolingLayer_propPsRoiOutChannels_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_PoolingLayer_propPsRoiOutChannels_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_PoolingLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_PoolingLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_PoolingLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_PoolingLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_PoolingLayerInt8_propInput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_PoolingLayerInt8_propInput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_PoolingLayerInt8_propOutput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_PoolingLayerInt8_propOutput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_PoolingLayerInt8_propInput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_PoolingLayerInt8_propInput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_PoolingLayerInt8_propOutput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_PoolingLayerInt8_propOutput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_PoolingLayerInt8_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_PoolingLayerInt8_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_PoolingLayerInt8_to_PoolingLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_PoolingLayerInt8_delete(instance: *mut c_void);
		pub fn cv_dnn_PowerLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_PowerLayer_propPower_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_PowerLayer_propPower_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_PowerLayer_propScale_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_PowerLayer_propScale_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_PowerLayer_propShift_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_PowerLayer_propShift_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_PowerLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_PowerLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_PowerLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_PowerLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_PriorBoxLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_PriorBoxLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_PriorBoxLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_PriorBoxLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ProposalLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ProposalLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ProposalLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ProposalLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_QuantizeLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_QuantizeLayer_propScales_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_QuantizeLayer_propScales_vectorLfloatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_QuantizeLayer_propZeropoints_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_QuantizeLayer_propZeropoints_vectorLintG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_QuantizeLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_QuantizeLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_QuantizeLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_RNNLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_RNNLayer_setWeights_const_MatR_const_MatR_const_MatR_const_MatR_const_MatR(instance: *mut c_void, wxh: *const c_void, bh: *const c_void, whh: *const c_void, who: *const c_void, bo: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_RNNLayer_setProduceHiddenOutput_bool(instance: *mut c_void, produce: bool, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_RNNLayer_setProduceHiddenOutput(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_RNNLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_RNNLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_RNNLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ReLU6Layer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ReLU6Layer_propMinValue_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ReLU6Layer_propMinValue_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ReLU6Layer_propMaxValue_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ReLU6Layer_propMaxValue_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ReLU6Layer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ReLU6Layer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ReLU6Layer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ReLU6Layer_delete(instance: *mut c_void);
		pub fn cv_dnn_ReLULayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ReLULayer_propNegativeSlope_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ReLULayer_propNegativeSlope_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ReLULayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ReLULayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ReLULayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ReLULayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ReciprocalLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ReciprocalLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ReciprocalLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ReciprocalLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ReciprocalLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ReduceLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ReduceLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ReduceLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ReduceLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_RegionLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_RegionLayer_propNmsThreshold_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_RegionLayer_propNmsThreshold_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_RegionLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_RegionLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_RegionLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ReorgLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ReorgLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ReorgLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ReorgLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_RequantizeLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_RequantizeLayer_propScale_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_RequantizeLayer_propScale_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_RequantizeLayer_propShift_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_RequantizeLayer_propShift_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_RequantizeLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_RequantizeLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_RequantizeLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ReshapeLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ReshapeLayer_propNewShapeDesc_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_ReshapeLayer_propNewShapeDesc_MatShape(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_ReshapeLayer_propNewShapeRange_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_ReshapeLayer_propNewShapeRange_Range(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_ReshapeLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ReshapeLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ReshapeLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ResizeLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ResizeLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ResizeLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ResizeLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_RoundLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_RoundLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_RoundLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_RoundLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_RoundLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ScaleLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ScaleLayer_propHasBias_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_ScaleLayer_propHasBias_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_ScaleLayer_propAxis_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_ScaleLayer_propAxis_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_ScaleLayer_propMode_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_ScaleLayer_propMode_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_dnn_ScaleLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ScaleLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ScaleLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ScaleLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ScaleLayerInt8_propOutput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ScaleLayerInt8_propOutput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ScaleLayerInt8_propOutput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_ScaleLayerInt8_propOutput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_ScaleLayerInt8_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ScaleLayerInt8_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ScaleLayerInt8_to_ScaleLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ScaleLayerInt8_delete(instance: *mut c_void);
		pub fn cv_dnn_ScatterLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ScatterLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ScatterLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ScatterLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ScatterNDLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ScatterNDLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ScatterNDLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ScatterNDLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_SegmentationModel_SegmentationModel_const_StringR_const_StringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SegmentationModel_SegmentationModel_const_StringR(model: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SegmentationModel_SegmentationModel_const_NetR(network: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SegmentationModel_segment_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, frame: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_SegmentationModel_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_SegmentationModel_to_Model(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SegmentationModel_delete(instance: *mut c_void);
		pub fn cv_dnn_SeluLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SeluLayer_propAlpha_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_SeluLayer_propAlpha_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_SeluLayer_propGamma_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_SeluLayer_propGamma_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_SeluLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SeluLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SeluLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SeluLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ShiftLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ShiftLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ShiftLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ShiftLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ShiftLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ShiftLayerInt8_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ShiftLayerInt8_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ShiftLayerInt8_delete(instance: *mut c_void);
		pub fn cv_dnn_ShrinkLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ShrinkLayer_propBias_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ShrinkLayer_propBias_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ShrinkLayer_propLambd_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ShrinkLayer_propLambd_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ShrinkLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ShrinkLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ShrinkLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ShrinkLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_ShuffleChannelLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ShuffleChannelLayer_propGroup_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_ShuffleChannelLayer_propGroup_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_ShuffleChannelLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ShuffleChannelLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ShuffleChannelLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_SigmoidLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SigmoidLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SigmoidLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SigmoidLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SigmoidLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_SignLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SignLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SignLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SignLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SignLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_SinLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SinLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SinLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SinLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SinLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_SinhLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SinhLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SinhLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SinhLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SinhLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_SliceLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SliceLayer_propSliceRanges_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_SliceLayer_propSliceRanges_vectorLvectorLRangeGG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_SliceLayer_propSliceSteps_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_SliceLayer_propSliceSteps_vectorLvectorLintGG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_dnn_SliceLayer_propAxis_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_SliceLayer_propAxis_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_SliceLayer_propNum_split_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_SliceLayer_propNum_split_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_SliceLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SliceLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SliceLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_SoftmaxLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SoftmaxLayer_propLogSoftMax_const(instance: *const c_void) -> bool;
		pub fn cv_dnn_SoftmaxLayer_propLogSoftMax_bool(instance: *mut c_void, val: bool);
		pub fn cv_dnn_SoftmaxLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SoftmaxLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SoftmaxLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_SoftmaxLayerInt8_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SoftmaxLayerInt8_propOutput_sc_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_SoftmaxLayerInt8_propOutput_sc_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_SoftmaxLayerInt8_propOutput_zp_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_SoftmaxLayerInt8_propOutput_zp_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_SoftmaxLayerInt8_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SoftmaxLayerInt8_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SoftmaxLayerInt8_to_SoftmaxLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SoftmaxLayerInt8_delete(instance: *mut c_void);
		pub fn cv_dnn_SoftplusLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SoftplusLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SoftplusLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SoftplusLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SoftplusLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_SoftsignLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SoftsignLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SoftsignLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SoftsignLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SoftsignLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_SplitLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SplitLayer_propOutputsCount_const(instance: *const c_void) -> i32;
		pub fn cv_dnn_SplitLayer_propOutputsCount_int(instance: *mut c_void, val: i32);
		pub fn cv_dnn_SplitLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SplitLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SplitLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_SqrtLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SqrtLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SqrtLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SqrtLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SqrtLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_SwishLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_SwishLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SwishLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SwishLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_SwishLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_TanHLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TanHLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_TanHLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_TanHLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_TanHLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_TanLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TanLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_TanLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_TanLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_TanLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_TextDetectionModel_detect_const_const__InputArrayR_vectorLvectorLPointGGR_vectorLfloatGR(instance: *const c_void, frame: *const c_void, detections: *mut c_void, confidences: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_TextDetectionModel_detect_const_const__InputArrayR_vectorLvectorLPointGGR(instance: *const c_void, frame: *const c_void, detections: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_TextDetectionModel_detectTextRectangles_const_const__InputArrayR_vectorLRotatedRectGR_vectorLfloatGR(instance: *const c_void, frame: *const c_void, detections: *mut c_void, confidences: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_TextDetectionModel_detectTextRectangles_const_const__InputArrayR_vectorLRotatedRectGR(instance: *const c_void, frame: *const c_void, detections: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_TextDetectionModel_to_Model(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_TextDetectionModel_delete(instance: *mut c_void);
		pub fn cv_dnn_TextDetectionModel_DB_TextDetectionModel_DB(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_DB_TextDetectionModel_DB_const_NetR(network: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_DB_TextDetectionModel_DB_const_stringR_const_stringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_DB_TextDetectionModel_DB_const_stringR(model: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_DB_setBinaryThreshold_float(instance: *mut c_void, binary_threshold: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_DB_getBinaryThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_dnn_TextDetectionModel_DB_setPolygonThreshold_float(instance: *mut c_void, polygon_threshold: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_DB_getPolygonThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_dnn_TextDetectionModel_DB_setUnclipRatio_double(instance: *mut c_void, unclip_ratio: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_DB_getUnclipRatio_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_dnn_TextDetectionModel_DB_setMaxCandidates_int(instance: *mut c_void, max_candidates: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_DB_getMaxCandidates_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_TextDetectionModel_DB_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_TextDetectionModel_DB_to_Model(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_TextDetectionModel_DB_to_TextDetectionModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_TextDetectionModel_DB_delete(instance: *mut c_void);
		pub fn cv_dnn_TextDetectionModel_EAST_TextDetectionModel_EAST(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_EAST_TextDetectionModel_EAST_const_NetR(network: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_EAST_TextDetectionModel_EAST_const_stringR_const_stringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_EAST_TextDetectionModel_EAST_const_stringR(model: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_EAST_setConfidenceThreshold_float(instance: *mut c_void, conf_threshold: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_EAST_getConfidenceThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_dnn_TextDetectionModel_EAST_setNMSThreshold_float(instance: *mut c_void, nms_threshold: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextDetectionModel_EAST_getNMSThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_dnn_TextDetectionModel_EAST_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_TextDetectionModel_EAST_to_Model(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_TextDetectionModel_EAST_to_TextDetectionModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_TextDetectionModel_EAST_delete(instance: *mut c_void);
		pub fn cv_dnn_TextRecognitionModel_TextRecognitionModel(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_TextRecognitionModel_const_NetR(network: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_TextRecognitionModel_const_stringR_const_stringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_TextRecognitionModel_const_stringR(model: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_setDecodeType_const_stringR(instance: *mut c_void, decode_type: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_getDecodeType_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_setDecodeOptsCTCPrefixBeamSearch_int_int(instance: *mut c_void, beam_size: i32, voc_prune_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_setDecodeOptsCTCPrefixBeamSearch_int(instance: *mut c_void, beam_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_setVocabulary_const_vectorLstringGR(instance: *mut c_void, vocabulary: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_getVocabulary_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_recognize_const_const__InputArrayR(instance: *const c_void, frame: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TextRecognitionModel_recognize_const_const__InputArrayR_const__InputArrayR_vectorLstringGR(instance: *const c_void, frame: *const c_void, roi_rects: *const c_void, results: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_TextRecognitionModel_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_dnn_TextRecognitionModel_to_Model(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_TextRecognitionModel_delete(instance: *mut c_void);
		pub fn cv_dnn_ThresholdedReluLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_ThresholdedReluLayer_propAlpha_const(instance: *const c_void) -> f32;
		pub fn cv_dnn_ThresholdedReluLayer_propAlpha_float(instance: *mut c_void, val: f32);
		pub fn cv_dnn_ThresholdedReluLayer_to_ActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ThresholdedReluLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ThresholdedReluLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_ThresholdedReluLayer_delete(instance: *mut c_void);
		pub fn cv_dnn_TileLayer_create_const_LayerParamsR(params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_TileLayer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_TileLayer_to_Layer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn_TileLayer_delete(instance: *mut c_void);
		pub fn cv_dnn__Range__Range_const_RangeR(r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn__Range__Range_int_int(start_: i32, size_: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn__Range__Range_int(start_: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn__Range_to_Range(instance: *mut c_void) -> *mut c_void;
		pub fn cv_dnn__Range_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_AbsLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AbsLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AbsLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_AbsLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AbsLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AbsLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AbsLayerG_new_const_AbsLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AccumLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AccumLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AccumLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_AccumLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AccumLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AccumLayerG_new_const_AccumLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AcosLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AcosLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AcosLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_AcosLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AcosLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AcosLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AcosLayerG_new_const_AcosLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AcoshLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AcoshLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AcoshLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_AcoshLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AcoshLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AcoshLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AcoshLayerG_new_const_AcoshLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ActivationLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ActivationLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ActivationLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ActivationLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ActivationLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ActivationLayerG_new_const_ActivationLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ActivationLayerInt8G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ActivationLayerInt8G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ActivationLayerInt8G_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ActivationLayerInt8G_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ActivationLayerInt8G_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ActivationLayerInt8G_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ActivationLayerInt8G_new_const_ActivationLayerInt8(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ArgLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ArgLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ArgLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ArgLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ArgLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ArgLayerG_new_const_ArgLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AsinLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AsinLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AsinLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_AsinLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AsinLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AsinLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AsinLayerG_new_const_AsinLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AsinhLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AsinhLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AsinhLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_AsinhLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AsinhLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AsinhLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AsinhLayerG_new_const_AsinhLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AtanLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AtanLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AtanLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_AtanLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AtanLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AtanLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AtanLayerG_new_const_AtanLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AtanhLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AtanhLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AtanhLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_AtanhLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AtanhLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AtanhLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_AtanhLayerG_new_const_AtanhLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BNLLLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BNLLLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BNLLLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_BNLLLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BNLLLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BNLLLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BNLLLayerG_new_const_BNLLLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BackendNodeG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BackendNodeG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BackendNodeG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_BackendNodeG_new_const_BackendNode(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BackendWrapperG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BackendWrapperG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BackendWrapperG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_BaseConvolutionLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BaseConvolutionLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BaseConvolutionLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_BaseConvolutionLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BaseConvolutionLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BaseConvolutionLayerG_new_const_BaseConvolutionLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BatchNormLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BatchNormLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BatchNormLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_BatchNormLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BatchNormLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BatchNormLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BatchNormLayerG_new_const_BatchNormLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BatchNormLayerInt8G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BatchNormLayerInt8G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BatchNormLayerInt8G_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_BatchNormLayerInt8G_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BatchNormLayerInt8G_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BatchNormLayerInt8G_to_PtrOfBatchNormLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BatchNormLayerInt8G_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BatchNormLayerInt8G_new_const_BatchNormLayerInt8(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BlankLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BlankLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BlankLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_BlankLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BlankLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_BlankLayerG_new_const_BlankLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CeilLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CeilLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CeilLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_CeilLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CeilLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CeilLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CeilLayerG_new_const_CeilLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CeluLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CeluLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CeluLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_CeluLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CeluLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CeluLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CeluLayerG_new_const_CeluLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ChannelsPReLULayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ChannelsPReLULayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ChannelsPReLULayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ChannelsPReLULayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ChannelsPReLULayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ChannelsPReLULayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ChannelsPReLULayerG_new_const_ChannelsPReLULayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CompareLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CompareLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CompareLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_CompareLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CompareLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CompareLayerG_new_const_CompareLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConcatLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConcatLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConcatLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ConcatLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConcatLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConcatLayerG_new_const_ConcatLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConstLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConstLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConstLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ConstLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConstLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConstLayerG_new_const_ConstLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConvolutionLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConvolutionLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConvolutionLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ConvolutionLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConvolutionLayerG_to_PtrOfBaseConvolutionLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConvolutionLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConvolutionLayerG_new_const_ConvolutionLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConvolutionLayerInt8G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConvolutionLayerInt8G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConvolutionLayerInt8G_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ConvolutionLayerInt8G_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConvolutionLayerInt8G_to_PtrOfBaseConvolutionLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConvolutionLayerInt8G_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ConvolutionLayerInt8G_new_const_ConvolutionLayerInt8(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CorrelationLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CorrelationLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CorrelationLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_CorrelationLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CorrelationLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CorrelationLayerG_new_const_CorrelationLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CosLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CosLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CosLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_CosLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CosLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CosLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CosLayerG_new_const_CosLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CoshLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CoshLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CoshLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_CoshLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CoshLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CoshLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CoshLayerG_new_const_CoshLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CropAndResizeLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CropAndResizeLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CropAndResizeLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_CropAndResizeLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CropAndResizeLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CropAndResizeLayerG_new_const_CropAndResizeLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CropLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CropLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CropLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_CropLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CropLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CropLayerG_new_const_CropLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CumSumLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CumSumLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CumSumLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_CumSumLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CumSumLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_CumSumLayerG_new_const_CumSumLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DataAugmentationLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DataAugmentationLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DataAugmentationLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_DataAugmentationLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DataAugmentationLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DataAugmentationLayerG_new_const_DataAugmentationLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DeconvolutionLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DeconvolutionLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DeconvolutionLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_DeconvolutionLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DeconvolutionLayerG_to_PtrOfBaseConvolutionLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DeconvolutionLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DeconvolutionLayerG_new_const_DeconvolutionLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DequantizeLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DequantizeLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DequantizeLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_DequantizeLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DequantizeLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DequantizeLayerG_new_const_DequantizeLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DetectionOutputLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DetectionOutputLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DetectionOutputLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_DetectionOutputLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DetectionOutputLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_DetectionOutputLayerG_new_const_DetectionOutputLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ELULayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ELULayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ELULayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ELULayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ELULayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ELULayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ELULayerG_new_const_ELULayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_EltwiseLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_EltwiseLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_EltwiseLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_EltwiseLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_EltwiseLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_EltwiseLayerG_new_const_EltwiseLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_EltwiseLayerInt8G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_EltwiseLayerInt8G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_EltwiseLayerInt8G_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_EltwiseLayerInt8G_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_EltwiseLayerInt8G_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_EltwiseLayerInt8G_new_const_EltwiseLayerInt8(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ErfLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ErfLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ErfLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ErfLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ErfLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ErfLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ErfLayerG_new_const_ErfLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ExpLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ExpLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ExpLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ExpLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ExpLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ExpLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ExpLayerG_new_const_ExpLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_FlattenLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_FlattenLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_FlattenLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_FlattenLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_FlattenLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_FlattenLayerG_new_const_FlattenLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_FloorLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_FloorLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_FloorLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_FloorLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_FloorLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_FloorLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_FloorLayerG_new_const_FloorLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_FlowWarpLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_FlowWarpLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_FlowWarpLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_FlowWarpLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_FlowWarpLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_FlowWarpLayerG_new_const_FlowWarpLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GRULayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GRULayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GRULayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_GRULayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GRULayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GRULayerG_new_const_GRULayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GatherLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GatherLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GatherLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_GatherLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GatherLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GatherLayerG_new_const_GatherLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GeluApproximationLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GeluApproximationLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GeluApproximationLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_GeluApproximationLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GeluApproximationLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GeluApproximationLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GeluApproximationLayerG_new_const_GeluApproximationLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GeluLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GeluLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GeluLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_GeluLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GeluLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GeluLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_GeluLayerG_new_const_GeluLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_HardSigmoidLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_HardSigmoidLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_HardSigmoidLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_HardSigmoidLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_HardSigmoidLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_HardSigmoidLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_HardSigmoidLayerG_new_const_HardSigmoidLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_HardSwishLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_HardSwishLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_HardSwishLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_HardSwishLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_HardSwishLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_HardSwishLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_HardSwishLayerG_new_const_HardSwishLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_InnerProductLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_InnerProductLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_InnerProductLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_InnerProductLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_InnerProductLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_InnerProductLayerG_new_const_InnerProductLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_InnerProductLayerInt8G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_InnerProductLayerInt8G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_InnerProductLayerInt8G_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_InnerProductLayerInt8G_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_InnerProductLayerInt8G_to_PtrOfInnerProductLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_InnerProductLayerInt8G_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_InnerProductLayerInt8G_new_const_InnerProductLayerInt8(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_InterpLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_InterpLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_InterpLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_InterpLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_InterpLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_InterpLayerG_new_const_InterpLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LRNLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LRNLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LRNLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_LRNLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LRNLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LRNLayerG_new_const_LRNLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LSTMLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LSTMLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LSTMLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_LSTMLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LSTMLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_LayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LayerG_new_const_Layer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LayerNormLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LayerNormLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LayerNormLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_LayerNormLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LayerNormLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LayerNormLayerG_new_const_LayerNormLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LogLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LogLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LogLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_LogLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LogLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LogLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_LogLayerG_new_const_LogLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_MVNLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_MVNLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_MVNLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_MVNLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_MVNLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_MVNLayerG_new_const_MVNLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_MaxUnpoolLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_MaxUnpoolLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_MaxUnpoolLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_MaxUnpoolLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_MaxUnpoolLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_MaxUnpoolLayerG_new_const_MaxUnpoolLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_MishLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_MishLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_MishLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_MishLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_MishLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_MishLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_MishLayerG_new_const_MishLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_NaryEltwiseLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_NaryEltwiseLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_NaryEltwiseLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_NaryEltwiseLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_NaryEltwiseLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_NaryEltwiseLayerG_new_const_NaryEltwiseLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_NormalizeBBoxLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_NormalizeBBoxLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_NormalizeBBoxLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_NormalizeBBoxLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_NormalizeBBoxLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_NormalizeBBoxLayerG_new_const_NormalizeBBoxLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_NotLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_NotLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_NotLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_NotLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_NotLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_NotLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_NotLayerG_new_const_NotLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PaddingLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PaddingLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PaddingLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_PaddingLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PaddingLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PaddingLayerG_new_const_PaddingLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PermuteLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PermuteLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PermuteLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_PermuteLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PermuteLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PermuteLayerG_new_const_PermuteLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PoolingLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PoolingLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PoolingLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_PoolingLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PoolingLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PoolingLayerG_new_const_PoolingLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PoolingLayerInt8G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PoolingLayerInt8G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PoolingLayerInt8G_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_PoolingLayerInt8G_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PoolingLayerInt8G_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PoolingLayerInt8G_to_PtrOfPoolingLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PoolingLayerInt8G_new_const_PoolingLayerInt8(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PowerLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PowerLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PowerLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_PowerLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PowerLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PowerLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PowerLayerG_new_const_PowerLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PriorBoxLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PriorBoxLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PriorBoxLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_PriorBoxLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PriorBoxLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_PriorBoxLayerG_new_const_PriorBoxLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ProposalLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ProposalLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ProposalLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ProposalLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ProposalLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ProposalLayerG_new_const_ProposalLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_QuantizeLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_QuantizeLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_QuantizeLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_QuantizeLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_QuantizeLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_QuantizeLayerG_new_const_QuantizeLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RNNLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RNNLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RNNLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_RNNLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RNNLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReLU6LayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReLU6LayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReLU6LayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ReLU6LayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReLU6LayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReLU6LayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReLU6LayerG_new_const_ReLU6Layer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReLULayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReLULayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReLULayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ReLULayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReLULayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReLULayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReLULayerG_new_const_ReLULayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReciprocalLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReciprocalLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReciprocalLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ReciprocalLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReciprocalLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReciprocalLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReciprocalLayerG_new_const_ReciprocalLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReduceLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReduceLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReduceLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ReduceLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReduceLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReduceLayerG_new_const_ReduceLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RegionLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RegionLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RegionLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_RegionLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RegionLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RegionLayerG_new_const_RegionLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReorgLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReorgLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReorgLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ReorgLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReorgLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReorgLayerG_new_const_ReorgLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RequantizeLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RequantizeLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RequantizeLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_RequantizeLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RequantizeLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RequantizeLayerG_new_const_RequantizeLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReshapeLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReshapeLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReshapeLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ReshapeLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReshapeLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ReshapeLayerG_new_const_ReshapeLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ResizeLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ResizeLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ResizeLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ResizeLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ResizeLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ResizeLayerG_new_const_ResizeLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RoundLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RoundLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RoundLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_RoundLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RoundLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RoundLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_RoundLayerG_new_const_RoundLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScaleLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScaleLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScaleLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ScaleLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScaleLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScaleLayerG_new_const_ScaleLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScaleLayerInt8G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScaleLayerInt8G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScaleLayerInt8G_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ScaleLayerInt8G_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScaleLayerInt8G_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScaleLayerInt8G_to_PtrOfScaleLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScaleLayerInt8G_new_const_ScaleLayerInt8(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScatterLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScatterLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScatterLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ScatterLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScatterLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScatterLayerG_new_const_ScatterLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScatterNDLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScatterNDLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScatterNDLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ScatterNDLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScatterNDLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ScatterNDLayerG_new_const_ScatterNDLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SeluLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SeluLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SeluLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_SeluLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SeluLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SeluLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SeluLayerG_new_const_SeluLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShiftLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShiftLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShiftLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ShiftLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShiftLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShiftLayerG_new_const_ShiftLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShiftLayerInt8G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShiftLayerInt8G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShiftLayerInt8G_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ShiftLayerInt8G_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShiftLayerInt8G_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShiftLayerInt8G_new_const_ShiftLayerInt8(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShrinkLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShrinkLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShrinkLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ShrinkLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShrinkLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShrinkLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShrinkLayerG_new_const_ShrinkLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShuffleChannelLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShuffleChannelLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShuffleChannelLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ShuffleChannelLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShuffleChannelLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ShuffleChannelLayerG_new_const_ShuffleChannelLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SigmoidLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SigmoidLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SigmoidLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_SigmoidLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SigmoidLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SigmoidLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SigmoidLayerG_new_const_SigmoidLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SignLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SignLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SignLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_SignLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SignLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SignLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SignLayerG_new_const_SignLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SinLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SinLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SinLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_SinLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SinLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SinLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SinLayerG_new_const_SinLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SinhLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SinhLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SinhLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_SinhLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SinhLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SinhLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SinhLayerG_new_const_SinhLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SliceLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SliceLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SliceLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_SliceLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SliceLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SliceLayerG_new_const_SliceLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftmaxLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftmaxLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftmaxLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_SoftmaxLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftmaxLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftmaxLayerG_new_const_SoftmaxLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftmaxLayerInt8G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftmaxLayerInt8G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftmaxLayerInt8G_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_SoftmaxLayerInt8G_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftmaxLayerInt8G_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftmaxLayerInt8G_to_PtrOfSoftmaxLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftmaxLayerInt8G_new_const_SoftmaxLayerInt8(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftplusLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftplusLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftplusLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_SoftplusLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftplusLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftplusLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftplusLayerG_new_const_SoftplusLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftsignLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftsignLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftsignLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_SoftsignLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftsignLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftsignLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SoftsignLayerG_new_const_SoftsignLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SplitLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SplitLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SplitLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_SplitLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SplitLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SplitLayerG_new_const_SplitLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SqrtLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SqrtLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SqrtLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_SqrtLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SqrtLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SqrtLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SqrtLayerG_new_const_SqrtLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SwishLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SwishLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SwishLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_SwishLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SwishLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SwishLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_SwishLayerG_new_const_SwishLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_TanHLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_TanHLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_TanHLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_TanHLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_TanHLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_TanHLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_TanHLayerG_new_const_TanHLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_TanLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_TanLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_TanLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_TanLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_TanLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_TanLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_TanLayerG_new_const_TanLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ThresholdedReluLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ThresholdedReluLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ThresholdedReluLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_ThresholdedReluLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ThresholdedReluLayerG_to_PtrOfActivationLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ThresholdedReluLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_ThresholdedReluLayerG_new_const_ThresholdedReluLayer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_TileLayerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_TileLayerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_TileLayerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_TileLayerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_TileLayerG_to_PtrOfLayer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_TileLayerG_new_const_TileLayer(val: *mut c_void) -> *mut c_void;
		pub fn std_pairLcv_dnn_Backend__cv_dnn_TargetG_new_const_Backend_Target(arg: crate::dnn::Backend, arg_1: crate::dnn::Target) -> *mut c_void;
		pub fn std_pairLcv_dnn_Backend__cv_dnn_TargetG_get_0_const(instance: *const c_void, ocvrs_return: *mut crate::dnn::Backend);
		pub fn std_pairLcv_dnn_Backend__cv_dnn_TargetG_get_1_const(instance: *const c_void, ocvrs_return: *mut crate::dnn::Target);
		pub fn std_pairLcv_dnn_Backend__cv_dnn_TargetG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_dnn_MatShapeG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_dnn_MatShapeG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_dnn_MatShapeG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_dnn_MatShapeG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_dnn_MatShapeG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_dnn_MatShapeG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_dnn_MatShapeG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_dnn_MatShapeG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_dnn_MatShapeG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_dnn_MatShapeG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_dnn_MatShapeG_push_const_MatShape(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_dnn_MatShapeG_insert_size_t_const_MatShape(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_dnn_MatShapeG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_dnn_MatShapeG_set_size_t_const_MatShape(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_dnn_MatShapeG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_dnn_MatShapeG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_dnn_MatShapeG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendNodeGG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_PtrLcv_dnn_BackendNodeGG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendNodeGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_PtrLcv_dnn_BackendNodeGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_PtrLcv_dnn_BackendNodeGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_PtrLcv_dnn_BackendNodeGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendNodeGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendNodeGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendNodeGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendNodeGG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendNodeGG_push_const_PtrLBackendNodeG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendNodeGG_insert_size_t_const_PtrLBackendNodeG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendNodeGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendNodeGG_set_size_t_const_PtrLBackendNodeG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendWrapperGG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_PtrLcv_dnn_BackendWrapperGG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendWrapperGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_PtrLcv_dnn_BackendWrapperGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_PtrLcv_dnn_BackendWrapperGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_PtrLcv_dnn_BackendWrapperGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendWrapperGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendWrapperGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendWrapperGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendWrapperGG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendWrapperGG_push_const_PtrLBackendWrapperG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendWrapperGG_insert_size_t_const_PtrLBackendWrapperG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendWrapperGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_BackendWrapperGG_set_size_t_const_PtrLBackendWrapperG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_LayerGG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_PtrLcv_dnn_LayerGG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_LayerGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_PtrLcv_dnn_LayerGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_PtrLcv_dnn_LayerGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_PtrLcv_dnn_LayerGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_LayerGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_PtrLcv_dnn_LayerGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_PtrLcv_dnn_LayerGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_PtrLcv_dnn_LayerGG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_LayerGG_push_const_PtrLLayerG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_LayerGG_insert_size_t_const_PtrLLayerG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_LayerGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_PtrLcv_dnn_LayerGG_set_size_t_const_PtrLLayerG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_dnn_TargetG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_dnn_TargetG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_dnn_TargetG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_dnn_TargetG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_dnn_TargetG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_dnn_TargetG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_dnn_TargetG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_dnn_TargetG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_dnn_TargetG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_dnn_TargetG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_dnn_TargetG_push_const_Target(instance: *mut c_void, val: crate::dnn::Target);
		pub fn std_vectorLcv_dnn_TargetG_insert_size_t_const_Target(instance: *mut c_void, index: size_t, val: crate::dnn::Target);
		pub fn std_vectorLcv_dnn_TargetG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut crate::dnn::Target);
		pub fn std_vectorLcv_dnn_TargetG_set_size_t_const_Target(instance: *mut c_void, index: size_t, val: crate::dnn::Target);
		pub fn std_vectorLcv_dnn_TargetG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_dnn_TargetG_data_const(instance: *const c_void) -> *const crate::dnn::Target;
		pub fn std_vectorLcv_dnn_TargetG_dataMut(instance: *mut c_void) -> *mut crate::dnn::Target;
		pub fn cv_fromSlice_const_const_TargetX_size_t(data: *const crate::dnn::Target, len: size_t) -> *mut c_void;
		pub fn std_vectorLstd_pairLcv_dnn_Backend__cv_dnn_TargetGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_pairLcv_dnn_Backend__cv_dnn_TargetGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_pairLcv_dnn_Backend__cv_dnn_TargetGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_pairLcv_dnn_Backend__cv_dnn_TargetGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_pairLcv_dnn_Backend__cv_dnn_TargetGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_pairLcv_dnn_Backend__cv_dnn_TargetGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_pairLcv_dnn_Backend__cv_dnn_TargetGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_pairLcv_dnn_Backend__cv_dnn_TargetGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_pairLcv_dnn_Backend__cv_dnn_TargetGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_pairLcv_dnn_Backend__cv_dnn_TargetGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_pairLcv_dnn_Backend__cv_dnn_TargetGG_push_const_pairLcv_dnn_Backend__cv_dnn_TargetG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_pairLcv_dnn_Backend__cv_dnn_TargetGG_insert_size_t_const_pairLcv_dnn_Backend__cv_dnn_TargetG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_pairLcv_dnn_Backend__cv_dnn_TargetGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_pairLcv_dnn_Backend__cv_dnn_TargetGG_set_size_t_const_pairLcv_dnn_Backend__cv_dnn_TargetG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_dnn_MatShapeGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLcv_dnn_MatShapeGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_dnn_MatShapeGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_dnn_MatShapeGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLcv_dnn_MatShapeGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_dnn_MatShapeGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_dnn_MatShapeGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLcv_dnn_MatShapeGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLcv_dnn_MatShapeGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLcv_dnn_MatShapeGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_dnn_MatShapeGG_push_const_vectorLMatShapeG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_dnn_MatShapeGG_insert_size_t_const_vectorLMatShapeG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_dnn_MatShapeGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLcv_dnn_MatShapeGG_set_size_t_const_vectorLMatShapeG(instance: *mut c_void, index: size_t, val: *const c_void);
	}
}
#[cfg(ocvrs_has_module_dnn)]
pub use dnn_sys::*;

#[cfg(ocvrs_has_module_dnn_superres)]
mod dnn_superres_sys {
	use super::*;

	extern "C" {
		pub fn cv_dnn_superres_DnnSuperResImpl_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_superres_DnnSuperResImpl_DnnSuperResImpl(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_superres_DnnSuperResImpl_DnnSuperResImpl_const_StringR_int(algo: *const c_char, scale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_superres_DnnSuperResImpl_readModel_const_StringR(instance: *mut c_void, path: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_superres_DnnSuperResImpl_readModel_const_StringR_const_StringR(instance: *mut c_void, weights: *const c_char, definition: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_superres_DnnSuperResImpl_setModel_const_StringR_int(instance: *mut c_void, algo: *const c_char, scale: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_superres_DnnSuperResImpl_setPreferableBackend_int(instance: *mut c_void, backend_id: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_superres_DnnSuperResImpl_setPreferableTarget_int(instance: *mut c_void, target_id: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_superres_DnnSuperResImpl_upsample_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, img: *const c_void, result: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_superres_DnnSuperResImpl_upsampleMultioutput_const__InputArrayR_vectorLMatGR_const_vectorLintGR_const_vectorLStringGR(instance: *mut c_void, img: *const c_void, imgs_new: *mut c_void, scale_factors: *const c_void, node_names: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dnn_superres_DnnSuperResImpl_getScale(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_dnn_superres_DnnSuperResImpl_getAlgorithm(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dnn_superres_DnnSuperResImpl_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_superres_DnnSuperResImplG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_superres_DnnSuperResImplG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dnn_superres_DnnSuperResImplG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dnn_superres_DnnSuperResImplG_new_const_DnnSuperResImpl(val: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_dnn_superres)]
pub use dnn_superres_sys::*;

#[cfg(ocvrs_has_module_dpm)]
mod dpm_sys {
	use super::*;

	extern "C" {
		pub fn cv_dpm_DPMDetector_isEmpty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dpm_DPMDetector_detect_MatR_vectorLObjectDetectionGR(instance: *mut c_void, image: *mut c_void, objects: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dpm_DPMDetector_getClassNames_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dpm_DPMDetector_getClassCount_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_dpm_DPMDetector_create_const_vectorLstringGR_const_vectorLstringGR(filenames: *const c_void, class_names: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dpm_DPMDetector_create_const_vectorLstringGR(filenames: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dpm_DPMDetector_delete(instance: *mut c_void);
		pub fn cv_dpm_DPMDetector_ObjectDetection_ObjectDetection(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dpm_DPMDetector_ObjectDetection_ObjectDetection_const_RectR_float_int(rect: *const core::Rect, score: f32, class_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dpm_DPMDetector_ObjectDetection_ObjectDetection_const_RectR_float(rect: *const core::Rect, score: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dpm_DPMDetector_ObjectDetection_propRect_const(instance: *const c_void, ocvrs_return: *mut core::Rect);
		pub fn cv_dpm_DPMDetector_ObjectDetection_propRect_Rect(instance: *mut c_void, val: *const core::Rect);
		pub fn cv_dpm_DPMDetector_ObjectDetection_propScore_const(instance: *const c_void) -> f32;
		pub fn cv_dpm_DPMDetector_ObjectDetection_propScore_float(instance: *mut c_void, val: f32);
		pub fn cv_dpm_DPMDetector_ObjectDetection_propClassID_const(instance: *const c_void) -> i32;
		pub fn cv_dpm_DPMDetector_ObjectDetection_propClassID_int(instance: *mut c_void, val: i32);
		pub fn cv_dpm_DPMDetector_ObjectDetection_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_dpm_DPMDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dpm_DPMDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dpm_DPMDetectorG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_dpm_DPMDetector_ObjectDetectionG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_dpm_DPMDetector_ObjectDetectionG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_dpm_DPMDetector_ObjectDetectionG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_dpm_DPMDetector_ObjectDetectionG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_dpm_DPMDetector_ObjectDetectionG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_dpm_DPMDetector_ObjectDetectionG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_dpm_DPMDetector_ObjectDetectionG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_dpm_DPMDetector_ObjectDetectionG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_dpm_DPMDetector_ObjectDetectionG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_dpm_DPMDetector_ObjectDetectionG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_dpm_DPMDetector_ObjectDetectionG_push_const_ObjectDetection(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_dpm_DPMDetector_ObjectDetectionG_insert_size_t_const_ObjectDetection(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_dpm_DPMDetector_ObjectDetectionG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_dpm_DPMDetector_ObjectDetectionG_set_size_t_const_ObjectDetection(instance: *mut c_void, index: size_t, val: *const c_void);
	}
}
#[cfg(ocvrs_has_module_dpm)]
pub use dpm_sys::*;

#[cfg(ocvrs_has_module_face)]
mod face_sys {
	use super::*;

	extern "C" {
		pub fn cv_face_createFacemarkAAM(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_createFacemarkKazemi(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_createFacemarkLBF(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_drawFacemarks_const__InputOutputArrayR_const__InputArrayR(image: *const c_void, points: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_face_drawFacemarks_const__InputOutputArrayR_const__InputArrayR_Scalar(image: *const c_void, points: *const c_void, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_face_getFacesHAAR_const__InputArrayR_const__OutputArrayR_const_StringR(image: *const c_void, faces: *const c_void, face_cascade_name: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_getFaces_const__InputArrayR_const__OutputArrayR_CParamsX(image: *const c_void, faces: *const c_void, params: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_loadDatasetList_String_String_vectorLStringGR_vectorLStringGR(image_list: *mut c_char, annotation_list: *mut c_char, images: *mut c_void, annotations: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_loadFacePoints_String_const__OutputArrayR(filename: *mut c_char, points: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_loadFacePoints_String_const__OutputArrayR_float(filename: *mut c_char, points: *const c_void, offset: f32, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_loadTrainingData_String_String_vectorLStringGR_const__OutputArrayR(image_list: *mut c_char, ground_truth: *mut c_char, images: *mut c_void, face_points: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_loadTrainingData_String_String_vectorLStringGR_const__OutputArrayR_float(image_list: *mut c_char, ground_truth: *mut c_char, images: *mut c_void, face_points: *const c_void, offset: f32, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_loadTrainingData_String_vectorLStringGR_const__OutputArrayR(filename: *mut c_char, images: *mut c_void, face_points: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_loadTrainingData_String_vectorLStringGR_const__OutputArrayR_char_float(filename: *mut c_char, images: *mut c_void, face_points: *const c_void, delim: c_char, offset: f32, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_loadTrainingData_vectorLStringG_vectorLvectorLPoint2fGGR_vectorLStringGR(filename: *mut c_void, trainlandmarks: *mut c_void, trainimages: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_BIF_getNumBands_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_face_BIF_getNumRotations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_face_BIF_compute_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, image: *const c_void, features: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_face_BIF_create_int_int(num_bands: i32, num_rotations: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_BIF_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_BIF_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_BIF_delete(instance: *mut c_void);
		pub fn cv_face_BasicFaceRecognizer_getNumComponents_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_face_BasicFaceRecognizer_setNumComponents_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_face_BasicFaceRecognizer_getThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_face_BasicFaceRecognizer_setThreshold_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_face_BasicFaceRecognizer_getProjections_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_BasicFaceRecognizer_getLabels_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_BasicFaceRecognizer_getEigenValues_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_BasicFaceRecognizer_getEigenVectors_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_BasicFaceRecognizer_getMean_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_BasicFaceRecognizer_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_face_BasicFaceRecognizer_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_face_BasicFaceRecognizer_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_BasicFaceRecognizer_to_EigenFaceRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_BasicFaceRecognizer_to_FisherFaceRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_BasicFaceRecognizer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_BasicFaceRecognizer_to_FaceRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_BasicFaceRecognizer_delete(instance: *mut c_void);
		pub fn cv_face_CParams_CParams_String_double_int_Size_Size(cascade_model: *mut c_char, sf: f64, min_n: i32, min_sz: *const core::Size, max_sz: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_CParams_CParams_String(cascade_model: *mut c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_CParams_propCascade_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_CParams_propCascade_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_face_CParams_propScaleFactor_const(instance: *const c_void) -> f64;
		pub fn cv_face_CParams_propScaleFactor_double(instance: *mut c_void, val: f64);
		pub fn cv_face_CParams_propMinNeighbors_const(instance: *const c_void) -> i32;
		pub fn cv_face_CParams_propMinNeighbors_int(instance: *mut c_void, val: i32);
		pub fn cv_face_CParams_propMinSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_face_CParams_propMinSize_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_face_CParams_propMaxSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_face_CParams_propMaxSize_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_face_CParams_propFace_cascade_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_CParams_propFace_cascade_CascadeClassifier(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_CParams_delete(instance: *mut c_void);
		pub fn cv_face_EigenFaceRecognizer_create_int_double(num_components: i32, threshold: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_EigenFaceRecognizer_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_EigenFaceRecognizer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_EigenFaceRecognizer_to_BasicFaceRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_EigenFaceRecognizer_to_FaceRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_EigenFaceRecognizer_delete(instance: *mut c_void);
		pub fn cv_face_FaceRecognizer_train_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, labels: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_face_FaceRecognizer_update_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, labels: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_face_FaceRecognizer_predict_const_const__InputArrayR(instance: *const c_void, src: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_face_FaceRecognizer_predict_const_const__InputArrayR_intR_doubleR(instance: *const c_void, src: *const c_void, label: *mut i32, confidence: *mut f64, ocvrs_return: *mut Result_void);
		pub fn cv_face_FaceRecognizer_predict_const_const__InputArrayR_PtrLPredictCollectorG(instance: *const c_void, src: *const c_void, collector: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_face_FaceRecognizer_write_const_const_StringR(instance: *const c_void, filename: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_face_FaceRecognizer_read_const_StringR(instance: *mut c_void, filename: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_face_FaceRecognizer_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_face_FaceRecognizer_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_face_FaceRecognizer_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_FaceRecognizer_setLabelInfo_int_const_StringR(instance: *mut c_void, label: i32, str_info: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_face_FaceRecognizer_getLabelInfo_const_int(instance: *const c_void, label: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_FaceRecognizer_getLabelsByString_const_const_StringR(instance: *const c_void, str: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_FaceRecognizer_getThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_face_FaceRecognizer_setThreshold_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_face_FaceRecognizer_to_BasicFaceRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FaceRecognizer_to_EigenFaceRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FaceRecognizer_to_FisherFaceRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FaceRecognizer_to_LBPHFaceRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FaceRecognizer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FaceRecognizer_delete(instance: *mut c_void);
		pub fn cv_face_Facemark_loadModel_String(instance: *mut c_void, model: *mut c_char, ocvrs_return: *mut Result_void);
		pub fn cv_face_Facemark_fit_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, faces: *const c_void, landmarks: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_Facemark_to_FacemarkAAM(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_Facemark_to_FacemarkKazemi(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_Facemark_to_FacemarkLBF(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_Facemark_to_FacemarkTrain(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_Facemark_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_Facemark_delete(instance: *mut c_void);
		pub fn cv_face_FacemarkAAM_fitConfig_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const_vectorLConfigGR(instance: *mut c_void, image: *const c_void, roi: *const c_void, _landmarks: *const c_void, runtime_params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_FacemarkAAM_create_const_ParamsR(parameters: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_FacemarkAAM_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_FacemarkAAM_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_to_Facemark(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_to_FacemarkTrain(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_delete(instance: *mut c_void);
		pub fn cv_face_FacemarkAAM_Config_Config_Mat_Point2f_float_int(rot: *mut c_void, trans: *const core::Point2f, scaling: f32, scale_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_FacemarkAAM_Config_Config(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_FacemarkAAM_Config_propR_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_Config_propR_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkAAM_Config_propT_const(instance: *const c_void, ocvrs_return: *mut core::Point2f);
		pub fn cv_face_FacemarkAAM_Config_propT_Point2f(instance: *mut c_void, val: *const core::Point2f);
		pub fn cv_face_FacemarkAAM_Config_propScale_const(instance: *const c_void) -> f32;
		pub fn cv_face_FacemarkAAM_Config_propScale_float(instance: *mut c_void, val: f32);
		pub fn cv_face_FacemarkAAM_Config_propModel_scale_idx_const(instance: *const c_void) -> i32;
		pub fn cv_face_FacemarkAAM_Config_propModel_scale_idx_int(instance: *mut c_void, val: i32);
		pub fn cv_face_FacemarkAAM_Config_delete(instance: *mut c_void);
		pub fn cv_face_FacemarkAAM_Data_propS0_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_Data_propS0_vectorLPoint2fG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkAAM_Data_delete(instance: *mut c_void);
		pub fn cv_face_FacemarkAAM_Model_propScales_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_Model_propScales_vectorLfloatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkAAM_Model_propTriangles_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_Model_propTriangles_vectorLVec3iG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkAAM_Model_propTextures_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_Model_propTextures_vectorLTextureG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkAAM_Model_propS0_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_Model_propS0_vectorLPoint2fG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkAAM_Model_propS_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_Model_propS_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkAAM_Model_propQ_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_Model_propQ_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkAAM_Model_delete(instance: *mut c_void);
		pub fn cv_face_FacemarkAAM_Model_Texture_propMax_m_const(instance: *const c_void) -> i32;
		pub fn cv_face_FacemarkAAM_Model_Texture_propMax_m_int(instance: *mut c_void, val: i32);
		pub fn cv_face_FacemarkAAM_Model_Texture_propResolution_const(instance: *const c_void, ocvrs_return: *mut core::Rect);
		pub fn cv_face_FacemarkAAM_Model_Texture_propResolution_Rect(instance: *mut c_void, val: *const core::Rect);
		pub fn cv_face_FacemarkAAM_Model_Texture_propA_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_Model_Texture_propA_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkAAM_Model_Texture_propA0_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_Model_Texture_propA0_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkAAM_Model_Texture_propAA_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_Model_Texture_propAA_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkAAM_Model_Texture_propAA0_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_Model_Texture_propAA0_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkAAM_Model_Texture_propTextureIdx_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_Model_Texture_propTextureIdx_vectorLvectorLPointGG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkAAM_Model_Texture_propBase_shape_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_Model_Texture_propBase_shape_vectorLPoint2fG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkAAM_Model_Texture_propInd1_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_Model_Texture_propInd1_vectorLintG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkAAM_Model_Texture_propInd2_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_Model_Texture_propInd2_vectorLintG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkAAM_Model_Texture_delete(instance: *mut c_void);
		pub fn cv_face_FacemarkAAM_Params_Params(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_FacemarkAAM_Params_read_const_FileNodeR(instance: *mut c_void, unnamed: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_face_FacemarkAAM_Params_write_const_FileStorageR(instance: *const c_void, unnamed: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_face_FacemarkAAM_Params_propModel_filename_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_Params_propModel_filename_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_face_FacemarkAAM_Params_propM_const(instance: *const c_void) -> i32;
		pub fn cv_face_FacemarkAAM_Params_propM_int(instance: *mut c_void, val: i32);
		pub fn cv_face_FacemarkAAM_Params_propN_const(instance: *const c_void) -> i32;
		pub fn cv_face_FacemarkAAM_Params_propN_int(instance: *mut c_void, val: i32);
		pub fn cv_face_FacemarkAAM_Params_propN_iter_const(instance: *const c_void) -> i32;
		pub fn cv_face_FacemarkAAM_Params_propN_iter_int(instance: *mut c_void, val: i32);
		pub fn cv_face_FacemarkAAM_Params_propVerbose_const(instance: *const c_void) -> bool;
		pub fn cv_face_FacemarkAAM_Params_propVerbose_bool(instance: *mut c_void, val: bool);
		pub fn cv_face_FacemarkAAM_Params_propSave_model_const(instance: *const c_void) -> bool;
		pub fn cv_face_FacemarkAAM_Params_propSave_model_bool(instance: *mut c_void, val: bool);
		pub fn cv_face_FacemarkAAM_Params_propMax_m_const(instance: *const c_void) -> i32;
		pub fn cv_face_FacemarkAAM_Params_propMax_m_int(instance: *mut c_void, val: i32);
		pub fn cv_face_FacemarkAAM_Params_propMax_n_const(instance: *const c_void) -> i32;
		pub fn cv_face_FacemarkAAM_Params_propMax_n_int(instance: *mut c_void, val: i32);
		pub fn cv_face_FacemarkAAM_Params_propTexture_max_m_const(instance: *const c_void) -> i32;
		pub fn cv_face_FacemarkAAM_Params_propTexture_max_m_int(instance: *mut c_void, val: i32);
		pub fn cv_face_FacemarkAAM_Params_propScales_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkAAM_Params_propScales_vectorLfloatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkAAM_Params_delete(instance: *mut c_void);
		pub fn cv_face_FacemarkKazemi_create_const_ParamsR(parameters: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_FacemarkKazemi_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_FacemarkKazemi_training_vectorLMatGR_vectorLvectorLPoint2fGGR_string_Size_string(instance: *mut c_void, images: *mut c_void, landmarks: *mut c_void, configfile: *mut c_char, scale: *const core::Size, model_filename: *mut c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_FacemarkKazemi_training_vectorLMatGR_vectorLvectorLPoint2fGGR_string_Size(instance: *mut c_void, images: *mut c_void, landmarks: *mut c_void, configfile: *mut c_char, scale: *const core::Size, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_FacemarkKazemi_setFaceDetector_bool__X__const_cv__InputArrayR__const_cv__OutputArrayR__voidX__voidX(instance: *mut c_void, f: Option<unsafe extern "C" fn(*const c_void, *const c_void, *mut c_void) -> bool>, user_data: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_FacemarkKazemi_getFaces_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, faces: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_FacemarkKazemi_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FacemarkKazemi_to_Facemark(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FacemarkKazemi_delete(instance: *mut c_void);
		pub fn cv_face_FacemarkKazemi_Params_Params(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_FacemarkKazemi_Params_propCascade_depth_const(instance: *const c_void) -> u32;
		pub fn cv_face_FacemarkKazemi_Params_propCascade_depth_unsigned_long(instance: *mut c_void, val: u32);
		pub fn cv_face_FacemarkKazemi_Params_propTree_depth_const(instance: *const c_void) -> u32;
		pub fn cv_face_FacemarkKazemi_Params_propTree_depth_unsigned_long(instance: *mut c_void, val: u32);
		pub fn cv_face_FacemarkKazemi_Params_propNum_trees_per_cascade_level_const(instance: *const c_void) -> u32;
		pub fn cv_face_FacemarkKazemi_Params_propNum_trees_per_cascade_level_unsigned_long(instance: *mut c_void, val: u32);
		pub fn cv_face_FacemarkKazemi_Params_propLearning_rate_const(instance: *const c_void) -> f32;
		pub fn cv_face_FacemarkKazemi_Params_propLearning_rate_float(instance: *mut c_void, val: f32);
		pub fn cv_face_FacemarkKazemi_Params_propOversampling_amount_const(instance: *const c_void) -> u32;
		pub fn cv_face_FacemarkKazemi_Params_propOversampling_amount_unsigned_long(instance: *mut c_void, val: u32);
		pub fn cv_face_FacemarkKazemi_Params_propNum_test_coordinates_const(instance: *const c_void) -> u32;
		pub fn cv_face_FacemarkKazemi_Params_propNum_test_coordinates_unsigned_long(instance: *mut c_void, val: u32);
		pub fn cv_face_FacemarkKazemi_Params_propLambda_const(instance: *const c_void) -> f32;
		pub fn cv_face_FacemarkKazemi_Params_propLambda_float(instance: *mut c_void, val: f32);
		pub fn cv_face_FacemarkKazemi_Params_propNum_test_splits_const(instance: *const c_void) -> u32;
		pub fn cv_face_FacemarkKazemi_Params_propNum_test_splits_unsigned_long(instance: *mut c_void, val: u32);
		pub fn cv_face_FacemarkKazemi_Params_propConfigfile_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkKazemi_Params_propConfigfile_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_face_FacemarkKazemi_Params_delete(instance: *mut c_void);
		pub fn cv_face_FacemarkLBF_create_const_ParamsR(parameters: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_FacemarkLBF_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_FacemarkLBF_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FacemarkLBF_to_Facemark(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FacemarkLBF_to_FacemarkTrain(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FacemarkLBF_delete(instance: *mut c_void);
		pub fn cv_face_FacemarkLBF_Params_Params(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_FacemarkLBF_Params_read_const_FileNodeR(instance: *mut c_void, unnamed: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_face_FacemarkLBF_Params_write_const_FileStorageR(instance: *const c_void, unnamed: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_face_FacemarkLBF_Params_propShape_offset_const(instance: *const c_void) -> f64;
		pub fn cv_face_FacemarkLBF_Params_propShape_offset_double(instance: *mut c_void, val: f64);
		pub fn cv_face_FacemarkLBF_Params_propCascade_face_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkLBF_Params_propCascade_face_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_face_FacemarkLBF_Params_propVerbose_const(instance: *const c_void) -> bool;
		pub fn cv_face_FacemarkLBF_Params_propVerbose_bool(instance: *mut c_void, val: bool);
		pub fn cv_face_FacemarkLBF_Params_propN_landmarks_const(instance: *const c_void) -> i32;
		pub fn cv_face_FacemarkLBF_Params_propN_landmarks_int(instance: *mut c_void, val: i32);
		pub fn cv_face_FacemarkLBF_Params_propInitShape_n_const(instance: *const c_void) -> i32;
		pub fn cv_face_FacemarkLBF_Params_propInitShape_n_int(instance: *mut c_void, val: i32);
		pub fn cv_face_FacemarkLBF_Params_propStages_n_const(instance: *const c_void) -> i32;
		pub fn cv_face_FacemarkLBF_Params_propStages_n_int(instance: *mut c_void, val: i32);
		pub fn cv_face_FacemarkLBF_Params_propTree_n_const(instance: *const c_void) -> i32;
		pub fn cv_face_FacemarkLBF_Params_propTree_n_int(instance: *mut c_void, val: i32);
		pub fn cv_face_FacemarkLBF_Params_propTree_depth_const(instance: *const c_void) -> i32;
		pub fn cv_face_FacemarkLBF_Params_propTree_depth_int(instance: *mut c_void, val: i32);
		pub fn cv_face_FacemarkLBF_Params_propBagging_overlap_const(instance: *const c_void) -> f64;
		pub fn cv_face_FacemarkLBF_Params_propBagging_overlap_double(instance: *mut c_void, val: f64);
		pub fn cv_face_FacemarkLBF_Params_propModel_filename_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkLBF_Params_propModel_filename_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_face_FacemarkLBF_Params_propSave_model_const(instance: *const c_void) -> bool;
		pub fn cv_face_FacemarkLBF_Params_propSave_model_bool(instance: *mut c_void, val: bool);
		pub fn cv_face_FacemarkLBF_Params_propSeed_const(instance: *const c_void) -> u32;
		pub fn cv_face_FacemarkLBF_Params_propSeed_unsigned_int(instance: *mut c_void, val: u32);
		pub fn cv_face_FacemarkLBF_Params_propFeats_m_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkLBF_Params_propFeats_m_vectorLintG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkLBF_Params_propRadius_m_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_face_FacemarkLBF_Params_propRadius_m_vectorLdoubleG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_face_FacemarkLBF_Params_propDetectROI_const(instance: *const c_void, ocvrs_return: *mut core::Rect);
		pub fn cv_face_FacemarkLBF_Params_propDetectROI_Rect(instance: *mut c_void, val: *const core::Rect);
		pub fn cv_face_FacemarkLBF_Params_delete(instance: *mut c_void);
		pub fn cv_face_FacemarkTrain_addTrainingSample_const__InputArrayR_const__InputArrayR(instance: *mut c_void, image: *const c_void, landmarks: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_FacemarkTrain_training_voidX(instance: *mut c_void, parameters: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_face_FacemarkTrain_training(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_face_FacemarkTrain_setFaceDetector_FN_FaceDetector_voidX(instance: *mut c_void, detector: Option<unsafe extern "C" fn(*const c_void, *const c_void, *mut c_void) -> bool>, user_data: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_FacemarkTrain_getFaces_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, faces: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_FacemarkTrain_getData_voidX(instance: *mut c_void, items: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_FacemarkTrain_getData(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_FacemarkTrain_to_FacemarkAAM(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FacemarkTrain_to_FacemarkLBF(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FacemarkTrain_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FacemarkTrain_to_Facemark(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FacemarkTrain_delete(instance: *mut c_void);
		pub fn cv_face_FisherFaceRecognizer_create_int_double(num_components: i32, threshold: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_FisherFaceRecognizer_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_FisherFaceRecognizer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FisherFaceRecognizer_to_BasicFaceRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FisherFaceRecognizer_to_FaceRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_FisherFaceRecognizer_delete(instance: *mut c_void);
		pub fn cv_face_LBPHFaceRecognizer_getGridX_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_face_LBPHFaceRecognizer_setGridX_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_face_LBPHFaceRecognizer_getGridY_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_face_LBPHFaceRecognizer_setGridY_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_face_LBPHFaceRecognizer_getRadius_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_face_LBPHFaceRecognizer_setRadius_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_face_LBPHFaceRecognizer_getNeighbors_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_face_LBPHFaceRecognizer_setNeighbors_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_face_LBPHFaceRecognizer_getThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_face_LBPHFaceRecognizer_setThreshold_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_face_LBPHFaceRecognizer_getHistograms_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_LBPHFaceRecognizer_getLabels_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_LBPHFaceRecognizer_create_int_int_int_int_double(radius: i32, neighbors: i32, grid_x: i32, grid_y: i32, threshold: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_LBPHFaceRecognizer_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_LBPHFaceRecognizer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_LBPHFaceRecognizer_to_FaceRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_LBPHFaceRecognizer_delete(instance: *mut c_void);
		pub fn cv_face_MACE_salt_const_StringR(instance: *mut c_void, passphrase: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_face_MACE_train_const__InputArrayR(instance: *mut c_void, images: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_face_MACE_same_const_const__InputArrayR(instance: *const c_void, query: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_MACE_load_const_StringR_const_StringR(filename: *const c_char, objname: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_MACE_load_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_MACE_create_int(imgsize: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_MACE_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_MACE_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_MACE_delete(instance: *mut c_void);
		pub fn cv_face_PredictCollector_init_size_t(instance: *mut c_void, size: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_face_PredictCollector_collect_int_double(instance: *mut c_void, label: i32, dist: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_PredictCollector_to_StandardCollector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_PredictCollector_delete(instance: *mut c_void);
		pub fn cv_face_StandardCollector_StandardCollector_double(threshold_: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_StandardCollector_StandardCollector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_StandardCollector_init_size_t(instance: *mut c_void, size: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_face_StandardCollector_collect_int_double(instance: *mut c_void, label: i32, dist: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_face_StandardCollector_getMinLabel_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_face_StandardCollector_getMinDist_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_face_StandardCollector_getResults_const_bool(instance: *const c_void, sorted: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_StandardCollector_getResults_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_StandardCollector_create_double(threshold: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_StandardCollector_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_face_StandardCollector_to_PredictCollector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_face_StandardCollector_delete(instance: *mut c_void);
		pub fn cv_face_StandardCollector_PredictResult_PredictResult_int_double(label_: i32, distance_: f64, ocvrs_return: *mut Result<crate::face::StandardCollector_PredictResult>);
		pub fn cv_face_StandardCollector_PredictResult_PredictResult(ocvrs_return: *mut Result<crate::face::StandardCollector_PredictResult>);
		pub fn cv_PtrLcv_face_BIFG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_BIFG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_BIFG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_face_BIFG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_BasicFaceRecognizerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_BasicFaceRecognizerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_BasicFaceRecognizerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_face_BasicFaceRecognizerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_BasicFaceRecognizerG_to_PtrOfFaceRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_EigenFaceRecognizerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_EigenFaceRecognizerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_EigenFaceRecognizerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_face_EigenFaceRecognizerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_EigenFaceRecognizerG_to_PtrOfBasicFaceRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_EigenFaceRecognizerG_to_PtrOfFaceRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FaceRecognizerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FaceRecognizerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FaceRecognizerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_face_FaceRecognizerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_face_FacemarkG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkAAMG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkAAMG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkAAMG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_face_FacemarkAAMG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkAAMG_to_PtrOfFacemark(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkAAMG_to_PtrOfFacemarkTrain(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkKazemiG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkKazemiG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkKazemiG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_face_FacemarkKazemiG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkKazemiG_to_PtrOfFacemark(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkLBFG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkLBFG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkLBFG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_face_FacemarkLBFG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkLBFG_to_PtrOfFacemark(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkLBFG_to_PtrOfFacemarkTrain(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkTrainG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkTrainG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkTrainG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_face_FacemarkTrainG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FacemarkTrainG_to_PtrOfFacemark(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FisherFaceRecognizerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FisherFaceRecognizerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FisherFaceRecognizerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_face_FisherFaceRecognizerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FisherFaceRecognizerG_to_PtrOfBasicFaceRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_FisherFaceRecognizerG_to_PtrOfFaceRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_LBPHFaceRecognizerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_LBPHFaceRecognizerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_LBPHFaceRecognizerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_face_LBPHFaceRecognizerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_LBPHFaceRecognizerG_to_PtrOfFaceRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_MACEG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_MACEG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_MACEG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_face_MACEG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_PredictCollectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_PredictCollectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_PredictCollectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_face_StandardCollectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_StandardCollectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_StandardCollectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_face_StandardCollectorG_to_PtrOfPredictCollector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_face_StandardCollectorG_new_const_StandardCollector(val: *mut c_void) -> *mut c_void;
		pub fn std_vectorLcv_face_FacemarkAAM_ConfigG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_face_FacemarkAAM_ConfigG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_face_FacemarkAAM_ConfigG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_face_FacemarkAAM_ConfigG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_face_FacemarkAAM_ConfigG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_face_FacemarkAAM_ConfigG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_face_FacemarkAAM_ConfigG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_face_FacemarkAAM_ConfigG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_face_FacemarkAAM_ConfigG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_face_FacemarkAAM_ConfigG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_face_FacemarkAAM_ConfigG_push_const_Config(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_face_FacemarkAAM_ConfigG_insert_size_t_const_Config(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_face_FacemarkAAM_ConfigG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_face_FacemarkAAM_ConfigG_set_size_t_const_Config(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_face_FacemarkAAM_Model_TextureG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_face_FacemarkAAM_Model_TextureG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_face_FacemarkAAM_Model_TextureG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_face_FacemarkAAM_Model_TextureG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_face_FacemarkAAM_Model_TextureG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_face_FacemarkAAM_Model_TextureG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_face_FacemarkAAM_Model_TextureG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_face_FacemarkAAM_Model_TextureG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_face_FacemarkAAM_Model_TextureG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_face_FacemarkAAM_Model_TextureG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_face_FacemarkAAM_Model_TextureG_push_const_Texture(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_face_FacemarkAAM_Model_TextureG_insert_size_t_const_Texture(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_face_FacemarkAAM_Model_TextureG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_face_FacemarkAAM_Model_TextureG_set_size_t_const_Texture(instance: *mut c_void, index: size_t, val: *const c_void);
	}
}
#[cfg(ocvrs_has_module_face)]
pub use face_sys::*;

#[cfg(ocvrs_has_module_features2d)]
mod features2d_sys {
	use super::*;

	extern "C" {
		pub fn cv_AGAST_const__InputArrayR_vectorLKeyPointGR_int(image: *const c_void, keypoints: *mut c_void, threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_AGAST_const__InputArrayR_vectorLKeyPointGR_int_bool(image: *const c_void, keypoints: *mut c_void, threshold: i32, nonmax_suppression: bool, ocvrs_return: *mut Result_void);
		pub fn cv_AGAST_const__InputArrayR_vectorLKeyPointGR_int_bool_DetectorType(image: *const c_void, keypoints: *mut c_void, threshold: i32, nonmax_suppression: bool, typ: crate::features2d::AgastFeatureDetector_DetectorType, ocvrs_return: *mut Result_void);
		pub fn cv_FAST_const__InputArrayR_vectorLKeyPointGR_int(image: *const c_void, keypoints: *mut c_void, threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FAST_const__InputArrayR_vectorLKeyPointGR_int_bool(image: *const c_void, keypoints: *mut c_void, threshold: i32, nonmax_suppression: bool, ocvrs_return: *mut Result_void);
		pub fn cv_FAST_const__InputArrayR_vectorLKeyPointGR_int_bool_DetectorType(image: *const c_void, keypoints: *mut c_void, threshold: i32, nonmax_suppression: bool, typ: crate::features2d::FastFeatureDetector_DetectorType, ocvrs_return: *mut Result_void);
		pub fn cv_computeRecallPrecisionCurve_const_vectorLvectorLDMatchGGR_const_vectorLvectorLunsigned_charGGR_vectorLPoint2fGR(matches1to2: *const c_void, correct_matches1to2_mask: *const c_void, recall_precision_curve: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_drawKeypoints_const__InputArrayR_const_vectorLKeyPointGR_const__InputOutputArrayR(image: *const c_void, keypoints: *const c_void, out_image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_drawKeypoints_const__InputArrayR_const_vectorLKeyPointGR_const__InputOutputArrayR_const_ScalarR_DrawMatchesFlags(image: *const c_void, keypoints: *const c_void, out_image: *const c_void, color: *const core::Scalar, flags: crate::features2d::DrawMatchesFlags, ocvrs_return: *mut Result_void);
		pub fn cv_drawMatches_const__InputArrayR_const_vectorLKeyPointGR_const__InputArrayR_const_vectorLKeyPointGR_const_vectorLDMatchGR_const__InputOutputArrayR(img1: *const c_void, keypoints1: *const c_void, img2: *const c_void, keypoints2: *const c_void, matches1to2: *const c_void, out_img: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_drawMatches_const__InputArrayR_const_vectorLKeyPointGR_const__InputArrayR_const_vectorLKeyPointGR_const_vectorLDMatchGR_const__InputOutputArrayR_const_ScalarR_const_ScalarR_const_vectorLcharGR_DrawMatchesFlags(img1: *const c_void, keypoints1: *const c_void, img2: *const c_void, keypoints2: *const c_void, matches1to2: *const c_void, out_img: *const c_void, match_color: *const core::Scalar, single_point_color: *const core::Scalar, matches_mask: *const c_void, flags: crate::features2d::DrawMatchesFlags, ocvrs_return: *mut Result_void);
		pub fn cv_drawMatches_const__InputArrayR_const_vectorLKeyPointGR_const__InputArrayR_const_vectorLKeyPointGR_const_vectorLDMatchGR_const__InputOutputArrayR_const_int(img1: *const c_void, keypoints1: *const c_void, img2: *const c_void, keypoints2: *const c_void, matches1to2: *const c_void, out_img: *const c_void, matches_thickness: i32, ocvrs_return: *mut Result_void);
		pub fn cv_drawMatches_const__InputArrayR_const_vectorLKeyPointGR_const__InputArrayR_const_vectorLKeyPointGR_const_vectorLDMatchGR_const__InputOutputArrayR_const_int_const_ScalarR_const_ScalarR_const_vectorLcharGR_DrawMatchesFlags(img1: *const c_void, keypoints1: *const c_void, img2: *const c_void, keypoints2: *const c_void, matches1to2: *const c_void, out_img: *const c_void, matches_thickness: i32, match_color: *const core::Scalar, single_point_color: *const core::Scalar, matches_mask: *const c_void, flags: crate::features2d::DrawMatchesFlags, ocvrs_return: *mut Result_void);
		pub fn cv_drawMatches_const__InputArrayR_const_vectorLKeyPointGR_const__InputArrayR_const_vectorLKeyPointGR_const_vectorLvectorLDMatchGGR_const__InputOutputArrayR(img1: *const c_void, keypoints1: *const c_void, img2: *const c_void, keypoints2: *const c_void, matches1to2: *const c_void, out_img: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_drawMatches_const__InputArrayR_const_vectorLKeyPointGR_const__InputArrayR_const_vectorLKeyPointGR_const_vectorLvectorLDMatchGGR_const__InputOutputArrayR_const_ScalarR_const_ScalarR_const_vectorLvectorLcharGGR_DrawMatchesFlags(img1: *const c_void, keypoints1: *const c_void, img2: *const c_void, keypoints2: *const c_void, matches1to2: *const c_void, out_img: *const c_void, match_color: *const core::Scalar, single_point_color: *const core::Scalar, matches_mask: *const c_void, flags: crate::features2d::DrawMatchesFlags, ocvrs_return: *mut Result_void);
		pub fn cv_evaluateFeatureDetector_const_MatR_const_MatR_const_MatR_vectorLKeyPointGX_vectorLKeyPointGX_floatR_intR(img1: *const c_void, img2: *const c_void, h1to2: *const c_void, keypoints1: *mut c_void, keypoints2: *mut c_void, repeatability: *mut f32, corresp_count: *mut i32, ocvrs_return: *mut Result_void);
		pub fn cv_evaluateFeatureDetector_const_MatR_const_MatR_const_MatR_vectorLKeyPointGX_vectorLKeyPointGX_floatR_intR_const_PtrLFeature2DGR(img1: *const c_void, img2: *const c_void, h1to2: *const c_void, keypoints1: *mut c_void, keypoints2: *mut c_void, repeatability: *mut f32, corresp_count: *mut i32, fdetector: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_getNearestPoint_const_vectorLPoint2fGR_float(recall_precision_curve: *const c_void, l_precision: f32, ocvrs_return: *mut Result<i32>);
		pub fn cv_getRecall_const_vectorLPoint2fGR_float(recall_precision_curve: *const c_void, l_precision: f32, ocvrs_return: *mut Result<f32>);
		pub fn cv_AKAZE_create_DescriptorType_int_int_float_int_int_DiffusivityType(descriptor_type: crate::features2d::AKAZE_DescriptorType, descriptor_size: i32, descriptor_channels: i32, threshold: f32, n_octaves: i32, n_octave_layers: i32, diffusivity: crate::features2d::KAZE_DiffusivityType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AKAZE_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AKAZE_setDescriptorType_DescriptorType(instance: *mut c_void, dtype: crate::features2d::AKAZE_DescriptorType, ocvrs_return: *mut Result_void);
		pub fn cv_AKAZE_getDescriptorType_const(instance: *const c_void, ocvrs_return: *mut Result<crate::features2d::AKAZE_DescriptorType>);
		pub fn cv_AKAZE_setDescriptorSize_int(instance: *mut c_void, dsize: i32, ocvrs_return: *mut Result_void);
		pub fn cv_AKAZE_getDescriptorSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_AKAZE_setDescriptorChannels_int(instance: *mut c_void, dch: i32, ocvrs_return: *mut Result_void);
		pub fn cv_AKAZE_getDescriptorChannels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_AKAZE_setThreshold_double(instance: *mut c_void, threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_AKAZE_getThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_AKAZE_setNOctaves_int(instance: *mut c_void, octaves: i32, ocvrs_return: *mut Result_void);
		pub fn cv_AKAZE_getNOctaves_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_AKAZE_setNOctaveLayers_int(instance: *mut c_void, octave_layers: i32, ocvrs_return: *mut Result_void);
		pub fn cv_AKAZE_getNOctaveLayers_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_AKAZE_setDiffusivity_DiffusivityType(instance: *mut c_void, diff: crate::features2d::KAZE_DiffusivityType, ocvrs_return: *mut Result_void);
		pub fn cv_AKAZE_getDiffusivity_const(instance: *const c_void, ocvrs_return: *mut Result<crate::features2d::KAZE_DiffusivityType>);
		pub fn cv_AKAZE_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AKAZE_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_AKAZE_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_AKAZE_delete(instance: *mut c_void);
		pub fn cv_AffineFeature_create_const_PtrLFeature2DGR_int_int_float_float(backend: *const c_void, max_tilt: i32, min_tilt: i32, tilt_step: f32, rotate_step_base: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AffineFeature_create_const_PtrLFeature2DGR(backend: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AffineFeature_setViewParams_const_vectorLfloatGR_const_vectorLfloatGR(instance: *mut c_void, tilts: *const c_void, rolls: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_AffineFeature_getViewParams_const_vectorLfloatGR_vectorLfloatGR(instance: *const c_void, tilts: *mut c_void, rolls: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_AffineFeature_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AffineFeature_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_AffineFeature_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_AffineFeature_delete(instance: *mut c_void);
		pub fn cv_AgastFeatureDetector_create_int_bool_DetectorType(threshold: i32, nonmax_suppression: bool, typ: crate::features2d::AgastFeatureDetector_DetectorType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AgastFeatureDetector_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AgastFeatureDetector_setThreshold_int(instance: *mut c_void, threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_AgastFeatureDetector_getThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_AgastFeatureDetector_setNonmaxSuppression_bool(instance: *mut c_void, f: bool, ocvrs_return: *mut Result_void);
		pub fn cv_AgastFeatureDetector_getNonmaxSuppression_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_AgastFeatureDetector_setType_DetectorType(instance: *mut c_void, typ: crate::features2d::AgastFeatureDetector_DetectorType, ocvrs_return: *mut Result_void);
		pub fn cv_AgastFeatureDetector_getType_const(instance: *const c_void, ocvrs_return: *mut Result<crate::features2d::AgastFeatureDetector_DetectorType>);
		pub fn cv_AgastFeatureDetector_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AgastFeatureDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_AgastFeatureDetector_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_AgastFeatureDetector_delete(instance: *mut c_void);
		pub fn cv_BFMatcher_BFMatcher_int_bool(norm_type: i32, cross_check: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BFMatcher_BFMatcher(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BFMatcher_isMaskSupported_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_BFMatcher_create_int_bool(norm_type: i32, cross_check: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BFMatcher_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BFMatcher_clone_const_bool(instance: *const c_void, empty_train_data: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BFMatcher_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BFMatcher_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_BFMatcher_to_DescriptorMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_BFMatcher_delete(instance: *mut c_void);
		pub fn cv_BOWImgDescriptorExtractor_BOWImgDescriptorExtractor_const_PtrLFeature2DGR_const_PtrLDescriptorMatcherGR(dextractor: *const c_void, dmatcher: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWImgDescriptorExtractor_BOWImgDescriptorExtractor_const_PtrLDescriptorMatcherGR(dmatcher: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWImgDescriptorExtractor_setVocabulary_const_MatR(instance: *mut c_void, vocabulary: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BOWImgDescriptorExtractor_getVocabulary_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWImgDescriptorExtractor_compute_const__InputArrayR_vectorLKeyPointGR_const__OutputArrayR_vectorLvectorLintGGX_MatX(instance: *mut c_void, image: *const c_void, keypoints: *mut c_void, img_descriptor: *const c_void, point_idxs_of_clusters: *mut c_void, descriptors: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BOWImgDescriptorExtractor_compute_const__InputArrayR_vectorLKeyPointGR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, keypoints: *mut c_void, img_descriptor: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BOWImgDescriptorExtractor_compute_const__InputArrayR_const__OutputArrayR_vectorLvectorLintGGX(instance: *mut c_void, keypoint_descriptors: *const c_void, img_descriptor: *const c_void, point_idxs_of_clusters: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BOWImgDescriptorExtractor_compute_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, keypoint_descriptors: *const c_void, img_descriptor: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BOWImgDescriptorExtractor_compute2_const_MatR_vectorLKeyPointGR_MatR(instance: *mut c_void, image: *const c_void, keypoints: *mut c_void, img_descriptor: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BOWImgDescriptorExtractor_descriptorSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BOWImgDescriptorExtractor_descriptorType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BOWImgDescriptorExtractor_delete(instance: *mut c_void);
		pub fn cv_BOWKMeansTrainer_BOWKMeansTrainer_int_const_TermCriteriaR_int_int(cluster_count: i32, termcrit: *const core::TermCriteria, attempts: i32, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWKMeansTrainer_BOWKMeansTrainer_int(cluster_count: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWKMeansTrainer_cluster_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWKMeansTrainer_cluster_const_const_MatR(instance: *const c_void, descriptors: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWKMeansTrainer_to_BOWTrainer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_BOWKMeansTrainer_delete(instance: *mut c_void);
		pub fn cv_BOWTrainer_add_const_MatR(instance: *mut c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BOWTrainer_getDescriptors_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWTrainer_descriptorsCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BOWTrainer_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BOWTrainer_cluster_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWTrainer_cluster_const_const_MatR(instance: *const c_void, descriptors: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BOWTrainer_to_BOWKMeansTrainer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_BOWTrainer_delete(instance: *mut c_void);
		pub fn cv_BRISK_create_int_int_float(thresh: i32, octaves: i32, pattern_scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BRISK_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BRISK_create_const_vectorLfloatGR_const_vectorLintGR_float_float_const_vectorLintGR(radius_list: *const c_void, number_list: *const c_void, d_max: f32, d_min: f32, index_change: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BRISK_create_const_vectorLfloatGR_const_vectorLintGR(radius_list: *const c_void, number_list: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BRISK_create_int_int_const_vectorLfloatGR_const_vectorLintGR_float_float_const_vectorLintGR(thresh: i32, octaves: i32, radius_list: *const c_void, number_list: *const c_void, d_max: f32, d_min: f32, index_change: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BRISK_create_int_int_const_vectorLfloatGR_const_vectorLintGR(thresh: i32, octaves: i32, radius_list: *const c_void, number_list: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BRISK_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BRISK_setThreshold_int(instance: *mut c_void, threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_BRISK_getThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BRISK_setOctaves_int(instance: *mut c_void, octaves: i32, ocvrs_return: *mut Result_void);
		pub fn cv_BRISK_getOctaves_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BRISK_setPatternScale_float(instance: *mut c_void, pattern_scale: f32, ocvrs_return: *mut Result_void);
		pub fn cv_BRISK_getPatternScale_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_BRISK_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_BRISK_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_BRISK_delete(instance: *mut c_void);
		pub fn cv_DescriptorMatcher_add_const__InputArrayR(instance: *mut c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_getTrainDescriptors_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DescriptorMatcher_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_DescriptorMatcher_isMaskSupported_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_DescriptorMatcher_train(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_match_const_const__InputArrayR_const__InputArrayR_vectorLDMatchGR_const__InputArrayR(instance: *const c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_match_const_const__InputArrayR_const__InputArrayR_vectorLDMatchGR(instance: *const c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_knnMatch_const_const__InputArrayR_const__InputArrayR_vectorLvectorLDMatchGGR_int_const__InputArrayR_bool(instance: *const c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, k: i32, mask: *const c_void, compact_result: bool, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_knnMatch_const_const__InputArrayR_const__InputArrayR_vectorLvectorLDMatchGGR_int(instance: *const c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_radiusMatch_const_const__InputArrayR_const__InputArrayR_vectorLvectorLDMatchGGR_float_const__InputArrayR_bool(instance: *const c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, max_distance: f32, mask: *const c_void, compact_result: bool, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_radiusMatch_const_const__InputArrayR_const__InputArrayR_vectorLvectorLDMatchGGR_float(instance: *const c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, max_distance: f32, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_match_const__InputArrayR_vectorLDMatchGR_const__InputArrayR(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_match_const__InputArrayR_vectorLDMatchGR(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_knnMatch_const__InputArrayR_vectorLvectorLDMatchGGR_int_const__InputArrayR_bool(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, k: i32, masks: *const c_void, compact_result: bool, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_knnMatch_const__InputArrayR_vectorLvectorLDMatchGGR_int(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_radiusMatch_const__InputArrayR_vectorLvectorLDMatchGGR_float_const__InputArrayR_bool(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, max_distance: f32, masks: *const c_void, compact_result: bool, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_radiusMatch_const__InputArrayR_vectorLvectorLDMatchGGR_float(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, max_distance: f32, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_write_const_const_StringR(instance: *const c_void, file_name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_read_const_StringR(instance: *mut c_void, file_name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_read_const_FileNodeR(instance: *mut c_void, unnamed: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_write_const_FileStorageR(instance: *const c_void, unnamed: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_clone_const_bool(instance: *const c_void, empty_train_data: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DescriptorMatcher_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DescriptorMatcher_create_const_StringR(descriptor_matcher_type: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DescriptorMatcher_create_const_MatcherTypeR(matcher_type: *const crate::features2d::DescriptorMatcher_MatcherType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DescriptorMatcher_write_const_FileStorageR_const_StringR(instance: *const c_void, fs: *mut c_void, name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_write_const_const_PtrLFileStorageGR_const_StringR(instance: *const c_void, fs: *const c_void, name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_DescriptorMatcher_to_BFMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_DescriptorMatcher_to_FlannBasedMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_DescriptorMatcher_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_DescriptorMatcher_delete(instance: *mut c_void);
		pub fn cv_FastFeatureDetector_create_int_bool_DetectorType(threshold: i32, nonmax_suppression: bool, typ: crate::features2d::FastFeatureDetector_DetectorType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FastFeatureDetector_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FastFeatureDetector_setThreshold_int(instance: *mut c_void, threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FastFeatureDetector_getThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FastFeatureDetector_setNonmaxSuppression_bool(instance: *mut c_void, f: bool, ocvrs_return: *mut Result_void);
		pub fn cv_FastFeatureDetector_getNonmaxSuppression_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FastFeatureDetector_setType_DetectorType(instance: *mut c_void, typ: crate::features2d::FastFeatureDetector_DetectorType, ocvrs_return: *mut Result_void);
		pub fn cv_FastFeatureDetector_getType_const(instance: *const c_void, ocvrs_return: *mut Result<crate::features2d::FastFeatureDetector_DetectorType>);
		pub fn cv_FastFeatureDetector_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FastFeatureDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_FastFeatureDetector_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_FastFeatureDetector_delete(instance: *mut c_void);
		pub fn cv_Feature2D_detect_const__InputArrayR_vectorLKeyPointGR_const__InputArrayR(instance: *mut c_void, image: *const c_void, keypoints: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_detect_const__InputArrayR_vectorLKeyPointGR(instance: *mut c_void, image: *const c_void, keypoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_detect_const__InputArrayR_vectorLvectorLKeyPointGGR_const__InputArrayR(instance: *mut c_void, images: *const c_void, keypoints: *mut c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_detect_const__InputArrayR_vectorLvectorLKeyPointGGR(instance: *mut c_void, images: *const c_void, keypoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_compute_const__InputArrayR_vectorLKeyPointGR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, keypoints: *mut c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_compute_const__InputArrayR_vectorLvectorLKeyPointGGR_const__OutputArrayR(instance: *mut c_void, images: *const c_void, keypoints: *mut c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_detectAndCompute_const__InputArrayR_const__InputArrayR_vectorLKeyPointGR_const__OutputArrayR_bool(instance: *mut c_void, image: *const c_void, mask: *const c_void, keypoints: *mut c_void, descriptors: *const c_void, use_provided_keypoints: bool, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_detectAndCompute_const__InputArrayR_const__InputArrayR_vectorLKeyPointGR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, mask: *const c_void, keypoints: *mut c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_descriptorSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_Feature2D_descriptorType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_Feature2D_defaultNorm_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_Feature2D_write_const_const_StringR(instance: *const c_void, file_name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_read_const_StringR(instance: *mut c_void, file_name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_write_const_FileStorageR(instance: *const c_void, unnamed: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_read_const_FileNodeR(instance: *mut c_void, unnamed: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_Feature2D_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Feature2D_write_const_FileStorageR_const_StringR(instance: *const c_void, fs: *mut c_void, name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_write_const_const_PtrLFileStorageGR_const_StringR(instance: *const c_void, fs: *const c_void, name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_Feature2D_to_AKAZE(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Feature2D_to_AffineFeature(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Feature2D_to_AgastFeatureDetector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Feature2D_to_BRISK(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Feature2D_to_FastFeatureDetector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Feature2D_to_GFTTDetector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Feature2D_to_KAZE(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Feature2D_to_MSER(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Feature2D_to_ORB(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Feature2D_to_SIFT(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Feature2D_to_SimpleBlobDetector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Feature2D_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Feature2D_delete(instance: *mut c_void);
		pub fn cv_FlannBasedMatcher_FlannBasedMatcher_const_PtrLIndexParamsGR_const_PtrLSearchParamsGR(index_params: *const c_void, search_params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FlannBasedMatcher_FlannBasedMatcher(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FlannBasedMatcher_add_const__InputArrayR(instance: *mut c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FlannBasedMatcher_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FlannBasedMatcher_read_const_FileNodeR(instance: *mut c_void, unnamed: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FlannBasedMatcher_write_const_FileStorageR(instance: *const c_void, unnamed: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FlannBasedMatcher_train(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FlannBasedMatcher_isMaskSupported_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FlannBasedMatcher_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FlannBasedMatcher_clone_const_bool(instance: *const c_void, empty_train_data: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FlannBasedMatcher_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FlannBasedMatcher_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_FlannBasedMatcher_to_DescriptorMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_FlannBasedMatcher_delete(instance: *mut c_void);
		pub fn cv_GFTTDetector_create_int_double_double_int_bool_double(max_corners: i32, quality_level: f64, min_distance: f64, block_size: i32, use_harris_detector: bool, k: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GFTTDetector_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GFTTDetector_create_int_double_double_int_int_bool_double(max_corners: i32, quality_level: f64, min_distance: f64, block_size: i32, gradiant_size: i32, use_harris_detector: bool, k: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GFTTDetector_create_int_double_double_int_int(max_corners: i32, quality_level: f64, min_distance: f64, block_size: i32, gradiant_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GFTTDetector_setMaxFeatures_int(instance: *mut c_void, max_features: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GFTTDetector_getMaxFeatures_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GFTTDetector_setQualityLevel_double(instance: *mut c_void, qlevel: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GFTTDetector_getQualityLevel_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GFTTDetector_setMinDistance_double(instance: *mut c_void, min_distance: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GFTTDetector_getMinDistance_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GFTTDetector_setBlockSize_int(instance: *mut c_void, block_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GFTTDetector_getBlockSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GFTTDetector_setGradientSize_int(instance: *mut c_void, gradient_size_: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GFTTDetector_getGradientSize(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GFTTDetector_setHarrisDetector_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_GFTTDetector_getHarrisDetector_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GFTTDetector_setK_double(instance: *mut c_void, k: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GFTTDetector_getK_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GFTTDetector_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GFTTDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_GFTTDetector_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_GFTTDetector_delete(instance: *mut c_void);
		pub fn cv_KAZE_create_bool_bool_float_int_int_DiffusivityType(extended: bool, upright: bool, threshold: f32, n_octaves: i32, n_octave_layers: i32, diffusivity: crate::features2d::KAZE_DiffusivityType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KAZE_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KAZE_setExtended_bool(instance: *mut c_void, extended: bool, ocvrs_return: *mut Result_void);
		pub fn cv_KAZE_getExtended_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_KAZE_setUpright_bool(instance: *mut c_void, upright: bool, ocvrs_return: *mut Result_void);
		pub fn cv_KAZE_getUpright_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_KAZE_setThreshold_double(instance: *mut c_void, threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_KAZE_getThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_KAZE_setNOctaves_int(instance: *mut c_void, octaves: i32, ocvrs_return: *mut Result_void);
		pub fn cv_KAZE_getNOctaves_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_KAZE_setNOctaveLayers_int(instance: *mut c_void, octave_layers: i32, ocvrs_return: *mut Result_void);
		pub fn cv_KAZE_getNOctaveLayers_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_KAZE_setDiffusivity_DiffusivityType(instance: *mut c_void, diff: crate::features2d::KAZE_DiffusivityType, ocvrs_return: *mut Result_void);
		pub fn cv_KAZE_getDiffusivity_const(instance: *const c_void, ocvrs_return: *mut Result<crate::features2d::KAZE_DiffusivityType>);
		pub fn cv_KAZE_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KAZE_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_KAZE_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_KAZE_delete(instance: *mut c_void);
		pub fn cv_KeyPointsFilter_KeyPointsFilter(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KeyPointsFilter_runByImageBorder_vectorLKeyPointGR_Size_int(keypoints: *mut c_void, image_size: *const core::Size, border_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPointsFilter_runByKeypointSize_vectorLKeyPointGR_float_float(keypoints: *mut c_void, min_size: f32, max_size: f32, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPointsFilter_runByKeypointSize_vectorLKeyPointGR_float(keypoints: *mut c_void, min_size: f32, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPointsFilter_runByPixelsMask_vectorLKeyPointGR_const_MatR(keypoints: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPointsFilter_runByPixelsMask2VectorPoint_vectorLKeyPointGR_vectorLvectorLPointGGR_const_MatR(keypoints: *mut c_void, remove_from: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPointsFilter_removeDuplicated_vectorLKeyPointGR(keypoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPointsFilter_removeDuplicatedSorted_vectorLKeyPointGR(keypoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPointsFilter_retainBest_vectorLKeyPointGR_int(keypoints: *mut c_void, npoints: i32, ocvrs_return: *mut Result_void);
		pub fn cv_KeyPointsFilter_delete(instance: *mut c_void);
		pub fn cv_MSER_create_int_int_int_double_double_int_double_double_int(delta: i32, min_area: i32, max_area: i32, max_variation: f64, min_diversity: f64, max_evolution: i32, area_threshold: f64, min_margin: f64, edge_blur_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MSER_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MSER_detectRegions_const__InputArrayR_vectorLvectorLPointGGR_vectorLRectGR(instance: *mut c_void, image: *const c_void, msers: *mut c_void, bboxes: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MSER_setDelta_int(instance: *mut c_void, delta: i32, ocvrs_return: *mut Result_void);
		pub fn cv_MSER_getDelta_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_MSER_setMinArea_int(instance: *mut c_void, min_area: i32, ocvrs_return: *mut Result_void);
		pub fn cv_MSER_getMinArea_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_MSER_setMaxArea_int(instance: *mut c_void, max_area: i32, ocvrs_return: *mut Result_void);
		pub fn cv_MSER_getMaxArea_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_MSER_setMaxVariation_double(instance: *mut c_void, max_variation: f64, ocvrs_return: *mut Result_void);
		pub fn cv_MSER_getMaxVariation_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_MSER_setMinDiversity_double(instance: *mut c_void, min_diversity: f64, ocvrs_return: *mut Result_void);
		pub fn cv_MSER_getMinDiversity_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_MSER_setMaxEvolution_int(instance: *mut c_void, max_evolution: i32, ocvrs_return: *mut Result_void);
		pub fn cv_MSER_getMaxEvolution_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_MSER_setAreaThreshold_double(instance: *mut c_void, area_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_MSER_getAreaThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_MSER_setMinMargin_double(instance: *mut c_void, min_margin: f64, ocvrs_return: *mut Result_void);
		pub fn cv_MSER_getMinMargin_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_MSER_setEdgeBlurSize_int(instance: *mut c_void, edge_blur_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_MSER_getEdgeBlurSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_MSER_setPass2Only_bool(instance: *mut c_void, f: bool, ocvrs_return: *mut Result_void);
		pub fn cv_MSER_getPass2Only_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_MSER_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MSER_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MSER_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MSER_delete(instance: *mut c_void);
		pub fn cv_ORB_create_int_float_int_int_int_int_ScoreType_int_int(nfeatures: i32, scale_factor: f32, nlevels: i32, edge_threshold: i32, first_level: i32, wta_k: i32, score_type: crate::features2d::ORB_ScoreType, patch_size: i32, fast_threshold: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ORB_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ORB_setMaxFeatures_int(instance: *mut c_void, max_features: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ORB_getMaxFeatures_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ORB_setScaleFactor_double(instance: *mut c_void, scale_factor: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ORB_getScaleFactor_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ORB_setNLevels_int(instance: *mut c_void, nlevels: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ORB_getNLevels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ORB_setEdgeThreshold_int(instance: *mut c_void, edge_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ORB_getEdgeThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ORB_setFirstLevel_int(instance: *mut c_void, first_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ORB_getFirstLevel_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ORB_setWTA_K_int(instance: *mut c_void, wta_k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ORB_getWTA_K_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ORB_setScoreType_ScoreType(instance: *mut c_void, score_type: crate::features2d::ORB_ScoreType, ocvrs_return: *mut Result_void);
		pub fn cv_ORB_getScoreType_const(instance: *const c_void, ocvrs_return: *mut Result<crate::features2d::ORB_ScoreType>);
		pub fn cv_ORB_setPatchSize_int(instance: *mut c_void, patch_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ORB_getPatchSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ORB_setFastThreshold_int(instance: *mut c_void, fast_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ORB_getFastThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ORB_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ORB_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ORB_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ORB_delete(instance: *mut c_void);
		pub fn cv_SIFT_create_int_int_double_double_double_bool(nfeatures: i32, n_octave_layers: i32, contrast_threshold: f64, edge_threshold: f64, sigma: f64, enable_precise_upscale: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SIFT_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SIFT_create_int_int_double_double_double_int_bool(nfeatures: i32, n_octave_layers: i32, contrast_threshold: f64, edge_threshold: f64, sigma: f64, descriptor_type: i32, enable_precise_upscale: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SIFT_create_int_int_double_double_double_int(nfeatures: i32, n_octave_layers: i32, contrast_threshold: f64, edge_threshold: f64, sigma: f64, descriptor_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SIFT_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SIFT_setNFeatures_int(instance: *mut c_void, max_features: i32, ocvrs_return: *mut Result_void);
		pub fn cv_SIFT_getNFeatures_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_SIFT_setNOctaveLayers_int(instance: *mut c_void, n_octave_layers: i32, ocvrs_return: *mut Result_void);
		pub fn cv_SIFT_getNOctaveLayers_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_SIFT_setContrastThreshold_double(instance: *mut c_void, contrast_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_SIFT_getContrastThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_SIFT_setEdgeThreshold_double(instance: *mut c_void, edge_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_SIFT_getEdgeThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_SIFT_setSigma_double(instance: *mut c_void, sigma: f64, ocvrs_return: *mut Result_void);
		pub fn cv_SIFT_getSigma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_SIFT_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_SIFT_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_SIFT_delete(instance: *mut c_void);
		pub fn cv_SimpleBlobDetector_create_const_ParamsR(parameters: *const crate::features2d::SimpleBlobDetector_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SimpleBlobDetector_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SimpleBlobDetector_setParams_const_ParamsR(instance: *mut c_void, params: *const crate::features2d::SimpleBlobDetector_Params, ocvrs_return: *mut Result_void);
		pub fn cv_SimpleBlobDetector_getParams_const(instance: *const c_void, ocvrs_return: *mut Result<crate::features2d::SimpleBlobDetector_Params>);
		pub fn cv_SimpleBlobDetector_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SimpleBlobDetector_getBlobContours_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SimpleBlobDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_SimpleBlobDetector_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_SimpleBlobDetector_delete(instance: *mut c_void);
		pub fn cv_SimpleBlobDetector_Params_Params(ocvrs_return: *mut Result<crate::features2d::SimpleBlobDetector_Params>);
		pub fn cv_SimpleBlobDetector_Params_read_const_FileNodeR(instance: *const crate::features2d::SimpleBlobDetector_Params, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SimpleBlobDetector_Params_write_const_FileStorageR(instance: *const crate::features2d::SimpleBlobDetector_Params, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_PtrLcv_AKAZEG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AKAZEG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AKAZEG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_AKAZEG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AKAZEG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AffineFeatureG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AffineFeatureG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AffineFeatureG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_AffineFeatureG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AffineFeatureG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AgastFeatureDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AgastFeatureDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AgastFeatureDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_AgastFeatureDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AgastFeatureDetectorG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BFMatcherG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BFMatcherG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BFMatcherG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_BFMatcherG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BFMatcherG_to_PtrOfDescriptorMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BFMatcherG_new_const_BFMatcher(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BRISKG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BRISKG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BRISKG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_BRISKG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BRISKG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DescriptorMatcherG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DescriptorMatcherG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DescriptorMatcherG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_DescriptorMatcherG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FastFeatureDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FastFeatureDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FastFeatureDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_FastFeatureDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FastFeatureDetectorG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_Feature2DG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_Feature2DG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_Feature2DG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_Feature2DG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_Feature2DG_new_const_Feature2D(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FlannBasedMatcherG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FlannBasedMatcherG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FlannBasedMatcherG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_FlannBasedMatcherG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FlannBasedMatcherG_to_PtrOfDescriptorMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FlannBasedMatcherG_new_const_FlannBasedMatcher(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GFTTDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GFTTDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GFTTDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_GFTTDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GFTTDetectorG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_KAZEG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_KAZEG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_KAZEG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_KAZEG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_KAZEG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MSERG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MSERG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MSERG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_MSERG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MSERG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ORBG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ORBG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ORBG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ORBG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ORBG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SIFTG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SIFTG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SIFTG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_SIFTG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SIFTG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SimpleBlobDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SimpleBlobDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SimpleBlobDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_SimpleBlobDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SimpleBlobDetectorG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_features2d)]
pub use features2d_sys::*;

#[cfg(ocvrs_has_module_flann)]
mod flann_sys {
	use super::*;

	extern "C" {
		pub fn cvflann_flann_distance_type(ocvrs_return: *mut Result<crate::flann::flann_distance_t>);
		pub fn cvflann_set_distance_type_flann_distance_t_int(distance_type: crate::flann::flann_distance_t, order: i32, ocvrs_return: *mut Result_void);
		pub fn cv_flann_AutotunedIndexParams_AutotunedIndexParams_float_float_float_float(target_precision: f32, build_weight: f32, memory_weight: f32, sample_fraction: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_AutotunedIndexParams_AutotunedIndexParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_AutotunedIndexParams_to_IndexParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_flann_AutotunedIndexParams_delete(instance: *mut c_void);
		pub fn cv_flann_CompositeIndexParams_CompositeIndexParams_int_int_int_flann_centers_init_t_float(trees: i32, branching: i32, iterations: i32, centers_init: crate::flann::flann_centers_init_t, cb_index: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_CompositeIndexParams_CompositeIndexParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_CompositeIndexParams_to_IndexParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_flann_CompositeIndexParams_delete(instance: *mut c_void);
		pub fn cv_flann_HierarchicalClusteringIndexParams_HierarchicalClusteringIndexParams_int_flann_centers_init_t_int_int(branching: i32, centers_init: crate::flann::flann_centers_init_t, trees: i32, leaf_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_HierarchicalClusteringIndexParams_HierarchicalClusteringIndexParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_HierarchicalClusteringIndexParams_to_IndexParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_flann_HierarchicalClusteringIndexParams_delete(instance: *mut c_void);
		pub fn cv_flann_Index_Index(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_Index_Index_const__InputArrayR_const_IndexParamsR_flann_distance_t(features: *const c_void, params: *const c_void, dist_type: crate::flann::flann_distance_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_Index_Index_const__InputArrayR_const_IndexParamsR(features: *const c_void, params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_Index_build_const__InputArrayR_const_IndexParamsR_flann_distance_t(instance: *mut c_void, features: *const c_void, params: *const c_void, dist_type: crate::flann::flann_distance_t, ocvrs_return: *mut Result_void);
		pub fn cv_flann_Index_build_const__InputArrayR_const_IndexParamsR(instance: *mut c_void, features: *const c_void, params: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_flann_Index_knnSearch_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_const_SearchParamsR(instance: *mut c_void, query: *const c_void, indices: *const c_void, dists: *const c_void, knn: i32, params: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_flann_Index_knnSearch_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int(instance: *mut c_void, query: *const c_void, indices: *const c_void, dists: *const c_void, knn: i32, ocvrs_return: *mut Result_void);
		pub fn cv_flann_Index_radiusSearch_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double_int_const_SearchParamsR(instance: *mut c_void, query: *const c_void, indices: *const c_void, dists: *const c_void, radius: f64, max_results: i32, params: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_flann_Index_radiusSearch_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double_int(instance: *mut c_void, query: *const c_void, indices: *const c_void, dists: *const c_void, radius: f64, max_results: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_flann_Index_save_const_const_StringR(instance: *const c_void, filename: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_flann_Index_load_const__InputArrayR_const_StringR(instance: *mut c_void, features: *const c_void, filename: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_flann_Index_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_flann_Index_getDistance_const(instance: *const c_void, ocvrs_return: *mut Result<crate::flann::flann_distance_t>);
		pub fn cv_flann_Index_getAlgorithm_const(instance: *const c_void, ocvrs_return: *mut Result<crate::flann::flann_algorithm_t>);
		pub fn cv_flann_Index_delete(instance: *mut c_void);
		pub fn cv_flann_IndexParams_IndexParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_IndexParams_getString_const_const_StringR_const_StringR(instance: *const c_void, key: *const c_char, default_val: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_IndexParams_getString_const_const_StringR(instance: *const c_void, key: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_IndexParams_getInt_const_const_StringR_int(instance: *const c_void, key: *const c_char, default_val: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_flann_IndexParams_getInt_const_const_StringR(instance: *const c_void, key: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_flann_IndexParams_getDouble_const_const_StringR_double(instance: *const c_void, key: *const c_char, default_val: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_flann_IndexParams_getDouble_const_const_StringR(instance: *const c_void, key: *const c_char, ocvrs_return: *mut Result<f64>);
		pub fn cv_flann_IndexParams_setString_const_StringR_const_StringR(instance: *mut c_void, key: *const c_char, value: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_flann_IndexParams_setInt_const_StringR_int(instance: *mut c_void, key: *const c_char, value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_flann_IndexParams_setDouble_const_StringR_double(instance: *mut c_void, key: *const c_char, value: f64, ocvrs_return: *mut Result_void);
		pub fn cv_flann_IndexParams_setFloat_const_StringR_float(instance: *mut c_void, key: *const c_char, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_flann_IndexParams_setBool_const_StringR_bool(instance: *mut c_void, key: *const c_char, value: bool, ocvrs_return: *mut Result_void);
		pub fn cv_flann_IndexParams_setAlgorithm_int(instance: *mut c_void, value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_flann_IndexParams_getAll_const_vectorLStringGR_vectorLFlannIndexTypeGR_vectorLStringGR_vectorLdoubleGR(instance: *const c_void, names: *mut c_void, types: *mut c_void, str_values: *mut c_void, num_values: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_flann_IndexParams_propParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_flann_IndexParams_propParams_voidX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_flann_IndexParams_delete(instance: *mut c_void);
		pub fn cv_flann_KDTreeIndexParams_KDTreeIndexParams_int(trees: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_KDTreeIndexParams_KDTreeIndexParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_KDTreeIndexParams_to_IndexParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_flann_KDTreeIndexParams_delete(instance: *mut c_void);
		pub fn cv_flann_KMeansIndexParams_KMeansIndexParams_int_int_flann_centers_init_t_float(branching: i32, iterations: i32, centers_init: crate::flann::flann_centers_init_t, cb_index: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_KMeansIndexParams_KMeansIndexParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_KMeansIndexParams_to_IndexParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_flann_KMeansIndexParams_delete(instance: *mut c_void);
		pub fn cv_flann_LinearIndexParams_LinearIndexParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_LinearIndexParams_to_IndexParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_flann_LinearIndexParams_delete(instance: *mut c_void);
		pub fn cv_flann_LshIndexParams_LshIndexParams_int_int_int(table_number: i32, key_size: i32, multi_probe_level: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_LshIndexParams_to_IndexParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_flann_LshIndexParams_delete(instance: *mut c_void);
		pub fn cv_flann_SavedIndexParams_SavedIndexParams_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_SavedIndexParams_to_IndexParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_flann_SavedIndexParams_delete(instance: *mut c_void);
		pub fn cv_flann_SearchParams_SearchParams_int_float_bool_bool(checks: i32, eps: f32, sorted: bool, explore_all_trees: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_SearchParams_SearchParams_int_float_bool(checks: i32, eps: f32, sorted: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_SearchParams_SearchParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_flann_SearchParams_to_IndexParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_flann_SearchParams_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_flann_AutotunedIndexParamsG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_AutotunedIndexParamsG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_AutotunedIndexParamsG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_flann_AutotunedIndexParamsG_to_PtrOfIndexParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_AutotunedIndexParamsG_new_const_AutotunedIndexParams(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_CompositeIndexParamsG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_CompositeIndexParamsG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_CompositeIndexParamsG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_flann_CompositeIndexParamsG_to_PtrOfIndexParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_CompositeIndexParamsG_new_const_CompositeIndexParams(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_HierarchicalClusteringIndexParamsG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_HierarchicalClusteringIndexParamsG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_HierarchicalClusteringIndexParamsG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_flann_HierarchicalClusteringIndexParamsG_to_PtrOfIndexParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_HierarchicalClusteringIndexParamsG_new_const_HierarchicalClusteringIndexParams(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_IndexParamsG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_IndexParamsG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_IndexParamsG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_flann_IndexParamsG_new_const_IndexParams(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_KDTreeIndexParamsG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_KDTreeIndexParamsG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_KDTreeIndexParamsG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_flann_KDTreeIndexParamsG_to_PtrOfIndexParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_KDTreeIndexParamsG_new_const_KDTreeIndexParams(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_KMeansIndexParamsG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_KMeansIndexParamsG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_KMeansIndexParamsG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_flann_KMeansIndexParamsG_to_PtrOfIndexParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_KMeansIndexParamsG_new_const_KMeansIndexParams(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_LinearIndexParamsG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_LinearIndexParamsG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_LinearIndexParamsG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_flann_LinearIndexParamsG_to_PtrOfIndexParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_LinearIndexParamsG_new_const_LinearIndexParams(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_LshIndexParamsG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_LshIndexParamsG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_LshIndexParamsG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_flann_LshIndexParamsG_to_PtrOfIndexParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_LshIndexParamsG_new_const_LshIndexParams(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_SavedIndexParamsG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_SavedIndexParamsG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_SavedIndexParamsG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_flann_SavedIndexParamsG_to_PtrOfIndexParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_SavedIndexParamsG_new_const_SavedIndexParams(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_SearchParamsG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_SearchParamsG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_SearchParamsG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_flann_SearchParamsG_to_PtrOfIndexParams(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_flann_SearchParamsG_new_const_SearchParams(val: *mut c_void) -> *mut c_void;
		pub fn std_vectorLcv_flann_FlannIndexTypeG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_flann_FlannIndexTypeG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_flann_FlannIndexTypeG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_flann_FlannIndexTypeG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_flann_FlannIndexTypeG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_flann_FlannIndexTypeG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_flann_FlannIndexTypeG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_flann_FlannIndexTypeG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_flann_FlannIndexTypeG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_flann_FlannIndexTypeG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_flann_FlannIndexTypeG_push_const_FlannIndexType(instance: *mut c_void, val: crate::flann::FlannIndexType);
		pub fn std_vectorLcv_flann_FlannIndexTypeG_insert_size_t_const_FlannIndexType(instance: *mut c_void, index: size_t, val: crate::flann::FlannIndexType);
		pub fn std_vectorLcv_flann_FlannIndexTypeG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut crate::flann::FlannIndexType);
		pub fn std_vectorLcv_flann_FlannIndexTypeG_set_size_t_const_FlannIndexType(instance: *mut c_void, index: size_t, val: crate::flann::FlannIndexType);
		pub fn std_vectorLcv_flann_FlannIndexTypeG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_flann_FlannIndexTypeG_data_const(instance: *const c_void) -> *const crate::flann::FlannIndexType;
		pub fn std_vectorLcv_flann_FlannIndexTypeG_dataMut(instance: *mut c_void) -> *mut crate::flann::FlannIndexType;
		pub fn cv_fromSlice_const_const_FlannIndexTypeX_size_t(data: *const crate::flann::FlannIndexType, len: size_t) -> *mut c_void;
		pub fn std_vectorLcvflann_lsh_FeatureIndexG_new_const() -> *mut c_void;
		pub fn std_vectorLcvflann_lsh_FeatureIndexG_delete(instance: *mut c_void);
		pub fn std_vectorLcvflann_lsh_FeatureIndexG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcvflann_lsh_FeatureIndexG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcvflann_lsh_FeatureIndexG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcvflann_lsh_FeatureIndexG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcvflann_lsh_FeatureIndexG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcvflann_lsh_FeatureIndexG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcvflann_lsh_FeatureIndexG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcvflann_lsh_FeatureIndexG_clear(instance: *mut c_void);
		pub fn std_vectorLcvflann_lsh_FeatureIndexG_push_const_FeatureIndex(instance: *mut c_void, val: crate::flann::feature_index);
		pub fn std_vectorLcvflann_lsh_FeatureIndexG_insert_size_t_const_FeatureIndex(instance: *mut c_void, index: size_t, val: crate::flann::feature_index);
		pub fn std_vectorLcvflann_lsh_FeatureIndexG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut crate::flann::feature_index);
		pub fn std_vectorLcvflann_lsh_FeatureIndexG_set_size_t_const_FeatureIndex(instance: *mut c_void, index: size_t, val: crate::flann::feature_index);
		pub fn std_vectorLcvflann_lsh_FeatureIndexG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcvflann_lsh_FeatureIndexG_data_const(instance: *const c_void) -> *const crate::flann::feature_index;
		pub fn std_vectorLcvflann_lsh_FeatureIndexG_dataMut(instance: *mut c_void) -> *mut crate::flann::feature_index;
		pub fn cv_fromSlice_const_const_FeatureIndexX_size_t(data: *const crate::flann::feature_index, len: size_t) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_flann)]
pub use flann_sys::*;

#[cfg(ocvrs_has_module_freetype)]
mod freetype_sys {
	use super::*;

	extern "C" {
		pub fn cv_freetype_createFreeType2(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_freetype_FreeType2_loadFontData_String_int(instance: *mut c_void, font_file_name: *mut c_char, idx: i32, ocvrs_return: *mut Result_void);
		pub fn cv_freetype_FreeType2_setSplitNumber_int(instance: *mut c_void, num: i32, ocvrs_return: *mut Result_void);
		pub fn cv_freetype_FreeType2_putText_const__InputOutputArrayR_const_StringR_Point_int_Scalar_int_int_bool(instance: *mut c_void, img: *const c_void, text: *const c_char, org: *const core::Point, font_height: i32, color: *const core::Scalar, thickness: i32, line_type: i32, bottom_left_origin: bool, ocvrs_return: *mut Result_void);
		pub fn cv_freetype_FreeType2_getTextSize_const_StringR_int_int_intX(instance: *mut c_void, text: *const c_char, font_height: i32, thickness: i32, base_line: *mut i32, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_freetype_FreeType2_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_freetype_FreeType2_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_freetype_FreeType2G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_freetype_FreeType2G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_freetype_FreeType2G_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_freetype_FreeType2G_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_freetype)]
pub use freetype_sys::*;

#[cfg(ocvrs_has_module_fuzzy)]
mod fuzzy_sys {
	use super::*;

	extern "C" {
		pub fn cv_ft_FT02D_FL_process_const__InputArrayR_const_int_const__OutputArrayR(matrix: *const c_void, radius: i32, output: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ft_FT02D_FL_process_float_const__InputArrayR_const_int_const__OutputArrayR(matrix: *const c_void, radius: i32, output: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ft_FT02D_components_const__InputArrayR_const__InputArrayR_const__OutputArrayR(matrix: *const c_void, kernel: *const c_void, components: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ft_FT02D_components_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR(matrix: *const c_void, kernel: *const c_void, components: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ft_FT02D_inverseFT_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_int(components: *const c_void, kernel: *const c_void, output: *const c_void, width: i32, height: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ft_FT02D_iteration_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__OutputArrayR_bool(matrix: *const c_void, kernel: *const c_void, output: *const c_void, mask: *const c_void, mask_output: *const c_void, first_stop: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_ft_FT02D_process_const__InputArrayR_const__InputArrayR_const__OutputArrayR(matrix: *const c_void, kernel: *const c_void, output: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ft_FT02D_process_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR(matrix: *const c_void, kernel: *const c_void, output: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ft_FT12D_components_const__InputArrayR_const__InputArrayR_const__OutputArrayR(matrix: *const c_void, kernel: *const c_void, components: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ft_FT12D_createPolynomMatrixHorizontal_int_const__OutputArrayR_const_int(radius: i32, matrix: *const c_void, chn: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ft_FT12D_createPolynomMatrixVertical_int_const__OutputArrayR_const_int(radius: i32, matrix: *const c_void, chn: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ft_FT12D_inverseFT_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_int(components: *const c_void, kernel: *const c_void, output: *const c_void, width: i32, height: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ft_FT12D_polynomial_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(matrix: *const c_void, kernel: *const c_void, c00: *const c_void, c10: *const c_void, c01: *const c_void, components: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ft_FT12D_polynomial_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__InputArrayR(matrix: *const c_void, kernel: *const c_void, c00: *const c_void, c10: *const c_void, c01: *const c_void, components: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ft_FT12D_process_const__InputArrayR_const__InputArrayR_const__OutputArrayR(matrix: *const c_void, kernel: *const c_void, output: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ft_FT12D_process_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR(matrix: *const c_void, kernel: *const c_void, output: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ft_createKernel_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const_int(a: *const c_void, b: *const c_void, kernel: *const c_void, chn: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ft_createKernel_int_int_const__OutputArrayR_const_int(function: i32, radius: i32, kernel: *const c_void, chn: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ft_filter_const__InputArrayR_const__InputArrayR_const__OutputArrayR(image: *const c_void, kernel: *const c_void, output: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ft_inpaint_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_int_int(image: *const c_void, mask: *const c_void, output: *const c_void, radius: i32, function: i32, algorithm: i32, ocvrs_return: *mut Result_void);
	}
}
#[cfg(ocvrs_has_module_fuzzy)]
pub use fuzzy_sys::*;

#[cfg(ocvrs_has_module_gapi)]
mod gapi_sys {
	use super::*;

	extern "C" {
		pub fn cv_descr_of_const_MatR(mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_descr_of_const_MediaFrameR(frame: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_descr_of_const_RMatR(mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_descr_of_const_ScalarR(scalar: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_descr_of_const_UMatR(mat: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_empty_array_desc(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_empty_gopaque_desc(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_empty_scalar_desc(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_BGR2Gray_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_BGR2I420_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_BGR2LUV_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_BGR2RGB_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_BGR2YUV_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_BayerGR2RGB_const_GMatR(src_gr: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_Canny_const_GMatR_double_double(image: *const c_void, threshold1: f64, threshold2: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_Canny_const_GMatR_double_double_int_bool(image: *const c_void, threshold1: f64, threshold2: f64, aperture_size: i32, l2gradient: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_I4202BGR_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_I4202RGB_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_LUT_const_GMatR_const_MatR(src: *const c_void, lut: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_LUV2BGR_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_Laplacian_const_GMatR_int(src: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_Laplacian_const_GMatR_int_int_double_double_int(src: *const c_void, ddepth: i32, ksize: i32, scale: f64, delta: f64, border_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_NV12toBGR_const_GMatR_const_GMatR(src_y: *const c_void, src_uv: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_NV12toBGRp_const_GMatR_const_GMatR(src_y: *const c_void, src_uv: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_NV12toGray_const_GMatR_const_GMatR(src_y: *const c_void, src_uv: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_NV12toRGB_const_GMatR_const_GMatR(src_y: *const c_void, src_uv: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_NV12toRGBp_const_GMatR_const_GMatR(src_y: *const c_void, src_uv: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_RGB2Gray_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_RGB2Gray_const_GMatR_float_float_float(src: *const c_void, r_y: f32, g_y: f32, b_y: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_RGB2HSV_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_RGB2I420_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_RGB2Lab_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_RGB2YUV422_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_RGB2YUV_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_SobelXY_const_GMatR_int_int(src: *const c_void, ddepth: i32, order: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_SobelXY_const_GMatR_int_int_int_double_double_int_const_ScalarR(src: *const c_void, ddepth: i32, order: i32, ksize: i32, scale: f64, delta: f64, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_Sobel_const_GMatR_int_int_int(src: *const c_void, ddepth: i32, dx: i32, dy: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_Sobel_const_GMatR_int_int_int_int_double_double_int_const_ScalarR(src: *const c_void, ddepth: i32, dx: i32, dy: i32, ksize: i32, scale: f64, delta: f64, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_YUV2BGR_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_YUV2RGB_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_absDiffC_const_GMatR_const_GScalarR(src: *const c_void, c: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_absDiff_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_addC_const_GMatR_const_GScalarR(src1: *const c_void, c: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_addC_const_GMatR_const_GScalarR_int(src1: *const c_void, c: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_addC_const_GScalarR_const_GMatR(c: *const c_void, src1: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_addC_const_GScalarR_const_GMatR_int(c: *const c_void, src1: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_addWeighted_const_GMatR_double_const_GMatR_double_double(src1: *const c_void, alpha: f64, src2: *const c_void, beta: f64, gamma: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_addWeighted_const_GMatR_double_const_GMatR_double_double_int(src1: *const c_void, alpha: f64, src2: *const c_void, beta: f64, gamma: f64, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_add_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_add_const_GMatR_const_GMatR_int(src1: *const c_void, src2: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_bilateralFilter_const_GMatR_int_double_double(src: *const c_void, d: i32, sigma_color: f64, sigma_space: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_bilateralFilter_const_GMatR_int_double_double_int(src: *const c_void, d: i32, sigma_color: f64, sigma_space: f64, border_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_bitwise_and_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_bitwise_and_const_GMatR_const_GScalarR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_bitwise_not_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_bitwise_or_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_bitwise_or_const_GMatR_const_GScalarR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_bitwise_xor_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_bitwise_xor_const_GMatR_const_GScalarR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_blur_const_GMatR_const_SizeR(src: *const c_void, ksize: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_blur_const_GMatR_const_SizeR_const_PointR_int_const_ScalarR(src: *const c_void, ksize: *const core::Size, anchor: *const core::Point, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_boxFilter_const_GMatR_int_const_SizeR(src: *const c_void, dtype: i32, ksize: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_boxFilter_const_GMatR_int_const_SizeR_const_PointR_bool_int_const_ScalarR(src: *const c_void, dtype: i32, ksize: *const core::Size, anchor: *const core::Point, normalize: bool, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cartToPolar_const_GMatR_const_GMatR(x: *const c_void, y: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cartToPolar_const_GMatR_const_GMatR_bool(x: *const c_void, y: *const c_void, angle_in_degrees: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpEQ_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpEQ_const_GMatR_const_GScalarR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpGE_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpGE_const_GMatR_const_GScalarR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpGT_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpGT_const_GMatR_const_GScalarR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpLE_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpLE_const_GMatR_const_GScalarR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpLT_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpLT_const_GMatR_const_GScalarR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpNE_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_cmpNE_const_GMatR_const_GScalarR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_combine_const_GKernelPackageR_const_GKernelPackageR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_concatHor_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_concatHor_const_vectorLGMatGR(v: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_concatVert_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_concatVert_const_vectorLGMatGR(v: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_convertTo_const_GMatR_int(src: *const c_void, rdepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_convertTo_const_GMatR_int_double_double(src: *const c_void, rdepth: i32, alpha: f64, beta: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_copy_const_GFrameR(in_: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_copy_const_GMatR(in_: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_crop_const_GMatR_const_RectR(src: *const c_void, rect: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_dilate3x3_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_dilate3x3_const_GMatR_int_int_const_ScalarR(src: *const c_void, iterations: i32, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_dilate_const_GMatR_const_MatR(src: *const c_void, kernel: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_dilate_const_GMatR_const_MatR_const_PointR_int_int_const_ScalarR(src: *const c_void, kernel: *const c_void, anchor: *const core::Point, iterations: i32, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_divC_const_GMatR_const_GScalarR_double(src: *const c_void, divisor: *const c_void, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_divC_const_GMatR_const_GScalarR_double_int(src: *const c_void, divisor: *const c_void, scale: f64, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_divRC_const_GScalarR_const_GMatR_double(divident: *const c_void, src: *const c_void, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_divRC_const_GScalarR_const_GMatR_double_int(divident: *const c_void, src: *const c_void, scale: f64, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_div_const_GMatR_const_GMatR_double(src1: *const c_void, src2: *const c_void, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_div_const_GMatR_const_GMatR_double_int(src1: *const c_void, src2: *const c_void, scale: f64, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_equalizeHist_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_erode3x3_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_erode3x3_const_GMatR_int_int_const_ScalarR(src: *const c_void, iterations: i32, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_erode_const_GMatR_const_MatR(src: *const c_void, kernel: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_erode_const_GMatR_const_MatR_const_PointR_int_int_const_ScalarR(src: *const c_void, kernel: *const c_void, anchor: *const core::Point, iterations: i32, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_filter2D_const_GMatR_int_const_MatR(src: *const c_void, ddepth: i32, kernel: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_filter2D_const_GMatR_int_const_MatR_const_PointR_const_ScalarR_int_const_ScalarR(src: *const c_void, ddepth: i32, kernel: *const c_void, anchor: *const core::Point, delta: *const core::Scalar, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_flip_const_GMatR_int(src: *const c_void, flip_code: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_gaussianBlur_const_GMatR_const_SizeR_double(src: *const c_void, ksize: *const core::Size, sigma_x: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_gaussianBlur_const_GMatR_const_SizeR_double_double_int_const_ScalarR(src: *const c_void, ksize: *const core::Size, sigma_x: f64, sigma_y: f64, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_inRange_const_GMatR_const_GScalarR_const_GScalarR(src: *const c_void, thresh_low: *const c_void, thresh_up: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_integral_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_integral_const_GMatR_int_int(src: *const c_void, sdepth: i32, sqdepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_mask_const_GMatR_const_GMatR(src: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_max_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_mean_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_medianBlur_const_GMatR_int(src: *const c_void, ksize: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_merge3_const_GMatR_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, src3: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_merge4_const_GMatR_const_GMatR_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, src3: *const c_void, src4: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_min_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_morphologyEx_const_GMatR_const_MorphTypes_const_MatR(src: *const c_void, op: crate::imgproc::MorphTypes, kernel: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_morphologyEx_const_GMatR_const_MorphTypes_const_MatR_const_PointR_const_int_const_BorderTypes_const_ScalarR(src: *const c_void, op: crate::imgproc::MorphTypes, kernel: *const c_void, anchor: *const core::Point, iterations: i32, border_type: core::BorderTypes, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_mulC_const_GMatR_const_GScalarR(src: *const c_void, multiplier: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_mulC_const_GMatR_const_GScalarR_int(src: *const c_void, multiplier: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_mulC_const_GMatR_double(src: *const c_void, multiplier: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_mulC_const_GMatR_double_int(src: *const c_void, multiplier: f64, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_mulC_const_GScalarR_const_GMatR(multiplier: *const c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_mulC_const_GScalarR_const_GMatR_int(multiplier: *const c_void, src: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_mul_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_mul_const_GMatR_const_GMatR_double_int(src1: *const c_void, src2: *const c_void, scale: f64, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_normInf_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_normL1_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_normL2_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_normalize_const_GMatR_double_double_int(src: *const c_void, alpha: f64, beta: f64, norm_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_normalize_const_GMatR_double_double_int_int(src: *const c_void, alpha: f64, beta: f64, norm_type: i32, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_phase_const_GMatR_const_GMatR(x: *const c_void, y: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_phase_const_GMatR_const_GMatR_bool(x: *const c_void, y: *const c_void, angle_in_degrees: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_polarToCart_const_GMatR_const_GMatR(magnitude: *const c_void, angle: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_polarToCart_const_GMatR_const_GMatR_bool(magnitude: *const c_void, angle: *const c_void, angle_in_degrees: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_remap_const_GMatR_const_MatR_const_MatR_int(src: *const c_void, map1: *const c_void, map2: *const c_void, interpolation: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_remap_const_GMatR_const_MatR_const_MatR_int_int_const_ScalarR(src: *const c_void, map1: *const c_void, map2: *const c_void, interpolation: i32, border_mode: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_resizeP_const_GMatPR_const_SizeR(src: *const c_void, dsize: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_resizeP_const_GMatPR_const_SizeR_int(src: *const c_void, dsize: *const core::Size, interpolation: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_resize_const_GMatR_const_SizeR(src: *const c_void, dsize: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_resize_const_GMatR_const_SizeR_double_double_int(src: *const c_void, dsize: *const core::Size, fx: f64, fy: f64, interpolation: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_select_const_GMatR_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_sepFilter_const_GMatR_int_const_MatR_const_MatR_const_PointR_const_ScalarR(src: *const c_void, ddepth: i32, kernel_x: *const c_void, kernel_y: *const c_void, anchor: *const core::Point, delta: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_sepFilter_const_GMatR_int_const_MatR_const_MatR_const_PointR_const_ScalarR_int_const_ScalarR(src: *const c_void, ddepth: i32, kernel_x: *const c_void, kernel_y: *const c_void, anchor: *const core::Point, delta: *const core::Scalar, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_split3_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_split4_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_sqrt_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_streaming_BGR_const_GFrameR(in_: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_streaming_UV_const_GFrameR(frame: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_streaming_Y_const_GFrameR(frame: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_streaming_desync_const_GFrameR(f: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_streaming_desync_const_GMatR(g: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_streaming_kernels(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_subC_const_GMatR_const_GScalarR(src: *const c_void, c: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_subC_const_GMatR_const_GScalarR_int(src: *const c_void, c: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_subRC_const_GScalarR_const_GMatR(c: *const c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_subRC_const_GScalarR_const_GMatR_int(c: *const c_void, src: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_sub_const_GMatR_const_GMatR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_sub_const_GMatR_const_GMatR_int(src1: *const c_void, src2: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_sum_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_threshold_const_GMatR_const_GScalarR_const_GScalarR_int(src: *const c_void, thresh: *const c_void, maxval: *const c_void, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_threshold_const_GMatR_const_GScalarR_int(src: *const c_void, maxval: *const c_void, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_transpose_const_GMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_warpAffine_const_GMatR_const_MatR_const_SizeR(src: *const c_void, m: *const c_void, dsize: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_warpAffine_const_GMatR_const_MatR_const_SizeR_int_int_const_ScalarR(src: *const c_void, m: *const c_void, dsize: *const core::Size, flags: i32, border_mode: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_warpPerspective_const_GMatR_const_MatR_const_SizeR(src: *const c_void, m: *const c_void, dsize: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_warpPerspective_const_GMatR_const_MatR_const_SizeR_int_int_const_ScalarR(src: *const c_void, m: *const c_void, dsize: *const core::Size, flags: i32, border_mode: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorEQ_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorEQ_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorEQ_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorGE_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorGE_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorGE_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorG_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorG_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorG_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorLE_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorLE_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorLE_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorL_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorL_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorL_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNE_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNE_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNE_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNOTB_const_GMatR(lhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorOR_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorOR_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorOR_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorR_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorR_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorR_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorXOR_const_GMatR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorXOR_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorXOR_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_GMatR_const_GScalarR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_GMatR_float(lhs: *const c_void, rhs: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_GScalarR_const_GMatR(lhs: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_float_const_GMatR(lhs: f32, rhs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_validate_input_arg_const_GRunArgR(arg: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_validate_input_args_const_GRunArgsR(args: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GArg_GArg(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GArg_propKind_const(instance: *const c_void, ocvrs_return: *mut crate::gapi::Detail_ArgKind);
		pub fn cv_GArg_propKind_ArgKind(instance: *mut c_void, val: crate::gapi::Detail_ArgKind);
		pub fn cv_GArg_propOpaque_kind_const(instance: *const c_void, ocvrs_return: *mut crate::gapi::Detail_OpaqueKind);
		pub fn cv_GArg_propOpaque_kind_OpaqueKind(instance: *mut c_void, val: crate::gapi::Detail_OpaqueKind);
		pub fn cv_GArg_delete(instance: *mut c_void);
		pub fn cv_GArrayDesc_operatorEQ_const_const_GArrayDescR(instance: *const c_void, unnamed: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GArrayDesc_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GArrayDesc_defaultNew_const() -> *mut c_void;
		pub fn cv_GArrayDesc_delete(instance: *mut c_void);
		pub fn cv_GCall_GCall_const_GKernelR(k: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCall_yield_int(instance: *mut c_void, output: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCall_yield(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCall_yieldP_int(instance: *mut c_void, output: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCall_yieldP(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCall_yieldScalar_int(instance: *mut c_void, output: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCall_yieldScalar(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCall_yieldFrame_int(instance: *mut c_void, output: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCall_yieldFrame(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCall_kernel(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCall_params(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCall_setArgs_vectorLGArgGRR(instance: *mut c_void, args: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GCall_delete(instance: *mut c_void);
		pub fn cv_GCompileArg_GCompileArg() -> *mut c_void;
		pub fn cv_GCompileArg_propTag_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GCompileArg_propTag_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_GCompileArg_delete(instance: *mut c_void);
		pub fn cv_GCompiled_GCompiled(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GCompiled_operator___Mat_MatR(instance: *mut c_void, in_: *mut c_void, out: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GCompiled_operator___Mat_ScalarR(instance: *mut c_void, in_: *mut c_void, out: *mut core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_GCompiled_operator___Mat_Mat_MatR(instance: *mut c_void, in1: *mut c_void, in2: *mut c_void, out: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GCompiled_operator___Mat_Mat_ScalarR(instance: *mut c_void, in1: *mut c_void, in2: *mut c_void, out: *mut core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_GCompiled_operator___const_vectorLMatGR_const_vectorLMatGR(instance: *mut c_void, ins: *const c_void, outs: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GCompiled_operator_bool_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GCompiled_canReshape_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GCompiled_prepareForNewStream(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GCompiled_delete(instance: *mut c_void);
		pub fn cv_GComputation_GComputation_GMat_GMat(in_: *mut c_void, out: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GComputation_GComputation_GMat_GScalar(in_: *mut c_void, out: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GComputation_GComputation_GMat_GMat_GMat(in1: *mut c_void, in2: *mut c_void, out: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GComputation_GComputation_GMat_GMat_GScalar(in1: *mut c_void, in2: *mut c_void, out: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GComputation_GComputation_const_vectorLGMatGR_const_vectorLGMatGR(ins: *const c_void, outs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GComputation_apply_const_ExtractArgsCallbackR_GCompileArgsRR(instance: *mut c_void, callback: *const c_void, args: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GComputation_apply_const_ExtractArgsCallbackR(instance: *mut c_void, callback: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GComputation_apply_const_vectorLMatGR_const_vectorLMatGR_GCompileArgsRR(instance: *mut c_void, ins: *const c_void, outs: *const c_void, args: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_apply_const_vectorLMatGR_const_vectorLMatGR(instance: *mut c_void, ins: *const c_void, outs: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_apply_Mat_MatR_GCompileArgsRR(instance: *mut c_void, in_: *mut c_void, out: *mut c_void, args: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_apply_Mat_MatR(instance: *mut c_void, in_: *mut c_void, out: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_apply_Mat_ScalarR_GCompileArgsRR(instance: *mut c_void, in_: *mut c_void, out: *mut core::Scalar, args: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_apply_Mat_ScalarR(instance: *mut c_void, in_: *mut c_void, out: *mut core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_apply_Mat_Mat_MatR_GCompileArgsRR(instance: *mut c_void, in1: *mut c_void, in2: *mut c_void, out: *mut c_void, args: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_apply_Mat_Mat_MatR(instance: *mut c_void, in1: *mut c_void, in2: *mut c_void, out: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_apply_Mat_Mat_ScalarR_GCompileArgsRR(instance: *mut c_void, in1: *mut c_void, in2: *mut c_void, out: *mut core::Scalar, args: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_apply_Mat_Mat_ScalarR(instance: *mut c_void, in1: *mut c_void, in2: *mut c_void, out: *mut core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_apply_const_vectorLMatGR_vectorLMatGR_GCompileArgsRR(instance: *mut c_void, ins: *const c_void, outs: *mut c_void, args: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_apply_const_vectorLMatGR_vectorLMatGR(instance: *mut c_void, ins: *const c_void, outs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GComputation_compileStreaming_GCompileArgsRR(instance: *mut c_void, args: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GComputation_compileStreaming(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GComputation_compileStreaming_const_ExtractMetaCallbackR_GCompileArgsRR(instance: *mut c_void, callback: *const c_void, args: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GComputation_compileStreaming_const_ExtractMetaCallbackR(instance: *mut c_void, callback: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GComputation_delete(instance: *mut c_void);
		pub fn cv_GFrame_GFrame(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GFrame_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GFrame_delete(instance: *mut c_void);
		pub fn cv_GFrameDesc_operatorEQ_const_const_GFrameDescR(instance: *const c_void, unnamed: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GFrameDesc_propFmt_const(instance: *const c_void, ocvrs_return: *mut crate::gapi::MediaFormat);
		pub fn cv_GFrameDesc_propFmt_MediaFormat(instance: *mut c_void, val: crate::gapi::MediaFormat);
		pub fn cv_GFrameDesc_propSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_GFrameDesc_propSize_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_GFrameDesc_delete(instance: *mut c_void);
		pub fn cv_GKernel_propName_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GKernel_propName_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_GKernel_propTag_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GKernel_propTag_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_GKernel_propOutShapes_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GKernel_propOutShapes_GShapes(instance: *mut c_void, val: *mut c_void);
		pub fn cv_GKernel_propInKinds_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GKernel_propInKinds_GKinds(instance: *mut c_void, val: *mut c_void);
		pub fn cv_GKernel_propOutKinds_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GKernel_propOutKinds_GKinds(instance: *mut c_void, val: *mut c_void);
		pub fn cv_GKernel_delete(instance: *mut c_void);
		pub fn cv_GKernelImpl_propOpaque_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GKernelImpl_propOpaque_any(instance: *mut c_void, val: *mut c_void);
		pub fn cv_GKernelImpl_delete(instance: *mut c_void);
		pub fn cv_GKernelPackage_include_const_GFunctorR(instance: *mut c_void, functor: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GKernelPackage_get_transformations_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GKernelPackage_get_kernel_ids_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GKernelPackage_remove_const_GBackendR(instance: *mut c_void, backend: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GKernelPackage_includesAPI_const_const_stringR(instance: *const c_void, id: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_GKernelPackage_lookup_const_const_stringR(instance: *const c_void, id: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GKernelPackage_include_const_GBackendR_const_stringR(instance: *mut c_void, backend: *const c_void, kernel_id: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_GKernelPackage_backends_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GKernelPackage_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GKernelPackage_defaultNew_const() -> *mut c_void;
		pub fn cv_GKernelPackage_delete(instance: *mut c_void);
		pub fn cv_GMat_GMat(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMat_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GMat_delete(instance: *mut c_void);
		pub fn cv_GMatDesc_GMatDesc_int_int_Size_bool(d: i32, c: i32, s: *const core::Size, p: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_GMatDesc_int_int_Size(d: i32, c: i32, s: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_GMatDesc_int_const_vectorLintGR(d: i32, dd: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_GMatDesc_int_vectorLintGRR(d: i32, dd: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_GMatDesc(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_operatorEQ_const_const_GMatDescR(instance: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GMatDesc_operatorNE_const_const_GMatDescR(instance: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GMatDesc_isND_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GMatDesc_canDescribe_const_const_MatR(instance: *const c_void, mat: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GMatDesc_canDescribe_const_const_RMatR(instance: *const c_void, mat: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GMatDesc_withSizeDelta_const_Size(instance: *const c_void, delta: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_withSizeDelta_const_int_int(instance: *const c_void, dx: i32, dy: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_withSize_const_Size(instance: *const c_void, sz: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_withDepth_const_int(instance: *const c_void, ddepth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_withType_const_int_int(instance: *const c_void, ddepth: i32, dchan: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_asPlanar_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_asPlanar_const_int(instance: *const c_void, planes: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_asInterleaved_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GMatDesc_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GMatDesc_propDepth_const(instance: *const c_void) -> i32;
		pub fn cv_GMatDesc_propDepth_int(instance: *mut c_void, val: i32);
		pub fn cv_GMatDesc_propChan_const(instance: *const c_void) -> i32;
		pub fn cv_GMatDesc_propChan_int(instance: *mut c_void, val: i32);
		pub fn cv_GMatDesc_propSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_GMatDesc_propSize_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_GMatDesc_propPlanar_const(instance: *const c_void) -> bool;
		pub fn cv_GMatDesc_propPlanar_bool(instance: *mut c_void, val: bool);
		pub fn cv_GMatDesc_propDims_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GMatDesc_propDims_vectorLintG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_GMatDesc_delete(instance: *mut c_void);
		pub fn cv_GMatP_to_GMat(instance: *mut c_void) -> *mut c_void;
		pub fn cv_GMatP_delete(instance: *mut c_void);
		pub fn cv_GOpaqueDesc_operatorEQ_const_const_GOpaqueDescR(instance: *const c_void, unnamed: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GOpaqueDesc_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GOpaqueDesc_defaultNew_const() -> *mut c_void;
		pub fn cv_GOpaqueDesc_delete(instance: *mut c_void);
		pub fn cv_GRunArg_GRunArg(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GRunArg_GRunArg_const_GRunArgR(arg: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GRunArg_GRunArg_GRunArgRR(arg: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GRunArg_operatorST_const_GRunArgR(instance: *mut c_void, arg: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GRunArg_operatorST_GRunArgRR(instance: *mut c_void, arg: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GRunArg_delete(instance: *mut c_void);
		pub fn cv_GScalar_GScalar(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GScalar_GScalar_const_ScalarR(s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GScalar_GScalar_ScalarRR(s: *mut core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GScalar_GScalar_double(v0: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GScalar_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GScalar_delete(instance: *mut c_void);
		pub fn cv_GScalarDesc_operatorEQ_const_const_GScalarDescR(instance: *const c_void, unnamed: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GScalarDesc_operatorNE_const_const_GScalarDescR(instance: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GScalarDesc_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GScalarDesc_defaultNew_const() -> *mut c_void;
		pub fn cv_GScalarDesc_delete(instance: *mut c_void);
		pub fn cv_GStreamingCompiled_GStreamingCompiled(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GStreamingCompiled_setSource_GRunArgsRR(instance: *mut c_void, ins: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GStreamingCompiled_setSource_const_ExtractArgsCallbackR(instance: *mut c_void, callback: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GStreamingCompiled_start(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GStreamingCompiled_stop(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GStreamingCompiled_running_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GStreamingCompiled_operator_bool_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GStreamingCompiled_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GStreamingCompiled_delete(instance: *mut c_void);
		pub fn cv_GTransform_propDescription_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GTransform_propDescription_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_GTransform_delete(instance: *mut c_void);
		pub fn cv_GTypeInfo_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GTypeInfo_defaultNew_const() -> *mut c_void;
		pub fn cv_GTypeInfo_propShape_const(instance: *const c_void, ocvrs_return: *mut crate::gapi::GShape);
		pub fn cv_GTypeInfo_propShape_GShape(instance: *mut c_void, val: crate::gapi::GShape);
		pub fn cv_GTypeInfo_propKind_const(instance: *const c_void, ocvrs_return: *mut crate::gapi::Detail_OpaqueKind);
		pub fn cv_GTypeInfo_propKind_OpaqueKind(instance: *mut c_void, val: crate::gapi::Detail_OpaqueKind);
		pub fn cv_GTypeInfo_delete(instance: *mut c_void);
		pub fn cv_MediaFrame_MediaFrame(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MediaFrame_desc_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MediaFrame_blobParams_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MediaFrame_delete(instance: *mut c_void);
		pub fn cv_MediaFrame_IAdapter_meta_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MediaFrame_IAdapter_blobParams_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MediaFrame_IAdapter_delete(instance: *mut c_void);
		pub fn cv_MediaFrame_View_View_ViewRR(unnamed: *mut c_void) -> *mut c_void;
		pub fn cv_MediaFrame_View_delete(instance: *mut c_void);
		pub fn cv_RMat_RMat() -> *mut c_void;
		pub fn cv_RMat_desc_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RMat_delete(instance: *mut c_void);
		pub fn cv_RMat_IAdapter_desc_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RMat_IAdapter_delete(instance: *mut c_void);
		pub fn cv_RMat_View_View() -> *mut c_void;
		pub fn cv_RMat_View_View_ViewRR(unnamed: *mut c_void) -> *mut c_void;
		pub fn cv_RMat_View_operatorST_ViewRR(instance: *mut c_void, v: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_RMat_View_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_RMat_View_dims_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RMat_View_cols_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_RMat_View_rows_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_RMat_View_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_RMat_View_depth_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_RMat_View_chan_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_RMat_View_elemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_RMat_View_step_const_size_t(instance: *const c_void, i: size_t, ocvrs_return: *mut Result<size_t>);
		pub fn cv_RMat_View_step_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_RMat_View_steps_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RMat_View_delete(instance: *mut c_void);
		pub fn cv_detail_ExtractArgsCallback_operator___const_const_GTypesInfoR(instance: *const c_void, info: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_ExtractArgsCallback_delete(instance: *mut c_void);
		pub fn cv_detail_ExtractMetaCallback_delete(instance: *mut c_void);
		pub fn cv_detail_GArrayU_delete(instance: *mut c_void);
		pub fn cv_detail_GOpaqueU_delete(instance: *mut c_void);
		pub fn cv_gapi_GBackend_GBackend(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_GBackend_operatorEQ_const_const_GBackendR(instance: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_gapi_GBackend_delete(instance: *mut c_void);
		pub fn cv_gapi_GFunctor_impl_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_GFunctor_backend_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_GFunctor_id_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_GFunctor_delete(instance: *mut c_void);
		pub fn cv_gapi_own_Scalar_Scalar() -> *mut c_void;
		pub fn cv_gapi_own_Scalar_Scalar_double(v0: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_own_Scalar_Scalar_double_double_double_double(v0: f64, v1: f64, v2: f64, v3: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_own_Scalar_Scalar_double_double(v0: f64, v1: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_own_Scalar_operator___const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_gapi_own_Scalar_operator___int(instance: *mut c_void, i: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_gapi_own_Scalar_all_double(v0: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_own_Scalar_propVal(instance: *mut c_void) -> *mut [f64; 4];
		pub fn cv_gapi_own_Scalar_delete(instance: *mut c_void);
		pub fn cv_gapi_streaming_queue_capacity_queue_capacity_size_t(cap: size_t, ocvrs_return: *mut Result<crate::gapi::queue_capacity>);
		pub fn cv_gapi_streaming_queue_capacity_queue_capacity(ocvrs_return: *mut Result<crate::gapi::queue_capacity>);
		pub fn cv_gapi_use_only_propPkg_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_gapi_use_only_propPkg_GKernelPackage(instance: *mut c_void, val: *mut c_void);
		pub fn cv_gapi_use_only_delete(instance: *mut c_void);
		pub fn cv_gapi_wip_Data_to_GRunArg(instance: *mut c_void) -> *mut c_void;
		pub fn cv_gapi_wip_Data_delete(instance: *mut c_void);
		pub fn cv_gapi_wip_draw_Circle_Circle_const_PointR_int_const_ScalarR_int_int_int(center_: *const core::Point, radius_: i32, color_: *const core::Scalar, thick_: i32, lt_: i32, shift_: i32, ocvrs_return: *mut Result<crate::gapi::Circle>);
		pub fn cv_gapi_wip_draw_Circle_Circle_const_PointR_int_const_ScalarR(center_: *const core::Point, radius_: i32, color_: *const core::Scalar, ocvrs_return: *mut Result<crate::gapi::Circle>);
		pub fn cv_gapi_wip_draw_Circle_Circle(ocvrs_return: *mut crate::gapi::Circle);
		pub fn cv_gapi_wip_draw_Image_Image_const_PointR_const_MatR_const_MatR(org_: *const core::Point, img_: *const c_void, alpha_: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_wip_draw_Image_Image() -> *mut c_void;
		pub fn cv_gapi_wip_draw_Image_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_gapi_wip_draw_Image_propOrg_const(instance: *const c_void, ocvrs_return: *mut core::Point);
		pub fn cv_gapi_wip_draw_Image_propOrg_Point(instance: *mut c_void, val: *const core::Point);
		pub fn cv_gapi_wip_draw_Image_propImg_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_gapi_wip_draw_Image_propImg_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_gapi_wip_draw_Image_propAlpha_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_gapi_wip_draw_Image_propAlpha_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_gapi_wip_draw_Image_delete(instance: *mut c_void);
		pub fn cv_gapi_wip_draw_Line_Line_const_PointR_const_PointR_const_ScalarR_int_int_int(pt1_: *const core::Point, pt2_: *const core::Point, color_: *const core::Scalar, thick_: i32, lt_: i32, shift_: i32, ocvrs_return: *mut Result<crate::gapi::Line>);
		pub fn cv_gapi_wip_draw_Line_Line_const_PointR_const_PointR_const_ScalarR(pt1_: *const core::Point, pt2_: *const core::Point, color_: *const core::Scalar, ocvrs_return: *mut Result<crate::gapi::Line>);
		pub fn cv_gapi_wip_draw_Line_Line(ocvrs_return: *mut crate::gapi::Line);
		pub fn cv_gapi_wip_draw_Mosaic_Mosaic_const_RectR_int_int(mos_: *const core::Rect, cell_sz_: i32, decim_: i32, ocvrs_return: *mut Result<crate::gapi::Mosaic>);
		pub fn cv_gapi_wip_draw_Mosaic_Mosaic(ocvrs_return: *mut Result<crate::gapi::Mosaic>);
		pub fn cv_gapi_wip_draw_Poly_Poly_const_vectorLPointGR_const_ScalarR_int_int_int(points_: *const c_void, color_: *const core::Scalar, thick_: i32, lt_: i32, shift_: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_wip_draw_Poly_Poly_const_vectorLPointGR_const_ScalarR(points_: *const c_void, color_: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_wip_draw_Poly_Poly() -> *mut c_void;
		pub fn cv_gapi_wip_draw_Poly_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_gapi_wip_draw_Poly_propPoints_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_gapi_wip_draw_Poly_propPoints_vectorLPointG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_gapi_wip_draw_Poly_propColor_const(instance: *const c_void, ocvrs_return: *mut core::Scalar);
		pub fn cv_gapi_wip_draw_Poly_propColor_Scalar(instance: *mut c_void, val: *const core::Scalar);
		pub fn cv_gapi_wip_draw_Poly_propThick_const(instance: *const c_void) -> i32;
		pub fn cv_gapi_wip_draw_Poly_propThick_int(instance: *mut c_void, val: i32);
		pub fn cv_gapi_wip_draw_Poly_propLt_const(instance: *const c_void) -> i32;
		pub fn cv_gapi_wip_draw_Poly_propLt_int(instance: *mut c_void, val: i32);
		pub fn cv_gapi_wip_draw_Poly_propShift_const(instance: *const c_void) -> i32;
		pub fn cv_gapi_wip_draw_Poly_propShift_int(instance: *mut c_void, val: i32);
		pub fn cv_gapi_wip_draw_Poly_delete(instance: *mut c_void);
		pub fn cv_gapi_wip_draw_Rect_Rect_const_RectR_const_ScalarR_int_int_int(rect_: *const core::Rect, color_: *const core::Scalar, thick_: i32, lt_: i32, shift_: i32, ocvrs_return: *mut Result<crate::gapi::Rect>);
		pub fn cv_gapi_wip_draw_Rect_Rect_const_RectR_const_ScalarR(rect_: *const core::Rect, color_: *const core::Scalar, ocvrs_return: *mut Result<crate::gapi::Rect>);
		pub fn cv_gapi_wip_draw_Rect_Rect(ocvrs_return: *mut crate::gapi::Rect);
		pub fn cv_gapi_wip_draw_Text_Text_const_stringR_const_PointR_int_double_const_ScalarR_int_int_bool(text_: *const c_char, org_: *const core::Point, ff_: i32, fs_: f64, color_: *const core::Scalar, thick_: i32, lt_: i32, bottom_left_origin_: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_wip_draw_Text_Text_const_stringR_const_PointR_int_double_const_ScalarR(text_: *const c_char, org_: *const core::Point, ff_: i32, fs_: f64, color_: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_gapi_wip_draw_Text_Text() -> *mut c_void;
		pub fn cv_gapi_wip_draw_Text_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_gapi_wip_draw_Text_propText_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_gapi_wip_draw_Text_propText_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_gapi_wip_draw_Text_propOrg_const(instance: *const c_void, ocvrs_return: *mut core::Point);
		pub fn cv_gapi_wip_draw_Text_propOrg_Point(instance: *mut c_void, val: *const core::Point);
		pub fn cv_gapi_wip_draw_Text_propFf_const(instance: *const c_void) -> i32;
		pub fn cv_gapi_wip_draw_Text_propFf_int(instance: *mut c_void, val: i32);
		pub fn cv_gapi_wip_draw_Text_propFs_const(instance: *const c_void) -> f64;
		pub fn cv_gapi_wip_draw_Text_propFs_double(instance: *mut c_void, val: f64);
		pub fn cv_gapi_wip_draw_Text_propColor_const(instance: *const c_void, ocvrs_return: *mut core::Scalar);
		pub fn cv_gapi_wip_draw_Text_propColor_Scalar(instance: *mut c_void, val: *const core::Scalar);
		pub fn cv_gapi_wip_draw_Text_propThick_const(instance: *const c_void) -> i32;
		pub fn cv_gapi_wip_draw_Text_propThick_int(instance: *mut c_void, val: i32);
		pub fn cv_gapi_wip_draw_Text_propLt_const(instance: *const c_void) -> i32;
		pub fn cv_gapi_wip_draw_Text_propLt_int(instance: *mut c_void, val: i32);
		pub fn cv_gapi_wip_draw_Text_propBottom_left_origin_const(instance: *const c_void) -> bool;
		pub fn cv_gapi_wip_draw_Text_propBottom_left_origin_bool(instance: *mut c_void, val: bool);
		pub fn cv_gapi_wip_draw_Text_delete(instance: *mut c_void);
		pub fn cv_util_any_any_const_anyR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_util_any_any_anyR(src: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_util_any_any() -> *mut c_void;
		pub fn cv_util_any_any_anyRR(unnamed: *mut c_void) -> *mut c_void;
		pub fn cv_util_any_operatorST_anyRR(instance: *mut c_void, unnamed: *mut c_void);
		pub fn cv_util_any_operatorST_const_anyR(instance: *mut c_void, src: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_util_any_delete(instance: *mut c_void);
		pub fn std_pairLcv_gapi_GBackend__cv_GKernelImplG_new_const_GBackend_GKernelImpl(arg: *mut c_void, arg_1: *mut c_void) -> *mut c_void;
		pub fn std_pairLcv_gapi_GBackend__cv_GKernelImplG_get_0_const(instance: *const c_void, ocvrs_return: *mut *mut c_void);
		pub fn std_pairLcv_gapi_GBackend__cv_GKernelImplG_get_1_const(instance: *const c_void, ocvrs_return: *mut *mut c_void);
		pub fn std_pairLcv_gapi_GBackend__cv_GKernelImplG_delete(instance: *mut c_void);
		pub fn std_tupleLcv_GMat__cv_GMatG_new_const_GMat_GMat(arg: *mut c_void, arg_1: *mut c_void) -> *mut c_void;
		pub fn std_tupleLcv_GMat__cv_GMatG_get_0_const(instance: *const c_void, ocvrs_return: *mut *mut c_void);
		pub fn std_tupleLcv_GMat__cv_GMatG_get_1_const(instance: *const c_void, ocvrs_return: *mut *mut c_void);
		pub fn std_tupleLcv_GMat__cv_GMatG_delete(instance: *mut c_void);
		pub fn std_tupleLcv_GMat__cv_GMat__cv_GMatG_new_const_GMat_GMat_GMat(arg: *mut c_void, arg_1: *mut c_void, arg_2: *mut c_void) -> *mut c_void;
		pub fn std_tupleLcv_GMat__cv_GMat__cv_GMatG_get_0_const(instance: *const c_void, ocvrs_return: *mut *mut c_void);
		pub fn std_tupleLcv_GMat__cv_GMat__cv_GMatG_get_1_const(instance: *const c_void, ocvrs_return: *mut *mut c_void);
		pub fn std_tupleLcv_GMat__cv_GMat__cv_GMatG_get_2_const(instance: *const c_void, ocvrs_return: *mut *mut c_void);
		pub fn std_tupleLcv_GMat__cv_GMat__cv_GMatG_delete(instance: *mut c_void);
		pub fn std_tupleLcv_GMat__cv_GMat__cv_GMat__cv_GMatG_new_const_GMat_GMat_GMat_GMat(arg: *mut c_void, arg_1: *mut c_void, arg_2: *mut c_void, arg_3: *mut c_void) -> *mut c_void;
		pub fn std_tupleLcv_GMat__cv_GMat__cv_GMat__cv_GMatG_get_0_const(instance: *const c_void, ocvrs_return: *mut *mut c_void);
		pub fn std_tupleLcv_GMat__cv_GMat__cv_GMat__cv_GMatG_get_1_const(instance: *const c_void, ocvrs_return: *mut *mut c_void);
		pub fn std_tupleLcv_GMat__cv_GMat__cv_GMat__cv_GMatG_get_2_const(instance: *const c_void, ocvrs_return: *mut *mut c_void);
		pub fn std_tupleLcv_GMat__cv_GMat__cv_GMat__cv_GMatG_get_3_const(instance: *const c_void, ocvrs_return: *mut *mut c_void);
		pub fn std_tupleLcv_GMat__cv_GMat__cv_GMat__cv_GMatG_delete(instance: *mut c_void);
		pub fn std_tupleLcv_GMat__cv_GScalarG_new_const_GMat_GScalar(arg: *mut c_void, arg_1: *mut c_void) -> *mut c_void;
		pub fn std_tupleLcv_GMat__cv_GScalarG_get_0_const(instance: *const c_void, ocvrs_return: *mut *mut c_void);
		pub fn std_tupleLcv_GMat__cv_GScalarG_get_1_const(instance: *const c_void, ocvrs_return: *mut *mut c_void);
		pub fn std_tupleLcv_GMat__cv_GScalarG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_detail_OpaqueKindG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_detail_OpaqueKindG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_detail_OpaqueKindG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_detail_OpaqueKindG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_detail_OpaqueKindG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_detail_OpaqueKindG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_detail_OpaqueKindG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_detail_OpaqueKindG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_detail_OpaqueKindG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_detail_OpaqueKindG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_detail_OpaqueKindG_push_const_OpaqueKind(instance: *mut c_void, val: crate::gapi::Detail_OpaqueKind);
		pub fn std_vectorLcv_detail_OpaqueKindG_insert_size_t_const_OpaqueKind(instance: *mut c_void, index: size_t, val: crate::gapi::Detail_OpaqueKind);
		pub fn std_vectorLcv_detail_OpaqueKindG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut crate::gapi::Detail_OpaqueKind);
		pub fn std_vectorLcv_detail_OpaqueKindG_set_size_t_const_OpaqueKind(instance: *mut c_void, index: size_t, val: crate::gapi::Detail_OpaqueKind);
		pub fn std_vectorLcv_detail_OpaqueKindG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_detail_OpaqueKindG_data_const(instance: *const c_void) -> *const crate::gapi::Detail_OpaqueKind;
		pub fn std_vectorLcv_detail_OpaqueKindG_dataMut(instance: *mut c_void) -> *mut crate::gapi::Detail_OpaqueKind;
		pub fn cv_fromSlice_const_const_OpaqueKindX_size_t(data: *const crate::gapi::Detail_OpaqueKind, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_GArgG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_GArgG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_GArgG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_GArgG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_GArgG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_GArgG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_GArgG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_GArgG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_GArgG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_GArgG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_GArgG_push_const_GArg(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_GArgG_insert_size_t_const_GArg(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_GArgG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_GArgG_set_size_t_const_GArg(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_gapi_GBackendG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_gapi_GBackendG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_gapi_GBackendG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_gapi_GBackendG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_gapi_GBackendG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_gapi_GBackendG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_gapi_GBackendG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_gapi_GBackendG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_gapi_GBackendG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_gapi_GBackendG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_gapi_GBackendG_push_const_GBackend(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_gapi_GBackendG_insert_size_t_const_GBackend(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_gapi_GBackendG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_gapi_GBackendG_set_size_t_const_GBackend(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_GCompileArgG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_GCompileArgG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_GCompileArgG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_GCompileArgG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_GCompileArgG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_GCompileArgG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_GCompileArgG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_GCompileArgG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_GCompileArgG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_GCompileArgG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_GCompileArgG_push_const_GCompileArg(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_GCompileArgG_insert_size_t_const_GCompileArg(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_GCompileArgG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_GCompileArgG_set_size_t_const_GCompileArg(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_GMatG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_GMatG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_GMatG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_GMatG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_GMatG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_GMatG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_GMatG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_GMatG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_GMatG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_GMatG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_GMatG_push_const_GMat(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_GMatG_insert_size_t_const_GMat(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_GMatG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_GMatG_set_size_t_const_GMat(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_GRunArgG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_GRunArgG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_GRunArgG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_GRunArgG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_GRunArgG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_GRunArgG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_GRunArgG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_GRunArgG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_GRunArgG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_GRunArgG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_GRunArgG_push_const_GRunArg(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_GRunArgG_insert_size_t_const_GRunArg(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_GRunArgG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_GRunArgG_set_size_t_const_GRunArg(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_GShapeG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_GShapeG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_GShapeG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_GShapeG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_GShapeG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_GShapeG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_GShapeG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_GShapeG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_GShapeG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_GShapeG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_GShapeG_push_const_GShape(instance: *mut c_void, val: crate::gapi::GShape);
		pub fn std_vectorLcv_GShapeG_insert_size_t_const_GShape(instance: *mut c_void, index: size_t, val: crate::gapi::GShape);
		pub fn std_vectorLcv_GShapeG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut crate::gapi::GShape);
		pub fn std_vectorLcv_GShapeG_set_size_t_const_GShape(instance: *mut c_void, index: size_t, val: crate::gapi::GShape);
		pub fn std_vectorLcv_GShapeG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_GShapeG_data_const(instance: *const c_void) -> *const crate::gapi::GShape;
		pub fn std_vectorLcv_GShapeG_dataMut(instance: *mut c_void) -> *mut crate::gapi::GShape;
		pub fn cv_fromSlice_const_const_GShapeX_size_t(data: *const crate::gapi::GShape, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_GTransformG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_GTransformG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_GTransformG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_GTransformG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_GTransformG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_GTransformG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_GTransformG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_GTransformG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_GTransformG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_GTransformG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_GTransformG_push_const_GTransform(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_GTransformG_insert_size_t_const_GTransform(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_GTransformG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_GTransformG_set_size_t_const_GTransform(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_GTypeInfoG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_GTypeInfoG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_GTypeInfoG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_GTypeInfoG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_GTypeInfoG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_GTypeInfoG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_GTypeInfoG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_GTypeInfoG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_GTypeInfoG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_GTypeInfoG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_GTypeInfoG_push_const_GTypeInfo(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_GTypeInfoG_insert_size_t_const_GTypeInfo(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_GTypeInfoG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_GTypeInfoG_set_size_t_const_GTypeInfo(instance: *mut c_void, index: size_t, val: *const c_void);
	}
}
#[cfg(ocvrs_has_module_gapi)]
pub use gapi_sys::*;

#[cfg(ocvrs_has_module_hdf)]
mod hdf_sys {
	use super::*;

	extern "C" {
		pub fn cv_hdf_open_const_StringR(hdf5_filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_hdf_HDF5_close(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_grcreate_const_StringR(instance: *mut c_void, grlabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_hlexists_const_const_StringR(instance: *const c_void, label: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_hdf_HDF5_atexists_const_const_StringR(instance: *const c_void, atlabel: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_hdf_HDF5_atdelete_const_StringR(instance: *mut c_void, atlabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_atwrite_const_int_const_StringR(instance: *mut c_void, value: i32, atlabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_atread_intX_const_StringR(instance: *mut c_void, value: *mut i32, atlabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_atwrite_const_double_const_StringR(instance: *mut c_void, value: f64, atlabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_atread_doubleX_const_StringR(instance: *mut c_void, value: *mut f64, atlabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_atwrite_const_StringR_const_StringR(instance: *mut c_void, value: *const c_char, atlabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_atread_StringX_const_StringR(instance: *mut c_void, value: *mut *mut c_void, atlabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_atwrite_const__InputArrayR_const_StringR(instance: *mut c_void, value: *const c_void, atlabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_atread_const__OutputArrayR_const_StringR(instance: *mut c_void, value: *const c_void, atlabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dscreate_const_const_int_const_int_const_int_const_StringR(instance: *const c_void, rows: i32, cols: i32, typ: i32, dslabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dscreate_const_const_int_const_int_const_int_const_StringR_const_int(instance: *const c_void, rows: i32, cols: i32, typ: i32, dslabel: *const c_char, compresslevel: i32, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dscreate_const_const_int_const_int_const_int_const_StringR_const_int_const_vectorLintGR(instance: *const c_void, rows: i32, cols: i32, typ: i32, dslabel: *const c_char, compresslevel: i32, dims_chunks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dscreate_const_const_int_const_int_const_int_const_StringR_const_int_const_intX(instance: *const c_void, rows: i32, cols: i32, typ: i32, dslabel: *const c_char, compresslevel: i32, dims_chunks: *const i32, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dscreate_const_const_int_const_intX_const_int_const_StringR(instance: *const c_void, n_dims: i32, sizes: *const i32, typ: i32, dslabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dscreate_const_const_int_const_intX_const_int_const_StringR_const_int(instance: *const c_void, n_dims: i32, sizes: *const i32, typ: i32, dslabel: *const c_char, compresslevel: i32, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dscreate_const_const_vectorLintGR_const_int_const_StringR_const_int_const_vectorLintGR(instance: *const c_void, sizes: *const c_void, typ: i32, dslabel: *const c_char, compresslevel: i32, dims_chunks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dscreate_const_const_vectorLintGR_const_int_const_StringR(instance: *const c_void, sizes: *const c_void, typ: i32, dslabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dscreate_const_const_int_const_intX_const_int_const_StringR_const_int_const_intX(instance: *const c_void, n_dims: i32, sizes: *const i32, typ: i32, dslabel: *const c_char, compresslevel: i32, dims_chunks: *const i32, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dsgetsize_const_const_StringR_int(instance: *const c_void, dslabel: *const c_char, dims_flag: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_hdf_HDF5_dsgetsize_const_const_StringR(instance: *const c_void, dslabel: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_hdf_HDF5_dsgettype_const_const_StringR(instance: *const c_void, dslabel: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_hdf_HDF5_dswrite_const_const__InputArrayR_const_StringR(instance: *const c_void, array: *const c_void, dslabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dswrite_const_const__InputArrayR_const_StringR_const_intX(instance: *const c_void, array: *const c_void, dslabel: *const c_char, dims_offset: *const i32, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dswrite_const_const__InputArrayR_const_StringR_const_vectorLintGR_const_vectorLintGR(instance: *const c_void, array: *const c_void, dslabel: *const c_char, dims_offset: *const c_void, dims_counts: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dswrite_const_const__InputArrayR_const_StringR_const_vectorLintGR(instance: *const c_void, array: *const c_void, dslabel: *const c_char, dims_offset: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dswrite_const_const__InputArrayR_const_StringR_const_intX_const_intX(instance: *const c_void, array: *const c_void, dslabel: *const c_char, dims_offset: *const i32, dims_counts: *const i32, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dsinsert_const_const__InputArrayR_const_StringR(instance: *const c_void, array: *const c_void, dslabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dsinsert_const_const__InputArrayR_const_StringR_const_intX(instance: *const c_void, array: *const c_void, dslabel: *const c_char, dims_offset: *const i32, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dsinsert_const_const__InputArrayR_const_StringR_const_vectorLintGR_const_vectorLintGR(instance: *const c_void, array: *const c_void, dslabel: *const c_char, dims_offset: *const c_void, dims_counts: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dsinsert_const_const__InputArrayR_const_StringR_const_vectorLintGR(instance: *const c_void, array: *const c_void, dslabel: *const c_char, dims_offset: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dsinsert_const_const__InputArrayR_const_StringR_const_intX_const_intX(instance: *const c_void, array: *const c_void, dslabel: *const c_char, dims_offset: *const i32, dims_counts: *const i32, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dsread_const_const__OutputArrayR_const_StringR(instance: *const c_void, array: *const c_void, dslabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dsread_const_const__OutputArrayR_const_StringR_const_intX(instance: *const c_void, array: *const c_void, dslabel: *const c_char, dims_offset: *const i32, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dsread_const_const__OutputArrayR_const_StringR_const_vectorLintGR_const_vectorLintGR(instance: *const c_void, array: *const c_void, dslabel: *const c_char, dims_offset: *const c_void, dims_counts: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dsread_const_const__OutputArrayR_const_StringR_const_vectorLintGR(instance: *const c_void, array: *const c_void, dslabel: *const c_char, dims_offset: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_dsread_const_const__OutputArrayR_const_StringR_const_intX_const_intX(instance: *const c_void, array: *const c_void, dslabel: *const c_char, dims_offset: *const i32, dims_counts: *const i32, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_kpgetsize_const_const_StringR_int(instance: *const c_void, kplabel: *const c_char, dims_flag: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_hdf_HDF5_kpgetsize_const_const_StringR(instance: *const c_void, kplabel: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_hdf_HDF5_kpcreate_const_const_int_const_StringR_const_int_const_int(instance: *const c_void, size: i32, kplabel: *const c_char, compresslevel: i32, chunks: i32, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_kpcreate_const_const_int_const_StringR(instance: *const c_void, size: i32, kplabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_kpwrite_const_const_vectorLKeyPointG_const_StringR_const_int_const_int(instance: *const c_void, keypoints: *const c_void, kplabel: *const c_char, offset: i32, counts: i32, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_kpwrite_const_const_vectorLKeyPointG_const_StringR(instance: *const c_void, keypoints: *const c_void, kplabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_kpinsert_const_const_vectorLKeyPointG_const_StringR_const_int_const_int(instance: *const c_void, keypoints: *const c_void, kplabel: *const c_char, offset: i32, counts: i32, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_kpinsert_const_const_vectorLKeyPointG_const_StringR(instance: *const c_void, keypoints: *const c_void, kplabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_kpread_const_vectorLKeyPointGR_const_StringR_const_int_const_int(instance: *const c_void, keypoints: *mut c_void, kplabel: *const c_char, offset: i32, counts: i32, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_kpread_const_vectorLKeyPointGR_const_StringR(instance: *const c_void, keypoints: *mut c_void, kplabel: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_hdf_HDF5_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_hdf_HDF5G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_hdf_HDF5G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_hdf_HDF5G_delete(instance: *mut c_void);
	}
}
#[cfg(ocvrs_has_module_hdf)]
pub use hdf_sys::*;

#[cfg(ocvrs_has_module_hfs)]
mod hfs_sys {
	use super::*;

	extern "C" {
		pub fn cv_hfs_HfsSegment_setSegEgbThresholdI_float(instance: *mut c_void, c: f32, ocvrs_return: *mut Result_void);
		pub fn cv_hfs_HfsSegment_getSegEgbThresholdI(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_hfs_HfsSegment_setMinRegionSizeI_int(instance: *mut c_void, n: i32, ocvrs_return: *mut Result_void);
		pub fn cv_hfs_HfsSegment_getMinRegionSizeI(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_hfs_HfsSegment_setSegEgbThresholdII_float(instance: *mut c_void, c: f32, ocvrs_return: *mut Result_void);
		pub fn cv_hfs_HfsSegment_getSegEgbThresholdII(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_hfs_HfsSegment_setMinRegionSizeII_int(instance: *mut c_void, n: i32, ocvrs_return: *mut Result_void);
		pub fn cv_hfs_HfsSegment_getMinRegionSizeII(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_hfs_HfsSegment_setSpatialWeight_float(instance: *mut c_void, w: f32, ocvrs_return: *mut Result_void);
		pub fn cv_hfs_HfsSegment_getSpatialWeight(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_hfs_HfsSegment_setSlicSpixelSize_int(instance: *mut c_void, n: i32, ocvrs_return: *mut Result_void);
		pub fn cv_hfs_HfsSegment_getSlicSpixelSize(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_hfs_HfsSegment_setNumSlicIter_int(instance: *mut c_void, n: i32, ocvrs_return: *mut Result_void);
		pub fn cv_hfs_HfsSegment_getNumSlicIter(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_hfs_HfsSegment_performSegmentGpu_const__InputArrayR_bool(instance: *mut c_void, src: *const c_void, if_draw: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_hfs_HfsSegment_performSegmentGpu_const__InputArrayR(instance: *mut c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_hfs_HfsSegment_performSegmentCpu_const__InputArrayR_bool(instance: *mut c_void, src: *const c_void, if_draw: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_hfs_HfsSegment_performSegmentCpu_const__InputArrayR(instance: *mut c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_hfs_HfsSegment_create_int_int_float_int_float_int_float_int_int(height: i32, width: i32, seg_egb_threshold_i: f32, min_region_size_i: i32, seg_egb_threshold_ii: f32, min_region_size_ii: i32, spatial_weight: f32, slic_spixel_size: i32, num_slic_iter: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_hfs_HfsSegment_create_int_int(height: i32, width: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_hfs_HfsSegment_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_hfs_HfsSegment_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_hfs_HfsSegmentG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_hfs_HfsSegmentG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_hfs_HfsSegmentG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_hfs_HfsSegmentG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_hfs)]
pub use hfs_sys::*;

#[cfg(ocvrs_has_module_highgui)]
mod highgui_sys {
	use super::*;

	extern "C" {
		pub fn cv_addText_const_MatR_const_StringR_Point_const_QtFontR(img: *const c_void, text: *const c_char, org: *const core::Point, font: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_addText_const_MatR_const_StringR_Point_const_StringR(img: *const c_void, text: *const c_char, org: *const core::Point, name_font: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_addText_const_MatR_const_StringR_Point_const_StringR_int_Scalar_int_int_int(img: *const c_void, text: *const c_char, org: *const core::Point, name_font: *const c_char, point_size: i32, color: *const core::Scalar, weight: i32, style: i32, spacing: i32, ocvrs_return: *mut Result_void);
		pub fn cv_createButton_const_StringR_ButtonCallback_voidX(bar_name: *const c_char, on_change: Option<unsafe extern "C" fn(i32, *mut c_void) -> ()>, userdata: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_createButton_const_StringR_ButtonCallback_voidX_int_bool(bar_name: *const c_char, on_change: Option<unsafe extern "C" fn(i32, *mut c_void) -> ()>, userdata: *mut c_void, typ: i32, initial_button_state: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_createTrackbar_const_StringR_const_StringR_intX_int_TrackbarCallback_voidX(trackbarname: *const c_char, winname: *const c_char, value: *mut i32, count: i32, on_change: Option<unsafe extern "C" fn(i32, *mut c_void) -> ()>, userdata: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_destroyAllWindows(ocvrs_return: *mut Result_void);
		pub fn cv_destroyWindow_const_StringR(winname: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_displayOverlay_const_StringR_const_StringR(winname: *const c_char, text: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_displayOverlay_const_StringR_const_StringR_int(winname: *const c_char, text: *const c_char, delayms: i32, ocvrs_return: *mut Result_void);
		pub fn cv_displayStatusBar_const_StringR_const_StringR(winname: *const c_char, text: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_displayStatusBar_const_StringR_const_StringR_int(winname: *const c_char, text: *const c_char, delayms: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fontQt_const_StringR(name_font: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_fontQt_const_StringR_int_Scalar_int_int_int(name_font: *const c_char, point_size: i32, color: *const core::Scalar, weight: i32, style: i32, spacing: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getMouseWheelDelta_int(flags: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_getTrackbarPos_const_StringR_const_StringR(trackbarname: *const c_char, winname: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_getWindowImageRect_const_StringR(winname: *const c_char, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_getWindowProperty_const_StringR_int(winname: *const c_char, prop_id: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_imshow_const_StringR_const__InputArrayR(winname: *const c_char, mat: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_loadWindowParameters_const_StringR(window_name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_moveWindow_const_StringR_int_int(winname: *const c_char, x: i32, y: i32, ocvrs_return: *mut Result_void);
		pub fn cv_namedWindow_const_StringR(winname: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_namedWindow_const_StringR_int(winname: *const c_char, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_pollKey(ocvrs_return: *mut Result<i32>);
		pub fn cv_resizeWindow_const_StringR_const_SizeR(winname: *const c_char, size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_resizeWindow_const_StringR_int_int(winname: *const c_char, width: i32, height: i32, ocvrs_return: *mut Result_void);
		pub fn cv_saveWindowParameters_const_StringR(window_name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_selectROI_const_StringR_const__InputArrayR(window_name: *const c_char, img: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_selectROI_const_StringR_const__InputArrayR_bool_bool_bool(window_name: *const c_char, img: *const c_void, show_crosshair: bool, from_center: bool, print_notice: bool, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_selectROI_const__InputArrayR(img: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_selectROI_const__InputArrayR_bool_bool_bool(img: *const c_void, show_crosshair: bool, from_center: bool, print_notice: bool, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_selectROIs_const_StringR_const__InputArrayR_vectorLRectGR(window_name: *const c_char, img: *const c_void, bounding_boxes: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_selectROIs_const_StringR_const__InputArrayR_vectorLRectGR_bool_bool_bool(window_name: *const c_char, img: *const c_void, bounding_boxes: *mut c_void, show_crosshair: bool, from_center: bool, print_notice: bool, ocvrs_return: *mut Result_void);
		pub fn cv_setMouseCallback_const_StringR_MouseCallback_voidX(winname: *const c_char, on_mouse: Option<unsafe extern "C" fn(i32, i32, i32, i32, *mut c_void) -> ()>, userdata: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_setOpenGlContext_const_StringR(winname: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_setOpenGlDrawCallback_const_StringR_OpenGlDrawCallback_voidX(winname: *const c_char, on_opengl_draw: Option<unsafe extern "C" fn(*mut c_void) -> ()>, userdata: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_setTrackbarMax_const_StringR_const_StringR_int(trackbarname: *const c_char, winname: *const c_char, maxval: i32, ocvrs_return: *mut Result_void);
		pub fn cv_setTrackbarMin_const_StringR_const_StringR_int(trackbarname: *const c_char, winname: *const c_char, minval: i32, ocvrs_return: *mut Result_void);
		pub fn cv_setTrackbarPos_const_StringR_const_StringR_int(trackbarname: *const c_char, winname: *const c_char, pos: i32, ocvrs_return: *mut Result_void);
		pub fn cv_setWindowProperty_const_StringR_int_double(winname: *const c_char, prop_id: i32, prop_value: f64, ocvrs_return: *mut Result_void);
		pub fn cv_setWindowTitle_const_StringR_const_StringR(winname: *const c_char, title: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_startLoop_int__X__int__charXX__int_charXX(pt2_func: Option<unsafe extern "C" fn(i32, *mut *mut c_char) -> i32>, argc: i32, argv: *mut *mut c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_startWindowThread(ocvrs_return: *mut Result<i32>);
		pub fn cv_stopLoop(ocvrs_return: *mut Result_void);
		pub fn cv_updateWindow_const_StringR(winname: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_waitKey(ocvrs_return: *mut Result<i32>);
		pub fn cv_waitKeyEx(ocvrs_return: *mut Result<i32>);
		pub fn cv_waitKeyEx_int(delay: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_waitKey_int(delay: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_QtFont_propNameFont_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_QtFont_propColor_const(instance: *const c_void, ocvrs_return: *mut core::Scalar);
		pub fn cv_QtFont_propColor_Scalar(instance: *mut c_void, val: *const core::Scalar);
		pub fn cv_QtFont_propFont_face_const(instance: *const c_void) -> i32;
		pub fn cv_QtFont_propFont_face_int(instance: *mut c_void, val: i32);
		pub fn cv_QtFont_propAscii_const(instance: *const c_void) -> *const i32;
		pub fn cv_QtFont_propGreek_const(instance: *const c_void) -> *const i32;
		pub fn cv_QtFont_propCyrillic_const(instance: *const c_void) -> *const i32;
		pub fn cv_QtFont_propHscale_const(instance: *const c_void) -> f32;
		pub fn cv_QtFont_propHscale_float(instance: *mut c_void, val: f32);
		pub fn cv_QtFont_propVscale_const(instance: *const c_void) -> f32;
		pub fn cv_QtFont_propVscale_float(instance: *mut c_void, val: f32);
		pub fn cv_QtFont_propShear_const(instance: *const c_void) -> f32;
		pub fn cv_QtFont_propShear_float(instance: *mut c_void, val: f32);
		pub fn cv_QtFont_propThickness_const(instance: *const c_void) -> i32;
		pub fn cv_QtFont_propThickness_int(instance: *mut c_void, val: i32);
		pub fn cv_QtFont_propDx_const(instance: *const c_void) -> f32;
		pub fn cv_QtFont_propDx_float(instance: *mut c_void, val: f32);
		pub fn cv_QtFont_propLine_type_const(instance: *const c_void) -> i32;
		pub fn cv_QtFont_propLine_type_int(instance: *mut c_void, val: i32);
		pub fn cv_QtFont_delete(instance: *mut c_void);
	}
}
#[cfg(ocvrs_has_module_highgui)]
pub use highgui_sys::*;

#[cfg(ocvrs_has_module_img_hash)]
mod img_hash_sys {
	use super::*;

	extern "C" {
		pub fn cv_img_hash_averageHash_const__InputArrayR_const__OutputArrayR(input_arr: *const c_void, output_arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_img_hash_blockMeanHash_const__InputArrayR_const__OutputArrayR(input_arr: *const c_void, output_arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_img_hash_blockMeanHash_const__InputArrayR_const__OutputArrayR_int(input_arr: *const c_void, output_arr: *const c_void, mode: i32, ocvrs_return: *mut Result_void);
		pub fn cv_img_hash_colorMomentHash_const__InputArrayR_const__OutputArrayR(input_arr: *const c_void, output_arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_img_hash_marrHildrethHash_const__InputArrayR_const__OutputArrayR(input_arr: *const c_void, output_arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_img_hash_marrHildrethHash_const__InputArrayR_const__OutputArrayR_float_float(input_arr: *const c_void, output_arr: *const c_void, alpha: f32, scale: f32, ocvrs_return: *mut Result_void);
		pub fn cv_img_hash_pHash_const__InputArrayR_const__OutputArrayR(input_arr: *const c_void, output_arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_img_hash_radialVarianceHash_const__InputArrayR_const__OutputArrayR(input_arr: *const c_void, output_arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_img_hash_radialVarianceHash_const__InputArrayR_const__OutputArrayR_double_int(input_arr: *const c_void, output_arr: *const c_void, sigma: f64, num_of_angle_line: i32, ocvrs_return: *mut Result_void);
		pub fn cv_img_hash_AverageHash_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_img_hash_AverageHash_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_img_hash_AverageHash_to_ImgHashBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_img_hash_AverageHash_delete(instance: *mut c_void);
		pub fn cv_img_hash_BlockMeanHash_setMode_int(instance: *mut c_void, mode: i32, ocvrs_return: *mut Result_void);
		pub fn cv_img_hash_BlockMeanHash_getMean_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_img_hash_BlockMeanHash_create_int(mode: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_img_hash_BlockMeanHash_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_img_hash_BlockMeanHash_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_img_hash_BlockMeanHash_to_ImgHashBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_img_hash_BlockMeanHash_delete(instance: *mut c_void);
		pub fn cv_img_hash_ColorMomentHash_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_img_hash_ColorMomentHash_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_img_hash_ColorMomentHash_to_ImgHashBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_img_hash_ColorMomentHash_delete(instance: *mut c_void);
		pub fn cv_img_hash_ImgHashBase_compute_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, input_arr: *const c_void, output_arr: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_img_hash_ImgHashBase_compare_const_const__InputArrayR_const__InputArrayR(instance: *const c_void, hash_one: *const c_void, hash_two: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_img_hash_ImgHashBase_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_img_hash_ImgHashBase_delete(instance: *mut c_void);
		pub fn cv_img_hash_MarrHildrethHash_getAlpha_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_img_hash_MarrHildrethHash_getScale_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_img_hash_MarrHildrethHash_setKernelParam_float_float(instance: *mut c_void, alpha: f32, scale: f32, ocvrs_return: *mut Result_void);
		pub fn cv_img_hash_MarrHildrethHash_create_float_float(alpha: f32, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_img_hash_MarrHildrethHash_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_img_hash_MarrHildrethHash_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_img_hash_MarrHildrethHash_to_ImgHashBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_img_hash_MarrHildrethHash_delete(instance: *mut c_void);
		pub fn cv_img_hash_PHash_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_img_hash_PHash_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_img_hash_PHash_to_ImgHashBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_img_hash_PHash_delete(instance: *mut c_void);
		pub fn cv_img_hash_RadialVarianceHash_create_double_int(sigma: f64, num_of_angle_line: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_img_hash_RadialVarianceHash_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_img_hash_RadialVarianceHash_getNumOfAngleLine_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_img_hash_RadialVarianceHash_getSigma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_img_hash_RadialVarianceHash_setNumOfAngleLine_int(instance: *mut c_void, value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_img_hash_RadialVarianceHash_setSigma_double(instance: *mut c_void, value: f64, ocvrs_return: *mut Result_void);
		pub fn cv_img_hash_RadialVarianceHash_getFeatures(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_img_hash_RadialVarianceHash_getHash(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_img_hash_RadialVarianceHash_getPixPerLine_const_MatR(instance: *mut c_void, input: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_img_hash_RadialVarianceHash_getProjection(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_img_hash_RadialVarianceHash_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_img_hash_RadialVarianceHash_to_ImgHashBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_img_hash_RadialVarianceHash_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_img_hash_AverageHashG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_AverageHashG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_AverageHashG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_img_hash_AverageHashG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_AverageHashG_to_PtrOfImgHashBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_AverageHashG_new_const_AverageHash(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_BlockMeanHashG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_BlockMeanHashG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_BlockMeanHashG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_img_hash_BlockMeanHashG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_BlockMeanHashG_to_PtrOfImgHashBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_BlockMeanHashG_new_const_BlockMeanHash(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_ColorMomentHashG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_ColorMomentHashG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_ColorMomentHashG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_img_hash_ColorMomentHashG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_ColorMomentHashG_to_PtrOfImgHashBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_ColorMomentHashG_new_const_ColorMomentHash(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_ImgHashBaseG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_ImgHashBaseG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_ImgHashBaseG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_img_hash_ImgHashBaseG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_ImgHashBaseG_new_const_ImgHashBase(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_MarrHildrethHashG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_MarrHildrethHashG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_MarrHildrethHashG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_img_hash_MarrHildrethHashG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_MarrHildrethHashG_to_PtrOfImgHashBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_MarrHildrethHashG_new_const_MarrHildrethHash(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_PHashG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_PHashG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_PHashG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_img_hash_PHashG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_PHashG_to_PtrOfImgHashBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_PHashG_new_const_PHash(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_RadialVarianceHashG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_RadialVarianceHashG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_RadialVarianceHashG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_img_hash_RadialVarianceHashG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_RadialVarianceHashG_to_PtrOfImgHashBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_img_hash_RadialVarianceHashG_new_const_RadialVarianceHash(val: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_img_hash)]
pub use img_hash_sys::*;

#[cfg(ocvrs_has_module_imgcodecs)]
mod imgcodecs_sys {
	use super::*;

	extern "C" {
		pub fn cv_haveImageReader_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_haveImageWriter_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_imcount_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<size_t>);
		pub fn cv_imcount_const_StringR_int(filename: *const c_char, flags: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_imdecode_const__InputArrayR_int(buf: *const c_void, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_imdecode_const__InputArrayR_int_MatX(buf: *const c_void, flags: i32, dst: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_imdecodemulti_const__InputArrayR_int_vectorLMatGR(buf: *const c_void, flags: i32, mats: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imencode_const_StringR_const__InputArrayR_vectorLunsigned_charGR(ext: *const c_char, img: *const c_void, buf: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imencode_const_StringR_const__InputArrayR_vectorLunsigned_charGR_const_vectorLintGR(ext: *const c_char, img: *const c_void, buf: *mut c_void, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imread_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_imread_const_StringR_int(filename: *const c_char, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_imreadmulti_const_StringR_vectorLMatGR(filename: *const c_char, mats: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imreadmulti_const_StringR_vectorLMatGR_int(filename: *const c_char, mats: *mut c_void, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_imreadmulti_const_StringR_vectorLMatGR_int_int(filename: *const c_char, mats: *mut c_void, start: i32, count: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_imreadmulti_const_StringR_vectorLMatGR_int_int_int(filename: *const c_char, mats: *mut c_void, start: i32, count: i32, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_imwrite_const_StringR_const__InputArrayR(filename: *const c_char, img: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imwrite_const_StringR_const__InputArrayR_const_vectorLintGR(filename: *const c_char, img: *const c_void, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imwritemulti_const_StringR_const__InputArrayR(filename: *const c_char, img: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imwritemulti_const_StringR_const__InputArrayR_const_vectorLintGR(filename: *const c_char, img: *const c_void, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ImageCollection_ImageCollection(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_ImageCollection_const_StringR_int(filename: *const c_char, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_init_const_StringR_int(instance: *mut c_void, img: *const c_char, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ImageCollection_size_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ImageCollection_at_int(instance: *mut c_void, index: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_operator___int(instance: *mut c_void, index: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_releaseCache_int(instance: *mut c_void, index: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ImageCollection_begin(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_end(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_delete(instance: *mut c_void);
		pub fn cv_ImageCollection_iterator_iterator_ImageCollectionX(col: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_iterator_iterator_ImageCollectionX_int(col: *mut c_void, end: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_iterator_operatorX(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_iterator_operatorAA(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_iterator_delete(instance: *mut c_void);
	}
}
#[cfg(ocvrs_has_module_imgcodecs)]
pub use imgcodecs_sys::*;

#[cfg(ocvrs_has_module_imgproc)]
mod imgproc_sys {
	use super::*;

	extern "C" {
		pub fn cv_Canny_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_double(dx: *const c_void, dy: *const c_void, edges: *const c_void, threshold1: f64, threshold2: f64, ocvrs_return: *mut Result_void);
		pub fn cv_Canny_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_double_bool(dx: *const c_void, dy: *const c_void, edges: *const c_void, threshold1: f64, threshold2: f64, l2gradient: bool, ocvrs_return: *mut Result_void);
		pub fn cv_Canny_const__InputArrayR_const__OutputArrayR_double_double(image: *const c_void, edges: *const c_void, threshold1: f64, threshold2: f64, ocvrs_return: *mut Result_void);
		pub fn cv_Canny_const__InputArrayR_const__OutputArrayR_double_double_int_bool(image: *const c_void, edges: *const c_void, threshold1: f64, threshold2: f64, aperture_size: i32, l2gradient: bool, ocvrs_return: *mut Result_void);
		pub fn cv_EMD_const__InputArrayR_const__InputArrayR_int(signature1: *const c_void, signature2: *const c_void, dist_type: i32, ocvrs_return: *mut Result<f32>);
		pub fn cv_EMD_const__InputArrayR_const__InputArrayR_int_const__InputArrayR_floatX_const__OutputArrayR(signature1: *const c_void, signature2: *const c_void, dist_type: i32, cost: *const c_void, lower_bound: *mut f32, flow: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_GaussianBlur_const__InputArrayR_const__OutputArrayR_Size_double(src: *const c_void, dst: *const c_void, ksize: *const core::Size, sigma_x: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GaussianBlur_const__InputArrayR_const__OutputArrayR_Size_double_double_int(src: *const c_void, dst: *const c_void, ksize: *const core::Size, sigma_x: f64, sigma_y: f64, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_HoughCircles_const__InputArrayR_const__OutputArrayR_int_double_double(image: *const c_void, circles: *const c_void, method: i32, dp: f64, min_dist: f64, ocvrs_return: *mut Result_void);
		pub fn cv_HoughCircles_const__InputArrayR_const__OutputArrayR_int_double_double_double_double_int_int(image: *const c_void, circles: *const c_void, method: i32, dp: f64, min_dist: f64, param1: f64, param2: f64, min_radius: i32, max_radius: i32, ocvrs_return: *mut Result_void);
		pub fn cv_HoughLinesP_const__InputArrayR_const__OutputArrayR_double_double_int(image: *const c_void, lines: *const c_void, rho: f64, theta: f64, threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_HoughLinesP_const__InputArrayR_const__OutputArrayR_double_double_int_double_double(image: *const c_void, lines: *const c_void, rho: f64, theta: f64, threshold: i32, min_line_length: f64, max_line_gap: f64, ocvrs_return: *mut Result_void);
		pub fn cv_HoughLinesPointSet_const__InputArrayR_const__OutputArrayR_int_int_double_double_double_double_double_double(point: *const c_void, lines: *const c_void, lines_max: i32, threshold: i32, min_rho: f64, max_rho: f64, rho_step: f64, min_theta: f64, max_theta: f64, theta_step: f64, ocvrs_return: *mut Result_void);
		pub fn cv_HoughLines_const__InputArrayR_const__OutputArrayR_double_double_int(image: *const c_void, lines: *const c_void, rho: f64, theta: f64, threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_HoughLines_const__InputArrayR_const__OutputArrayR_double_double_int_double_double_double_double(image: *const c_void, lines: *const c_void, rho: f64, theta: f64, threshold: i32, srn: f64, stn: f64, min_theta: f64, max_theta: f64, ocvrs_return: *mut Result_void);
		pub fn cv_HuMoments_const_MomentsR_const__OutputArrayR(m: *const core::Moments, hu: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HuMoments_const_MomentsR_doubleXX(moments: *const core::Moments, hu: *mut [f64; 7], ocvrs_return: *mut Result_void);
		pub fn cv_Laplacian_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, ddepth: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Laplacian_const__InputArrayR_const__OutputArrayR_int_int_double_double_int(src: *const c_void, dst: *const c_void, ddepth: i32, ksize: i32, scale: f64, delta: f64, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Scharr_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, ddepth: i32, dx: i32, dy: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Scharr_const__InputArrayR_const__OutputArrayR_int_int_int_double_double_int(src: *const c_void, dst: *const c_void, ddepth: i32, dx: i32, dy: i32, scale: f64, delta: f64, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Sobel_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, ddepth: i32, dx: i32, dy: i32, ocvrs_return: *mut Result_void);
		pub fn cv_Sobel_const__InputArrayR_const__OutputArrayR_int_int_int_int_double_double_int(src: *const c_void, dst: *const c_void, ddepth: i32, dx: i32, dy: i32, ksize: i32, scale: f64, delta: f64, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_accumulateProduct_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_accumulateProduct_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_accumulateSquare_const__InputArrayR_const__InputOutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_accumulateSquare_const__InputArrayR_const__InputOutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_accumulateWeighted_const__InputArrayR_const__InputOutputArrayR_double(src: *const c_void, dst: *const c_void, alpha: f64, ocvrs_return: *mut Result_void);
		pub fn cv_accumulateWeighted_const__InputArrayR_const__InputOutputArrayR_double_const__InputArrayR(src: *const c_void, dst: *const c_void, alpha: f64, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_accumulate_const__InputArrayR_const__InputOutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_accumulate_const__InputArrayR_const__InputOutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_adaptiveThreshold_const__InputArrayR_const__OutputArrayR_double_int_int_int_double(src: *const c_void, dst: *const c_void, max_value: f64, adaptive_method: i32, threshold_type: i32, block_size: i32, c: f64, ocvrs_return: *mut Result_void);
		pub fn cv_applyColorMap_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, user_color: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_applyColorMap_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, colormap: i32, ocvrs_return: *mut Result_void);
		pub fn cv_approxPolyDP_const__InputArrayR_const__OutputArrayR_double_bool(curve: *const c_void, approx_curve: *const c_void, epsilon: f64, closed: bool, ocvrs_return: *mut Result_void);
		pub fn cv_arcLength_const__InputArrayR_bool(curve: *const c_void, closed: bool, ocvrs_return: *mut Result<f64>);
		pub fn cv_arrowedLine_const__InputOutputArrayR_Point_Point_const_ScalarR(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_arrowedLine_const__InputOutputArrayR_Point_Point_const_ScalarR_int_int_int_double(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, tip_length: f64, ocvrs_return: *mut Result_void);
		pub fn cv_bilateralFilter_const__InputArrayR_const__OutputArrayR_int_double_double(src: *const c_void, dst: *const c_void, d: i32, sigma_color: f64, sigma_space: f64, ocvrs_return: *mut Result_void);
		pub fn cv_bilateralFilter_const__InputArrayR_const__OutputArrayR_int_double_double_int(src: *const c_void, dst: *const c_void, d: i32, sigma_color: f64, sigma_space: f64, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_blendLinear_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, weights1: *const c_void, weights2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_blur_const__InputArrayR_const__OutputArrayR_Size(src: *const c_void, dst: *const c_void, ksize: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_blur_const__InputArrayR_const__OutputArrayR_Size_Point_int(src: *const c_void, dst: *const c_void, ksize: *const core::Size, anchor: *const core::Point, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_boundingRect_const__InputArrayR(array: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_boxFilter_const__InputArrayR_const__OutputArrayR_int_Size(src: *const c_void, dst: *const c_void, ddepth: i32, ksize: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_boxFilter_const__InputArrayR_const__OutputArrayR_int_Size_Point_bool_int(src: *const c_void, dst: *const c_void, ddepth: i32, ksize: *const core::Size, anchor: *const core::Point, normalize: bool, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_boxPoints_RotatedRect_const__OutputArrayR(box_: *const core::RotatedRect, points: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_buildPyramid_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, maxlevel: i32, ocvrs_return: *mut Result_void);
		pub fn cv_buildPyramid_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, maxlevel: i32, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_calcBackProject_const__InputArrayR_const_vectorLintGR_const__InputArrayR_const__OutputArrayR_const_vectorLfloatGR_double(images: *const c_void, channels: *const c_void, hist: *const c_void, dst: *const c_void, ranges: *const c_void, scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_calcHist_const__InputArrayR_const_vectorLintGR_const__InputArrayR_const__OutputArrayR_const_vectorLintGR_const_vectorLfloatGR(images: *const c_void, channels: *const c_void, mask: *const c_void, hist: *const c_void, hist_size: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_calcHist_const__InputArrayR_const_vectorLintGR_const__InputArrayR_const__OutputArrayR_const_vectorLintGR_const_vectorLfloatGR_bool(images: *const c_void, channels: *const c_void, mask: *const c_void, hist: *const c_void, hist_size: *const c_void, ranges: *const c_void, accumulate: bool, ocvrs_return: *mut Result_void);
		pub fn cv_circle_const__InputOutputArrayR_Point_int_const_ScalarR(img: *const c_void, center: *const core::Point, radius: i32, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_circle_const__InputOutputArrayR_Point_int_const_ScalarR_int_int_int(img: *const c_void, center: *const core::Point, radius: i32, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, ocvrs_return: *mut Result_void);
		pub fn cv_clipLine_Rect_PointR_PointR(img_rect: *const core::Rect, pt1: *mut core::Point, pt2: *mut core::Point, ocvrs_return: *mut Result<bool>);
		pub fn cv_clipLine_Size2l_Point2lR_Point2lR(img_size: *const core::Size2l, pt1: *mut core::Point2l, pt2: *mut core::Point2l, ocvrs_return: *mut Result<bool>);
		pub fn cv_clipLine_Size_PointR_PointR(img_size: *const core::Size, pt1: *mut core::Point, pt2: *mut core::Point, ocvrs_return: *mut Result<bool>);
		pub fn cv_compareHist_const_SparseMatR_const_SparseMatR_int(h1: *const c_void, h2: *const c_void, method: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_compareHist_const__InputArrayR_const__InputArrayR_int(h1: *const c_void, h2: *const c_void, method: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_connectedComponentsWithStats_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(image: *const c_void, labels: *const c_void, stats: *const c_void, centroids: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_connectedComponentsWithStats_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_int(image: *const c_void, labels: *const c_void, stats: *const c_void, centroids: *const c_void, connectivity: i32, ltype: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_connectedComponentsWithStats_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_int_int(image: *const c_void, labels: *const c_void, stats: *const c_void, centroids: *const c_void, connectivity: i32, ltype: i32, ccltype: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_connectedComponents_const__InputArrayR_const__OutputArrayR(image: *const c_void, labels: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_connectedComponents_const__InputArrayR_const__OutputArrayR_int_int(image: *const c_void, labels: *const c_void, connectivity: i32, ltype: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_connectedComponents_const__InputArrayR_const__OutputArrayR_int_int_int(image: *const c_void, labels: *const c_void, connectivity: i32, ltype: i32, ccltype: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_contourArea_const__InputArrayR(contour: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_contourArea_const__InputArrayR_bool(contour: *const c_void, oriented: bool, ocvrs_return: *mut Result<f64>);
		pub fn cv_convertMaps_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int(map1: *const c_void, map2: *const c_void, dstmap1: *const c_void, dstmap2: *const c_void, dstmap1type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_convertMaps_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_bool(map1: *const c_void, map2: *const c_void, dstmap1: *const c_void, dstmap2: *const c_void, dstmap1type: i32, nninterpolation: bool, ocvrs_return: *mut Result_void);
		pub fn cv_convexHull_const__InputArrayR_const__OutputArrayR(points: *const c_void, hull: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_convexHull_const__InputArrayR_const__OutputArrayR_bool_bool(points: *const c_void, hull: *const c_void, clockwise: bool, return_points: bool, ocvrs_return: *mut Result_void);
		pub fn cv_convexityDefects_const__InputArrayR_const__InputArrayR_const__OutputArrayR(contour: *const c_void, convexhull: *const c_void, convexity_defects: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cornerEigenValsAndVecs_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, block_size: i32, ksize: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cornerEigenValsAndVecs_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, block_size: i32, ksize: i32, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cornerHarris_const__InputArrayR_const__OutputArrayR_int_int_double(src: *const c_void, dst: *const c_void, block_size: i32, ksize: i32, k: f64, ocvrs_return: *mut Result_void);
		pub fn cv_cornerHarris_const__InputArrayR_const__OutputArrayR_int_int_double_int(src: *const c_void, dst: *const c_void, block_size: i32, ksize: i32, k: f64, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cornerMinEigenVal_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, block_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cornerMinEigenVal_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, block_size: i32, ksize: i32, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cornerSubPix_const__InputArrayR_const__InputOutputArrayR_Size_Size_TermCriteria(image: *const c_void, corners: *const c_void, win_size: *const core::Size, zero_zone: *const core::Size, criteria: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_createCLAHE(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createCLAHE_double_Size(clip_limit: f64, tile_grid_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createGeneralizedHoughBallard(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createGeneralizedHoughGuil(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createHanningWindow_const__OutputArrayR_Size_int(dst: *const c_void, win_size: *const core::Size, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_createLineSegmentDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createLineSegmentDetector_int_double_double_double_double_double_double_int(refine: i32, scale: f64, sigma_scale: f64, quant: f64, ang_th: f64, log_eps: f64, density_th: f64, n_bins: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cvtColorTwoPlane_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, code: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cvtColor_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, code: i32, ocvrs_return: *mut Result_void);
		pub fn cv_cvtColor_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, code: i32, dst_cn: i32, ocvrs_return: *mut Result_void);
		pub fn cv_demosaicing_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, code: i32, ocvrs_return: *mut Result_void);
		pub fn cv_demosaicing_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, code: i32, dst_cn: i32, ocvrs_return: *mut Result_void);
		pub fn cv_dilate_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, kernel: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dilate_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Point_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, kernel: *const c_void, anchor: *const core::Point, iterations: i32, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_distanceTransform_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, labels: *const c_void, distance_type: i32, mask_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_distanceTransform_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, labels: *const c_void, distance_type: i32, mask_size: i32, label_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_distanceTransform_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, distance_type: i32, mask_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_distanceTransform_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, distance_type: i32, mask_size: i32, dst_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_divSpectrums_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(a: *const c_void, b: *const c_void, c: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_divSpectrums_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_bool(a: *const c_void, b: *const c_void, c: *const c_void, flags: i32, conj_b: bool, ocvrs_return: *mut Result_void);
		pub fn cv_drawContours_const__InputOutputArrayR_const__InputArrayR_int_const_ScalarR(image: *const c_void, contours: *const c_void, contour_idx: i32, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_drawContours_const__InputOutputArrayR_const__InputArrayR_int_const_ScalarR_int_int_const__InputArrayR_int_Point(image: *const c_void, contours: *const c_void, contour_idx: i32, color: *const core::Scalar, thickness: i32, line_type: i32, hierarchy: *const c_void, max_level: i32, offset: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_drawMarker_const__InputOutputArrayR_Point_const_ScalarR(img: *const c_void, position: *const core::Point, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_drawMarker_const__InputOutputArrayR_Point_const_ScalarR_int_int_int_int(img: *const c_void, position: *const core::Point, color: *const core::Scalar, marker_type: i32, marker_size: i32, thickness: i32, line_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ellipse2Poly_Point2d_Size2d_int_int_int_int_vectorLPoint2dGR(center: *const core::Point2d, axes: *const core::Size2d, angle: i32, arc_start: i32, arc_end: i32, delta: i32, pts: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ellipse2Poly_Point_Size_int_int_int_int_vectorLPointGR(center: *const core::Point, axes: *const core::Size, angle: i32, arc_start: i32, arc_end: i32, delta: i32, pts: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ellipse_const__InputOutputArrayR_Point_Size_double_double_double_const_ScalarR(img: *const c_void, center: *const core::Point, axes: *const core::Size, angle: f64, start_angle: f64, end_angle: f64, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_ellipse_const__InputOutputArrayR_Point_Size_double_double_double_const_ScalarR_int_int_int(img: *const c_void, center: *const core::Point, axes: *const core::Size, angle: f64, start_angle: f64, end_angle: f64, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ellipse_const__InputOutputArrayR_const_RotatedRectR_const_ScalarR(img: *const c_void, box_: *const core::RotatedRect, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_ellipse_const__InputOutputArrayR_const_RotatedRectR_const_ScalarR_int_int(img: *const c_void, box_: *const core::RotatedRect, color: *const core::Scalar, thickness: i32, line_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_equalizeHist_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_erode_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, kernel: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_erode_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Point_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, kernel: *const c_void, anchor: *const core::Point, iterations: i32, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_fillConvexPoly_const__InputOutputArrayR_const__InputArrayR_const_ScalarR(img: *const c_void, points: *const c_void, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_fillConvexPoly_const__InputOutputArrayR_const__InputArrayR_const_ScalarR_int_int(img: *const c_void, points: *const c_void, color: *const core::Scalar, line_type: i32, shift: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fillPoly_const__InputOutputArrayR_const__InputArrayR_const_ScalarR(img: *const c_void, pts: *const c_void, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_fillPoly_const__InputOutputArrayR_const__InputArrayR_const_ScalarR_int_int_Point(img: *const c_void, pts: *const c_void, color: *const core::Scalar, line_type: i32, shift: i32, offset: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_filter2D_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR(src: *const c_void, dst: *const c_void, ddepth: i32, kernel: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_filter2D_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR_Point_double_int(src: *const c_void, dst: *const c_void, ddepth: i32, kernel: *const c_void, anchor: *const core::Point, delta: f64, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_findContours_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_int(image: *const c_void, contours: *const c_void, hierarchy: *const c_void, mode: i32, method: i32, ocvrs_return: *mut Result_void);
		pub fn cv_findContours_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_int_Point(image: *const c_void, contours: *const c_void, hierarchy: *const c_void, mode: i32, method: i32, offset: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_findContours_const__InputArrayR_const__OutputArrayR_int_int(image: *const c_void, contours: *const c_void, mode: i32, method: i32, ocvrs_return: *mut Result_void);
		pub fn cv_findContours_const__InputArrayR_const__OutputArrayR_int_int_Point(image: *const c_void, contours: *const c_void, mode: i32, method: i32, offset: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_fitEllipseAMS_const__InputArrayR(points: *const c_void, ocvrs_return: *mut Result<core::RotatedRect>);
		pub fn cv_fitEllipseDirect_const__InputArrayR(points: *const c_void, ocvrs_return: *mut Result<core::RotatedRect>);
		pub fn cv_fitEllipse_const__InputArrayR(points: *const c_void, ocvrs_return: *mut Result<core::RotatedRect>);
		pub fn cv_fitLine_const__InputArrayR_const__OutputArrayR_int_double_double_double(points: *const c_void, line: *const c_void, dist_type: i32, param: f64, reps: f64, aeps: f64, ocvrs_return: *mut Result_void);
		pub fn cv_floodFill_const__InputOutputArrayR_Point_Scalar(image: *const c_void, seed_point: *const core::Point, new_val: *const core::Scalar, ocvrs_return: *mut Result<i32>);
		pub fn cv_floodFill_const__InputOutputArrayR_Point_Scalar_RectX_Scalar_Scalar_int(image: *const c_void, seed_point: *const core::Point, new_val: *const core::Scalar, rect: *mut core::Rect, lo_diff: *const core::Scalar, up_diff: *const core::Scalar, flags: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_floodFill_const__InputOutputArrayR_const__InputOutputArrayR_Point_Scalar(image: *const c_void, mask: *const c_void, seed_point: *const core::Point, new_val: *const core::Scalar, ocvrs_return: *mut Result<i32>);
		pub fn cv_floodFill_const__InputOutputArrayR_const__InputOutputArrayR_Point_Scalar_RectX_Scalar_Scalar_int(image: *const c_void, mask: *const c_void, seed_point: *const core::Point, new_val: *const core::Scalar, rect: *mut core::Rect, lo_diff: *const core::Scalar, up_diff: *const core::Scalar, flags: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_getAffineTransform_const_Point2fX_const_Point2fX(src: *const core::Point2f, dst: *const core::Point2f, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getAffineTransform_const__InputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getDerivKernels_const__OutputArrayR_const__OutputArrayR_int_int_int(kx: *const c_void, ky: *const c_void, dx: i32, dy: i32, ksize: i32, ocvrs_return: *mut Result_void);
		pub fn cv_getDerivKernels_const__OutputArrayR_const__OutputArrayR_int_int_int_bool_int(kx: *const c_void, ky: *const c_void, dx: i32, dy: i32, ksize: i32, normalize: bool, ktype: i32, ocvrs_return: *mut Result_void);
		pub fn cv_getFontScaleFromHeight_const_int_const_int(font_face: i32, pixel_height: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_getFontScaleFromHeight_const_int_const_int_const_int(font_face: i32, pixel_height: i32, thickness: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_getGaborKernel_Size_double_double_double_double(ksize: *const core::Size, sigma: f64, theta: f64, lambd: f64, gamma: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getGaborKernel_Size_double_double_double_double_double_int(ksize: *const core::Size, sigma: f64, theta: f64, lambd: f64, gamma: f64, psi: f64, ktype: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getGaussianKernel_int_double(ksize: i32, sigma: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getGaussianKernel_int_double_int(ksize: i32, sigma: f64, ktype: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getPerspectiveTransform_const_Point2fX_const_Point2fX(src: *const core::Point2f, dst: *const core::Point2f, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getPerspectiveTransform_const_Point2fX_const_Point2fX_int(src: *const core::Point2f, dst: *const core::Point2f, solve_method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getPerspectiveTransform_const__InputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getPerspectiveTransform_const__InputArrayR_const__InputArrayR_int(src: *const c_void, dst: *const c_void, solve_method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getRectSubPix_const__InputArrayR_Size_Point2f_const__OutputArrayR(image: *const c_void, patch_size: *const core::Size, center: *const core::Point2f, patch: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_getRectSubPix_const__InputArrayR_Size_Point2f_const__OutputArrayR_int(image: *const c_void, patch_size: *const core::Size, center: *const core::Point2f, patch: *const c_void, patch_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_getRotationMatrix2D_Point2f_double_double(center: *const core::Point2f, angle: f64, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		#[cfg(not(target_os = "windows"))]
		pub fn cv_getRotationMatrix2D__Point2f_double_double(center: *const core::Point2f, angle: f64, scale: f64, ocvrs_return: *mut Result<core::Matx23d>);
		pub fn cv_getStructuringElement_int_Size(shape: i32, ksize: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getStructuringElement_int_Size_Point(shape: i32, ksize: *const core::Size, anchor: *const core::Point, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getTextSize_const_StringR_int_double_int_intX(text: *const c_char, font_face: i32, font_scale: f64, thickness: i32, base_line: *mut i32, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_goodFeaturesToTrack_const__InputArrayR_const__OutputArrayR_int_double_double(image: *const c_void, corners: *const c_void, max_corners: i32, quality_level: f64, min_distance: f64, ocvrs_return: *mut Result_void);
		pub fn cv_goodFeaturesToTrack_const__InputArrayR_const__OutputArrayR_int_double_double_const__InputArrayR_const__OutputArrayR(image: *const c_void, corners: *const c_void, max_corners: i32, quality_level: f64, min_distance: f64, mask: *const c_void, corners_quality: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_goodFeaturesToTrack_const__InputArrayR_const__OutputArrayR_int_double_double_const__InputArrayR_const__OutputArrayR_int_int_bool_double(image: *const c_void, corners: *const c_void, max_corners: i32, quality_level: f64, min_distance: f64, mask: *const c_void, corners_quality: *const c_void, block_size: i32, gradient_size: i32, use_harris_detector: bool, k: f64, ocvrs_return: *mut Result_void);
		pub fn cv_goodFeaturesToTrack_const__InputArrayR_const__OutputArrayR_int_double_double_const__InputArrayR_int_bool_double(image: *const c_void, corners: *const c_void, max_corners: i32, quality_level: f64, min_distance: f64, mask: *const c_void, block_size: i32, use_harris_detector: bool, k: f64, ocvrs_return: *mut Result_void);
		pub fn cv_goodFeaturesToTrack_const__InputArrayR_const__OutputArrayR_int_double_double_const__InputArrayR_int_int(image: *const c_void, corners: *const c_void, max_corners: i32, quality_level: f64, min_distance: f64, mask: *const c_void, block_size: i32, gradient_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_goodFeaturesToTrack_const__InputArrayR_const__OutputArrayR_int_double_double_const__InputArrayR_int_int_bool_double(image: *const c_void, corners: *const c_void, max_corners: i32, quality_level: f64, min_distance: f64, mask: *const c_void, block_size: i32, gradient_size: i32, use_harris_detector: bool, k: f64, ocvrs_return: *mut Result_void);
		pub fn cv_grabCut_const__InputArrayR_const__InputOutputArrayR_Rect_const__InputOutputArrayR_const__InputOutputArrayR_int(img: *const c_void, mask: *const c_void, rect: *const core::Rect, bgd_model: *const c_void, fgd_model: *const c_void, iter_count: i32, ocvrs_return: *mut Result_void);
		pub fn cv_grabCut_const__InputArrayR_const__InputOutputArrayR_Rect_const__InputOutputArrayR_const__InputOutputArrayR_int_int(img: *const c_void, mask: *const c_void, rect: *const core::Rect, bgd_model: *const c_void, fgd_model: *const c_void, iter_count: i32, mode: i32, ocvrs_return: *mut Result_void);
		pub fn cv_integral_const__InputArrayR_const__OutputArrayR(src: *const c_void, sum: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_integral_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, sum: *const c_void, sqsum: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_integral_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, sum: *const c_void, sqsum: *const c_void, tilted: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_integral_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_int(src: *const c_void, sum: *const c_void, sqsum: *const c_void, tilted: *const c_void, sdepth: i32, sqdepth: i32, ocvrs_return: *mut Result_void);
		pub fn cv_integral_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_int(src: *const c_void, sum: *const c_void, sqsum: *const c_void, sdepth: i32, sqdepth: i32, ocvrs_return: *mut Result_void);
		pub fn cv_integral_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, sum: *const c_void, sdepth: i32, ocvrs_return: *mut Result_void);
		pub fn cv_intersectConvexConvex_const__InputArrayR_const__InputArrayR_const__OutputArrayR(p1: *const c_void, p2: *const c_void, p12: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_intersectConvexConvex_const__InputArrayR_const__InputArrayR_const__OutputArrayR_bool(p1: *const c_void, p2: *const c_void, p12: *const c_void, handle_nested: bool, ocvrs_return: *mut Result<f32>);
		pub fn cv_invertAffineTransform_const__InputArrayR_const__OutputArrayR(m: *const c_void, i_m: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_isContourConvex_const__InputArrayR(contour: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_line_const__InputOutputArrayR_Point_Point_const_ScalarR(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_line_const__InputOutputArrayR_Point_Point_const_ScalarR_int_int_int(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, ocvrs_return: *mut Result_void);
		pub fn cv_linearPolar_const__InputArrayR_const__OutputArrayR_Point2f_double_int(src: *const c_void, dst: *const c_void, center: *const core::Point2f, max_radius: f64, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_logPolar_const__InputArrayR_const__OutputArrayR_Point2f_double_int(src: *const c_void, dst: *const c_void, center: *const core::Point2f, m: f64, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_matchShapes_const__InputArrayR_const__InputArrayR_int_double(contour1: *const c_void, contour2: *const c_void, method: i32, parameter: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_matchTemplate_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(image: *const c_void, templ: *const c_void, result: *const c_void, method: i32, ocvrs_return: *mut Result_void);
		pub fn cv_matchTemplate_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR(image: *const c_void, templ: *const c_void, result: *const c_void, method: i32, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_medianBlur_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, ksize: i32, ocvrs_return: *mut Result_void);
		pub fn cv_minAreaRect_const__InputArrayR(points: *const c_void, ocvrs_return: *mut Result<core::RotatedRect>);
		pub fn cv_minEnclosingCircle_const__InputArrayR_Point2fR_floatR(points: *const c_void, center: *mut core::Point2f, radius: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_minEnclosingTriangle_const__InputArrayR_const__OutputArrayR(points: *const c_void, triangle: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_moments_const__InputArrayR(array: *const c_void, ocvrs_return: *mut Result<core::Moments>);
		pub fn cv_moments_const__InputArrayR_bool(array: *const c_void, binary_image: bool, ocvrs_return: *mut Result<core::Moments>);
		pub fn cv_morphologyDefaultBorderValue(ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_morphologyEx_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR(src: *const c_void, dst: *const c_void, op: i32, kernel: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_morphologyEx_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR_Point_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, op: i32, kernel: *const c_void, anchor: *const core::Point, iterations: i32, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_phaseCorrelate_const__InputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<core::Point2d>);
		pub fn cv_phaseCorrelate_const__InputArrayR_const__InputArrayR_const__InputArrayR_doubleX(src1: *const c_void, src2: *const c_void, window: *const c_void, response: *mut f64, ocvrs_return: *mut Result<core::Point2d>);
		pub fn cv_pointPolygonTest_const__InputArrayR_Point2f_bool(contour: *const c_void, pt: *const core::Point2f, measure_dist: bool, ocvrs_return: *mut Result<f64>);
		pub fn cv_polylines_const__InputOutputArrayR_const__InputArrayR_bool_const_ScalarR(img: *const c_void, pts: *const c_void, is_closed: bool, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_polylines_const__InputOutputArrayR_const__InputArrayR_bool_const_ScalarR_int_int_int(img: *const c_void, pts: *const c_void, is_closed: bool, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, ocvrs_return: *mut Result_void);
		pub fn cv_preCornerDetect_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, ksize: i32, ocvrs_return: *mut Result_void);
		pub fn cv_preCornerDetect_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, ksize: i32, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_putText_const__InputOutputArrayR_const_StringR_Point_int_double_Scalar(img: *const c_void, text: *const c_char, org: *const core::Point, font_face: i32, font_scale: f64, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_putText_const__InputOutputArrayR_const_StringR_Point_int_double_Scalar_int_int_bool(img: *const c_void, text: *const c_char, org: *const core::Point, font_face: i32, font_scale: f64, color: *const core::Scalar, thickness: i32, line_type: i32, bottom_left_origin: bool, ocvrs_return: *mut Result_void);
		pub fn cv_pyrDown_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_pyrDown_const__InputArrayR_const__OutputArrayR_const_SizeR_int(src: *const c_void, dst: *const c_void, dstsize: *const core::Size, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_pyrMeanShiftFiltering_const__InputArrayR_const__OutputArrayR_double_double(src: *const c_void, dst: *const c_void, sp: f64, sr: f64, ocvrs_return: *mut Result_void);
		pub fn cv_pyrMeanShiftFiltering_const__InputArrayR_const__OutputArrayR_double_double_int_TermCriteria(src: *const c_void, dst: *const c_void, sp: f64, sr: f64, max_level: i32, termcrit: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_pyrUp_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_pyrUp_const__InputArrayR_const__OutputArrayR_const_SizeR_int(src: *const c_void, dst: *const c_void, dstsize: *const core::Size, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rectangle_const__InputOutputArrayR_Point_Point_const_ScalarR(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_rectangle_const__InputOutputArrayR_Point_Point_const_ScalarR_int_int_int(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rectangle_const__InputOutputArrayR_Rect_const_ScalarR(img: *const c_void, rec: *const core::Rect, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_rectangle_const__InputOutputArrayR_Rect_const_ScalarR_int_int_int(img: *const c_void, rec: *const core::Rect, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, ocvrs_return: *mut Result_void);
		pub fn cv_remap_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_int(src: *const c_void, dst: *const c_void, map1: *const c_void, map2: *const c_void, interpolation: i32, ocvrs_return: *mut Result_void);
		pub fn cv_remap_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, map1: *const c_void, map2: *const c_void, interpolation: i32, border_mode: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_resize_const__InputArrayR_const__OutputArrayR_Size(src: *const c_void, dst: *const c_void, dsize: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_resize_const__InputArrayR_const__OutputArrayR_Size_double_double_int(src: *const c_void, dst: *const c_void, dsize: *const core::Size, fx: f64, fy: f64, interpolation: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rotatedRectangleIntersection_const_RotatedRectR_const_RotatedRectR_const__OutputArrayR(rect1: *const core::RotatedRect, rect2: *const core::RotatedRect, intersecting_region: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_sepFilter2D_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, ddepth: i32, kernel_x: *const c_void, kernel_y: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sepFilter2D_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR_const__InputArrayR_Point_double_int(src: *const c_void, dst: *const c_void, ddepth: i32, kernel_x: *const c_void, kernel_y: *const c_void, anchor: *const core::Point, delta: f64, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_spatialGradient_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, dx: *const c_void, dy: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_spatialGradient_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_int(src: *const c_void, dx: *const c_void, dy: *const c_void, ksize: i32, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_sqrBoxFilter_const__InputArrayR_const__OutputArrayR_int_Size(src: *const c_void, dst: *const c_void, ddepth: i32, ksize: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_sqrBoxFilter_const__InputArrayR_const__OutputArrayR_int_Size_Point_bool_int(src: *const c_void, dst: *const c_void, ddepth: i32, ksize: *const core::Size, anchor: *const core::Point, normalize: bool, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_stackBlur_const__InputArrayR_const__OutputArrayR_Size(src: *const c_void, dst: *const c_void, ksize: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_threshold_const__InputArrayR_const__OutputArrayR_double_double_int(src: *const c_void, dst: *const c_void, thresh: f64, maxval: f64, typ: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_warpAffine_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Size(src: *const c_void, dst: *const c_void, m: *const c_void, dsize: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_warpAffine_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Size_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, m: *const c_void, dsize: *const core::Size, flags: i32, border_mode: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_warpPerspective_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Size(src: *const c_void, dst: *const c_void, m: *const c_void, dsize: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_warpPerspective_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Size_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, m: *const c_void, dsize: *const core::Size, flags: i32, border_mode: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_warpPolar_const__InputArrayR_const__OutputArrayR_Size_Point2f_double_int(src: *const c_void, dst: *const c_void, dsize: *const core::Size, center: *const core::Point2f, max_radius: f64, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_watershed_const__InputArrayR_const__InputOutputArrayR(image: *const c_void, markers: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_wrapperEMD_const__InputArrayR_const__InputArrayR_int(signature1: *const c_void, signature2: *const c_void, dist_type: i32, ocvrs_return: *mut Result<f32>);
		pub fn cv_wrapperEMD_const__InputArrayR_const__InputArrayR_int_const__InputArrayR_PtrLfloatG_const__OutputArrayR(signature1: *const c_void, signature2: *const c_void, dist_type: i32, cost: *const c_void, lower_bound: *mut c_void, flow: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_CLAHE_apply_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_CLAHE_setClipLimit_double(instance: *mut c_void, clip_limit: f64, ocvrs_return: *mut Result_void);
		pub fn cv_CLAHE_getClipLimit_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_CLAHE_setTilesGridSize_Size(instance: *mut c_void, tile_grid_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_CLAHE_getTilesGridSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_CLAHE_collectGarbage(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_CLAHE_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_CLAHE_delete(instance: *mut c_void);
		pub fn cv_GeneralizedHough_setTemplate_const__InputArrayR_Point(instance: *mut c_void, templ: *const c_void, templ_center: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_setTemplate_const__InputArrayR(instance: *mut c_void, templ: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_setTemplate_const__InputArrayR_const__InputArrayR_const__InputArrayR_Point(instance: *mut c_void, edges: *const c_void, dx: *const c_void, dy: *const c_void, templ_center: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_setTemplate_const__InputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, edges: *const c_void, dx: *const c_void, dy: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_detect_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, positions: *const c_void, votes: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_detect_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, positions: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_detect_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, edges: *const c_void, dx: *const c_void, dy: *const c_void, positions: *const c_void, votes: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_detect_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, edges: *const c_void, dx: *const c_void, dy: *const c_void, positions: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_setCannyLowThresh_int(instance: *mut c_void, canny_low_thresh: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_getCannyLowThresh_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHough_setCannyHighThresh_int(instance: *mut c_void, canny_high_thresh: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_getCannyHighThresh_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHough_setMinDist_double(instance: *mut c_void, min_dist: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_getMinDist_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHough_setDp_double(instance: *mut c_void, dp: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_getDp_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHough_setMaxBufferSize_int(instance: *mut c_void, max_buffer_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHough_getMaxBufferSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHough_to_GeneralizedHoughBallard(instance: *mut c_void) -> *mut c_void;
		pub fn cv_GeneralizedHough_to_GeneralizedHoughGuil(instance: *mut c_void) -> *mut c_void;
		pub fn cv_GeneralizedHough_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_GeneralizedHough_delete(instance: *mut c_void);
		pub fn cv_GeneralizedHoughBallard_setLevels_int(instance: *mut c_void, levels: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughBallard_getLevels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHoughBallard_setVotesThreshold_int(instance: *mut c_void, votes_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughBallard_getVotesThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHoughBallard_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_GeneralizedHoughBallard_to_GeneralizedHough(instance: *mut c_void) -> *mut c_void;
		pub fn cv_GeneralizedHoughBallard_delete(instance: *mut c_void);
		pub fn cv_GeneralizedHoughGuil_setXi_double(instance: *mut c_void, xi: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getXi_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setLevels_int(instance: *mut c_void, levels: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getLevels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHoughGuil_setAngleEpsilon_double(instance: *mut c_void, angle_epsilon: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getAngleEpsilon_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setMinAngle_double(instance: *mut c_void, min_angle: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getMinAngle_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setMaxAngle_double(instance: *mut c_void, max_angle: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getMaxAngle_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setAngleStep_double(instance: *mut c_void, angle_step: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getAngleStep_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setAngleThresh_int(instance: *mut c_void, angle_thresh: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getAngleThresh_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHoughGuil_setMinScale_double(instance: *mut c_void, min_scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getMinScale_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setMaxScale_double(instance: *mut c_void, max_scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getMaxScale_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setScaleStep_double(instance: *mut c_void, scale_step: f64, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getScaleStep_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setScaleThresh_int(instance: *mut c_void, scale_thresh: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getScaleThresh_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHoughGuil_setPosThresh_int(instance: *mut c_void, pos_thresh: i32, ocvrs_return: *mut Result_void);
		pub fn cv_GeneralizedHoughGuil_getPosThresh_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHoughGuil_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_GeneralizedHoughGuil_to_GeneralizedHough(instance: *mut c_void) -> *mut c_void;
		pub fn cv_GeneralizedHoughGuil_delete(instance: *mut c_void);
		pub fn cv_LineIterator_LineIterator_const_MatR_Point_Point_int_bool(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, connectivity: i32, left_to_right: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_LineIterator_const_MatR_Point_Point(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_LineIterator_Point_Point_int_bool(pt1: *const core::Point, pt2: *const core::Point, connectivity: i32, left_to_right: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_LineIterator_Point_Point(pt1: *const core::Point, pt2: *const core::Point, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_LineIterator_Size_Point_Point_int_bool(bounding_area_size: *const core::Size, pt1: *const core::Point, pt2: *const core::Point, connectivity: i32, left_to_right: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_LineIterator_Size_Point_Point(bounding_area_size: *const core::Size, pt1: *const core::Point, pt2: *const core::Point, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_LineIterator_Rect_Point_Point_int_bool(bounding_area_rect: *const core::Rect, pt1: *const core::Point, pt2: *const core::Point, connectivity: i32, left_to_right: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_LineIterator_Rect_Point_Point(bounding_area_rect: *const core::Rect, pt1: *const core::Point, pt2: *const core::Point, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_init_const_MatX_Rect_Point_Point_int_bool(instance: *mut c_void, img: *const c_void, bounding_area_rect: *const core::Rect, pt1: *const core::Point, pt2: *const core::Point, connectivity: i32, left_to_right: bool, ocvrs_return: *mut Result_void);
		pub fn cv_LineIterator_operatorX(instance: *mut c_void, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_LineIterator_operatorAA(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_pos_const(instance: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_LineIterator_propPtr(instance: *mut c_void) -> *mut u8;
		pub fn cv_LineIterator_propPtr_unsigned_charX(instance: *mut c_void, val: *mut u8);
		pub fn cv_LineIterator_propPtr0_const(instance: *const c_void) -> *const u8;
		pub fn cv_LineIterator_propStep_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propStep_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propElemSize_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propElemSize_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propErr_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propErr_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propCount_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propCount_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propMinusDelta_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propMinusDelta_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propPlusDelta_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propPlusDelta_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propMinusStep_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propMinusStep_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propPlusStep_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propPlusStep_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propMinusShift_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propMinusShift_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propPlusShift_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propPlusShift_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propP_const(instance: *const c_void, ocvrs_return: *mut core::Point);
		pub fn cv_LineIterator_propP_Point(instance: *mut c_void, val: *const core::Point);
		pub fn cv_LineIterator_propPtmode_const(instance: *const c_void) -> bool;
		pub fn cv_LineIterator_propPtmode_bool(instance: *mut c_void, val: bool);
		pub fn cv_LineIterator_delete(instance: *mut c_void);
		pub fn cv_LineSegmentDetector_detect_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, lines: *const c_void, width: *const c_void, prec: *const c_void, nfa: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_LineSegmentDetector_detect_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, lines: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_LineSegmentDetector_drawSegments_const__InputOutputArrayR_const__InputArrayR(instance: *mut c_void, image: *const c_void, lines: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_LineSegmentDetector_compareSegments_const_SizeR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR(instance: *mut c_void, size: *const core::Size, lines1: *const c_void, lines2: *const c_void, image: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_LineSegmentDetector_compareSegments_const_SizeR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, size: *const core::Size, lines1: *const c_void, lines2: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_LineSegmentDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_LineSegmentDetector_delete(instance: *mut c_void);
		pub fn cv_Subdiv2D_Subdiv2D(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Subdiv2D_Subdiv2D_Rect(rect: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Subdiv2D_initDelaunay_Rect(instance: *mut c_void, rect: *const core::Rect, ocvrs_return: *mut Result_void);
		pub fn cv_Subdiv2D_insert_Point2f(instance: *mut c_void, pt: *const core::Point2f, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_insert_const_vectorLPoint2fGR(instance: *mut c_void, ptvec: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Subdiv2D_locate_Point2f_intR_intR(instance: *mut c_void, pt: *const core::Point2f, edge: *mut i32, vertex: *mut i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_findNearest_Point2f_Point2fX(instance: *mut c_void, pt: *const core::Point2f, nearest_pt: *mut core::Point2f, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_findNearest_Point2f(instance: *mut c_void, pt: *const core::Point2f, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_getEdgeList_const_vectorLVec4fGR(instance: *const c_void, edge_list: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Subdiv2D_getLeadingEdgeList_const_vectorLintGR(instance: *const c_void, leading_edge_list: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Subdiv2D_getTriangleList_const_vectorLVec6fGR(instance: *const c_void, triangle_list: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Subdiv2D_getVoronoiFacetList_const_vectorLintGR_vectorLvectorLPoint2fGGR_vectorLPoint2fGR(instance: *mut c_void, idx: *const c_void, facet_list: *mut c_void, facet_centers: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Subdiv2D_getVertex_const_int_intX(instance: *const c_void, vertex: i32, first_edge: *mut i32, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_Subdiv2D_getVertex_const_int(instance: *const c_void, vertex: i32, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_Subdiv2D_getEdge_const_int_int(instance: *const c_void, edge: i32, next_edge_type: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_nextEdge_const_int(instance: *const c_void, edge: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_rotateEdge_const_int_int(instance: *const c_void, edge: i32, rotate: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_symEdge_const_int(instance: *const c_void, edge: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_edgeOrg_const_int_Point2fX(instance: *const c_void, edge: i32, orgpt: *mut core::Point2f, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_edgeOrg_const_int(instance: *const c_void, edge: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_edgeDst_const_int_Point2fX(instance: *const c_void, edge: i32, dstpt: *mut core::Point2f, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_edgeDst_const_int(instance: *const c_void, edge: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_delete(instance: *mut c_void);
		pub fn cv_segmentation_IntelligentScissorsMB_IntelligentScissorsMB(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_setWeights_float_float_float(instance: *mut c_void, weight_non_edge: f32, weight_gradient_direction: f32, weight_gradient_magnitude: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_setGradientMagnitudeMaxLimit_float(instance: *mut c_void, gradient_magnitude_threshold_max: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_setGradientMagnitudeMaxLimit(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_setEdgeFeatureZeroCrossingParameters_float(instance: *mut c_void, gradient_magnitude_min_value: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_setEdgeFeatureZeroCrossingParameters(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_setEdgeFeatureCannyParameters_double_double_int_bool(instance: *mut c_void, threshold1: f64, threshold2: f64, aperture_size: i32, l2gradient: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_setEdgeFeatureCannyParameters_double_double(instance: *mut c_void, threshold1: f64, threshold2: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_applyImage_const__InputArrayR(instance: *mut c_void, image: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_applyImageFeatures_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, non_edge: *const c_void, gradient_direction: *const c_void, gradient_magnitude: *const c_void, image: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_applyImageFeatures_const__InputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, non_edge: *const c_void, gradient_direction: *const c_void, gradient_magnitude: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_buildMap_const_PointR(instance: *mut c_void, source_pt: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_segmentation_IntelligentScissorsMB_getContour_const_const_PointR_const__OutputArrayR_bool(instance: *const c_void, target_pt: *const core::Point, contour: *const c_void, backward: bool, ocvrs_return: *mut Result_void);
		pub fn cv_segmentation_IntelligentScissorsMB_getContour_const_const_PointR_const__OutputArrayR(instance: *const c_void, target_pt: *const core::Point, contour: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_segmentation_IntelligentScissorsMB_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_segmentation_IntelligentScissorsMB_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_CLAHEG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CLAHEG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CLAHEG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_CLAHEG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_GeneralizedHoughG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughBallardG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughBallardG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughBallardG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_GeneralizedHoughBallardG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughBallardG_to_PtrOfGeneralizedHough(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughGuilG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughGuilG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughGuilG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_GeneralizedHoughGuilG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughGuilG_to_PtrOfGeneralizedHough(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_LineSegmentDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_LineSegmentDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_LineSegmentDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_LineSegmentDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_imgproc)]
pub use imgproc_sys::*;

#[cfg(ocvrs_has_module_intensity_transform)]
mod intensity_transform_sys {
	use super::*;

	extern "C" {
		pub fn cv_intensity_transform_BIMEF_const__InputArrayR_const__OutputArrayR(input: *const c_void, output: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_intensity_transform_BIMEF_const__InputArrayR_const__OutputArrayR_float_float_float(input: *const c_void, output: *const c_void, mu: f32, a: f32, b: f32, ocvrs_return: *mut Result_void);
		pub fn cv_intensity_transform_BIMEF_const__InputArrayR_const__OutputArrayR_float_float_float_float(input: *const c_void, output: *const c_void, k: f32, mu: f32, a: f32, b: f32, ocvrs_return: *mut Result_void);
		pub fn cv_intensity_transform_autoscaling_const_Mat_MatR(input: *const c_void, output: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_intensity_transform_contrastStretching_const_Mat_MatR_const_int_const_int_const_int_const_int(input: *const c_void, output: *mut c_void, r1: i32, s1: i32, r2: i32, s2: i32, ocvrs_return: *mut Result_void);
		pub fn cv_intensity_transform_gammaCorrection_const_Mat_MatR_const_float(input: *const c_void, output: *mut c_void, gamma: f32, ocvrs_return: *mut Result_void);
		pub fn cv_intensity_transform_logTransform_const_Mat_MatR(input: *const c_void, output: *mut c_void, ocvrs_return: *mut Result_void);
	}
}
#[cfg(ocvrs_has_module_intensity_transform)]
pub use intensity_transform_sys::*;

#[cfg(ocvrs_has_module_line_descriptor)]
mod line_descriptor_sys {
	use super::*;

	extern "C" {
		pub fn cv_line_descriptor_drawKeylines_const_MatR_const_vectorLKeyLineGR_MatR(image: *const c_void, keylines: *const c_void, out_image: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_drawKeylines_const_MatR_const_vectorLKeyLineGR_MatR_const_ScalarR_int(image: *const c_void, keylines: *const c_void, out_image: *mut c_void, color: *const core::Scalar, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_drawLineMatches_const_MatR_const_vectorLKeyLineGR_const_MatR_const_vectorLKeyLineGR_const_vectorLDMatchGR_MatR(img1: *const c_void, keylines1: *const c_void, img2: *const c_void, keylines2: *const c_void, matches1to2: *const c_void, out_img: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_drawLineMatches_const_MatR_const_vectorLKeyLineGR_const_MatR_const_vectorLKeyLineGR_const_vectorLDMatchGR_MatR_const_ScalarR_const_ScalarR_const_vectorLcharGR_int(img1: *const c_void, keylines1: *const c_void, img2: *const c_void, keylines2: *const c_void, matches1to2: *const c_void, out_img: *mut c_void, match_color: *const core::Scalar, single_line_color: *const core::Scalar, matches_mask: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptor_BinaryDescriptor_const_ParamsR(parameters: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_line_descriptor_BinaryDescriptor_BinaryDescriptor(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_line_descriptor_BinaryDescriptor_createBinaryDescriptor(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_line_descriptor_BinaryDescriptor_createBinaryDescriptor_Params(parameters: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_line_descriptor_BinaryDescriptor_getNumOfOctaves(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_line_descriptor_BinaryDescriptor_setNumOfOctaves_int(instance: *mut c_void, octaves: i32, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptor_getWidthOfBand(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_line_descriptor_BinaryDescriptor_setWidthOfBand_int(instance: *mut c_void, width: i32, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptor_getReductionRatio(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_line_descriptor_BinaryDescriptor_setReductionRatio_int(instance: *mut c_void, r_ratio: i32, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptor_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptor_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptor_detect_const_MatR_vectorLKeyLineGR_const_MatR(instance: *mut c_void, image: *const c_void, keypoints: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptor_detect_const_MatR_vectorLKeyLineGR(instance: *mut c_void, image: *const c_void, keypoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptor_detect_const_const_vectorLMatGR_vectorLvectorLKeyLineGGR_const_vectorLMatGR(instance: *const c_void, images: *const c_void, keylines: *mut c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptor_detect_const_const_vectorLMatGR_vectorLvectorLKeyLineGGR(instance: *const c_void, images: *const c_void, keylines: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptor_compute_const_const_MatR_vectorLKeyLineGR_MatR_bool(instance: *const c_void, image: *const c_void, keylines: *mut c_void, descriptors: *mut c_void, return_float_descr: bool, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptor_compute_const_const_MatR_vectorLKeyLineGR_MatR(instance: *const c_void, image: *const c_void, keylines: *mut c_void, descriptors: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptor_compute_const_const_vectorLMatGR_vectorLvectorLKeyLineGGR_vectorLMatGR_bool(instance: *const c_void, images: *const c_void, keylines: *mut c_void, descriptors: *mut c_void, return_float_descr: bool, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptor_compute_const_const_vectorLMatGR_vectorLvectorLKeyLineGGR_vectorLMatGR(instance: *const c_void, images: *const c_void, keylines: *mut c_void, descriptors: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptor_descriptorSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_line_descriptor_BinaryDescriptor_descriptorType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_line_descriptor_BinaryDescriptor_defaultNorm_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_line_descriptor_BinaryDescriptor_operator___const_const__InputArrayR_const__InputArrayR_vectorLKeyLineGR_const__OutputArrayR_bool_bool(instance: *const c_void, image: *const c_void, mask: *const c_void, keylines: *mut c_void, descriptors: *const c_void, use_provided_key_lines: bool, return_float_descr: bool, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptor_operator___const_const__InputArrayR_const__InputArrayR_vectorLKeyLineGR_const__OutputArrayR(instance: *const c_void, image: *const c_void, mask: *const c_void, keylines: *mut c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptor_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_line_descriptor_BinaryDescriptor_delete(instance: *mut c_void);
		pub fn cv_line_descriptor_BinaryDescriptor_Params_Params(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_line_descriptor_BinaryDescriptor_Params_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptor_Params_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptor_Params_propNumOfOctave__const(instance: *const c_void) -> i32;
		pub fn cv_line_descriptor_BinaryDescriptor_Params_propNumOfOctave__int(instance: *mut c_void, val: i32);
		pub fn cv_line_descriptor_BinaryDescriptor_Params_propWidthOfBand__const(instance: *const c_void) -> i32;
		pub fn cv_line_descriptor_BinaryDescriptor_Params_propWidthOfBand__int(instance: *mut c_void, val: i32);
		pub fn cv_line_descriptor_BinaryDescriptor_Params_propReductionRatio_const(instance: *const c_void) -> i32;
		pub fn cv_line_descriptor_BinaryDescriptor_Params_propReductionRatio_int(instance: *mut c_void, val: i32);
		pub fn cv_line_descriptor_BinaryDescriptor_Params_propKsize__const(instance: *const c_void) -> i32;
		pub fn cv_line_descriptor_BinaryDescriptor_Params_propKsize__int(instance: *mut c_void, val: i32);
		pub fn cv_line_descriptor_BinaryDescriptor_Params_delete(instance: *mut c_void);
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_match_const_const_MatR_const_MatR_vectorLDMatchGR_const_MatR(instance: *const c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_match_const_const_MatR_const_MatR_vectorLDMatchGR(instance: *const c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_match_const_MatR_vectorLDMatchGR_const_vectorLMatGR(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_match_const_MatR_vectorLDMatchGR(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_knnMatch_const_const_MatR_const_MatR_vectorLvectorLDMatchGGR_int_const_MatR_bool(instance: *const c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, k: i32, mask: *const c_void, compact_result: bool, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_knnMatch_const_const_MatR_const_MatR_vectorLvectorLDMatchGGR_int(instance: *const c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_knnMatch_const_MatR_vectorLvectorLDMatchGGR_int_const_vectorLMatGR_bool(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, k: i32, masks: *const c_void, compact_result: bool, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_knnMatch_const_MatR_vectorLvectorLDMatchGGR_int(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_radiusMatch_const_const_MatR_const_MatR_vectorLvectorLDMatchGGR_float_const_MatR_bool(instance: *const c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, max_distance: f32, mask: *const c_void, compact_result: bool, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_radiusMatch_const_const_MatR_const_MatR_vectorLvectorLDMatchGGR_float(instance: *const c_void, query_descriptors: *const c_void, train_descriptors: *const c_void, matches: *mut c_void, max_distance: f32, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_radiusMatch_const_MatR_vectorLvectorLDMatchGGR_float_const_vectorLMatGR_bool(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, max_distance: f32, masks: *const c_void, compact_result: bool, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_radiusMatch_const_MatR_vectorLvectorLDMatchGGR_float(instance: *mut c_void, query_descriptors: *const c_void, matches: *mut c_void, max_distance: f32, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_add_const_vectorLMatGR(instance: *mut c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_train(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_createBinaryDescriptorMatcher(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_BinaryDescriptorMatcher(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_line_descriptor_BinaryDescriptorMatcher_delete(instance: *mut c_void);
		pub fn cv_line_descriptor_KeyLine_getStartPoint_const(instance: *const crate::line_descriptor::KeyLine, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_line_descriptor_KeyLine_getEndPoint_const(instance: *const crate::line_descriptor::KeyLine, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_line_descriptor_KeyLine_getStartPointInOctave_const(instance: *const crate::line_descriptor::KeyLine, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_line_descriptor_KeyLine_getEndPointInOctave_const(instance: *const crate::line_descriptor::KeyLine, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_line_descriptor_KeyLine_KeyLine(ocvrs_return: *mut Result<crate::line_descriptor::KeyLine>);
		pub fn cv_line_descriptor_LSDDetector_LSDDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_line_descriptor_LSDDetector_LSDDetector_LSDParam(_params: *const crate::line_descriptor::LSDParam, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_line_descriptor_LSDDetector_createLSDDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_line_descriptor_LSDDetector_createLSDDetector_LSDParam(params: *const crate::line_descriptor::LSDParam, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_line_descriptor_LSDDetector_detect_const_MatR_vectorLKeyLineGR_int_int_const_MatR(instance: *mut c_void, image: *const c_void, keypoints: *mut c_void, scale: i32, num_octaves: i32, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_LSDDetector_detect_const_MatR_vectorLKeyLineGR_int_int(instance: *mut c_void, image: *const c_void, keypoints: *mut c_void, scale: i32, num_octaves: i32, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_LSDDetector_detect_const_const_vectorLMatGR_vectorLvectorLKeyLineGGR_int_int_const_vectorLMatGR(instance: *const c_void, images: *const c_void, keylines: *mut c_void, scale: i32, num_octaves: i32, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_LSDDetector_detect_const_const_vectorLMatGR_vectorLvectorLKeyLineGGR_int_int(instance: *const c_void, images: *const c_void, keylines: *mut c_void, scale: i32, num_octaves: i32, ocvrs_return: *mut Result_void);
		pub fn cv_line_descriptor_LSDDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_line_descriptor_LSDDetector_delete(instance: *mut c_void);
		pub fn cv_line_descriptor_LSDParam_LSDParam(ocvrs_return: *mut Result<crate::line_descriptor::LSDParam>);
		pub fn cv_PtrLcv_line_descriptor_BinaryDescriptorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_line_descriptor_BinaryDescriptorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_line_descriptor_BinaryDescriptorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_line_descriptor_BinaryDescriptorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_line_descriptor_BinaryDescriptorG_new_const_BinaryDescriptor(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_line_descriptor_BinaryDescriptorMatcherG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_line_descriptor_BinaryDescriptorMatcherG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_line_descriptor_BinaryDescriptorMatcherG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_line_descriptor_BinaryDescriptorMatcherG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_line_descriptor_BinaryDescriptorMatcherG_new_const_BinaryDescriptorMatcher(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_line_descriptor_LSDDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_line_descriptor_LSDDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_line_descriptor_LSDDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_line_descriptor_LSDDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_line_descriptor_LSDDetectorG_new_const_LSDDetector(val: *mut c_void) -> *mut c_void;
		pub fn std_vectorLcv_line_descriptor_KeyLineG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_line_descriptor_KeyLineG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_line_descriptor_KeyLineG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_line_descriptor_KeyLineG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_line_descriptor_KeyLineG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_line_descriptor_KeyLineG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_line_descriptor_KeyLineG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_line_descriptor_KeyLineG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_line_descriptor_KeyLineG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_line_descriptor_KeyLineG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_line_descriptor_KeyLineG_push_const_KeyLine(instance: *mut c_void, val: *const crate::line_descriptor::KeyLine);
		pub fn std_vectorLcv_line_descriptor_KeyLineG_insert_size_t_const_KeyLine(instance: *mut c_void, index: size_t, val: *const crate::line_descriptor::KeyLine);
		pub fn std_vectorLcv_line_descriptor_KeyLineG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut crate::line_descriptor::KeyLine);
		pub fn std_vectorLcv_line_descriptor_KeyLineG_set_size_t_const_KeyLine(instance: *mut c_void, index: size_t, val: *const crate::line_descriptor::KeyLine);
		pub fn std_vectorLcv_line_descriptor_KeyLineG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_line_descriptor_KeyLineG_data_const(instance: *const c_void) -> *const crate::line_descriptor::KeyLine;
		pub fn std_vectorLcv_line_descriptor_KeyLineG_dataMut(instance: *mut c_void) -> *mut crate::line_descriptor::KeyLine;
		pub fn cv_fromSlice_const_const_KeyLineX_size_t(data: *const crate::line_descriptor::KeyLine, len: size_t) -> *mut c_void;
		pub fn std_vectorLstd_vectorLcv_line_descriptor_KeyLineGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLcv_line_descriptor_KeyLineGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_line_descriptor_KeyLineGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_line_descriptor_KeyLineGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLcv_line_descriptor_KeyLineGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_line_descriptor_KeyLineGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_line_descriptor_KeyLineGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLcv_line_descriptor_KeyLineGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLcv_line_descriptor_KeyLineGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLcv_line_descriptor_KeyLineGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_line_descriptor_KeyLineGG_push_const_vectorLKeyLineG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_line_descriptor_KeyLineGG_insert_size_t_const_vectorLKeyLineG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_line_descriptor_KeyLineGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLcv_line_descriptor_KeyLineGG_set_size_t_const_vectorLKeyLineG(instance: *mut c_void, index: size_t, val: *const c_void);
	}
}
#[cfg(ocvrs_has_module_line_descriptor)]
pub use line_descriptor_sys::*;

#[cfg(ocvrs_has_module_mcc)]
mod mcc_sys {
	use super::*;

	extern "C" {
		pub fn cv_ccm_ColorCorrectionModel_ColorCorrectionModel_const_MatR_CONST_COLOR(src: *const c_void, constcolor: crate::mcc::CONST_COLOR, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ccm_ColorCorrectionModel_ColorCorrectionModel_const_MatR_Mat_COLOR_SPACE(src: *const c_void, colors: *mut c_void, ref_cs: crate::mcc::COLOR_SPACE, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ccm_ColorCorrectionModel_ColorCorrectionModel_const_MatR_Mat_COLOR_SPACE_Mat(src: *const c_void, colors: *mut c_void, ref_cs: crate::mcc::COLOR_SPACE, colored: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ccm_ColorCorrectionModel_setColorSpace_COLOR_SPACE(instance: *mut c_void, cs: crate::mcc::COLOR_SPACE, ocvrs_return: *mut Result_void);
		pub fn cv_ccm_ColorCorrectionModel_setCCM_TYPE_CCM_TYPE(instance: *mut c_void, ccm_type: crate::mcc::CCM_TYPE, ocvrs_return: *mut Result_void);
		pub fn cv_ccm_ColorCorrectionModel_setDistance_DISTANCE_TYPE(instance: *mut c_void, distance: crate::mcc::DISTANCE_TYPE, ocvrs_return: *mut Result_void);
		pub fn cv_ccm_ColorCorrectionModel_setLinear_LINEAR_TYPE(instance: *mut c_void, linear_type: crate::mcc::LINEAR_TYPE, ocvrs_return: *mut Result_void);
		pub fn cv_ccm_ColorCorrectionModel_setLinearGamma_const_doubleR(instance: *mut c_void, gamma: *const f64, ocvrs_return: *mut Result_void);
		pub fn cv_ccm_ColorCorrectionModel_setLinearDegree_const_intR(instance: *mut c_void, deg: *const i32, ocvrs_return: *mut Result_void);
		pub fn cv_ccm_ColorCorrectionModel_setSaturatedThreshold_const_doubleR_const_doubleR(instance: *mut c_void, lower: *const f64, upper: *const f64, ocvrs_return: *mut Result_void);
		pub fn cv_ccm_ColorCorrectionModel_setWeightsList_const_MatR(instance: *mut c_void, weights_list: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ccm_ColorCorrectionModel_setWeightCoeff_const_doubleR(instance: *mut c_void, weights_coeff: *const f64, ocvrs_return: *mut Result_void);
		pub fn cv_ccm_ColorCorrectionModel_setInitialMethod_INITIAL_METHOD_TYPE(instance: *mut c_void, initial_method_type: crate::mcc::INITIAL_METHOD_TYPE, ocvrs_return: *mut Result_void);
		pub fn cv_ccm_ColorCorrectionModel_setMaxCount_const_intR(instance: *mut c_void, max_count: *const i32, ocvrs_return: *mut Result_void);
		pub fn cv_ccm_ColorCorrectionModel_setEpsilon_const_doubleR(instance: *mut c_void, epsilon: *const f64, ocvrs_return: *mut Result_void);
		pub fn cv_ccm_ColorCorrectionModel_run(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ccm_ColorCorrectionModel_getCCM_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ccm_ColorCorrectionModel_getLoss_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ccm_ColorCorrectionModel_get_src_rgbl_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ccm_ColorCorrectionModel_get_dst_rgbl_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ccm_ColorCorrectionModel_getMask_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ccm_ColorCorrectionModel_getWeights_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ccm_ColorCorrectionModel_infer_const_MatR_bool(instance: *mut c_void, img: *const c_void, islinear: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ccm_ColorCorrectionModel_infer_const_MatR(instance: *mut c_void, img: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ccm_ColorCorrectionModel_delete(instance: *mut c_void);
		pub fn cv_mcc_CChecker_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_mcc_CChecker_setTarget_TYPECHART(instance: *mut c_void, _target: crate::mcc::MCC_TYPECHART, ocvrs_return: *mut Result_void);
		pub fn cv_mcc_CChecker_setBox_vectorLPoint2fG(instance: *mut c_void, _box: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_mcc_CChecker_setChartsRGB_Mat(instance: *mut c_void, _charts_rgb: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_mcc_CChecker_setChartsYCbCr_Mat(instance: *mut c_void, _charts_y_cb_cr: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_mcc_CChecker_setCost_float(instance: *mut c_void, _cost: f32, ocvrs_return: *mut Result_void);
		pub fn cv_mcc_CChecker_setCenter_Point2f(instance: *mut c_void, _center: *const core::Point2f, ocvrs_return: *mut Result_void);
		pub fn cv_mcc_CChecker_getTarget(instance: *mut c_void, ocvrs_return: *mut Result<crate::mcc::MCC_TYPECHART>);
		pub fn cv_mcc_CChecker_getBox(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_mcc_CChecker_getChartsRGB(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_mcc_CChecker_getChartsYCbCr(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_mcc_CChecker_getCost(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_mcc_CChecker_getCenter(instance: *mut c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_mcc_CChecker_delete(instance: *mut c_void);
		pub fn cv_mcc_CCheckerDetector_setNet_Net(instance: *mut c_void, net: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_mcc_CCheckerDetector_process_const__InputArrayR_const_TYPECHART_const_vectorLRectGR_const_int_bool_const_PtrLDetectorParametersGR(instance: *mut c_void, image: *const c_void, chart_type: crate::mcc::MCC_TYPECHART, regions_of_interest: *const c_void, nc: i32, use_net: bool, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_mcc_CCheckerDetector_process_const__InputArrayR_const_TYPECHART_const_vectorLRectGR(instance: *mut c_void, image: *const c_void, chart_type: crate::mcc::MCC_TYPECHART, regions_of_interest: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_mcc_CCheckerDetector_process_const__InputArrayR_const_TYPECHART_const_int_bool_const_PtrLDetectorParametersGR(instance: *mut c_void, image: *const c_void, chart_type: crate::mcc::MCC_TYPECHART, nc: i32, use_net: bool, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_mcc_CCheckerDetector_process_const__InputArrayR_const_TYPECHART(instance: *mut c_void, image: *const c_void, chart_type: crate::mcc::MCC_TYPECHART, ocvrs_return: *mut Result<bool>);
		pub fn cv_mcc_CCheckerDetector_getBestColorChecker(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_mcc_CCheckerDetector_getListColorChecker(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_mcc_CCheckerDetector_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_mcc_CCheckerDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_mcc_CCheckerDetector_delete(instance: *mut c_void);
		pub fn cv_mcc_CCheckerDraw_draw_const__InputOutputArrayR(instance: *mut c_void, img: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_mcc_CCheckerDraw_create_PtrLCCheckerG_Scalar_int(p_checker: *mut c_void, color: *const core::Scalar, thickness: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_mcc_CCheckerDraw_create_PtrLCCheckerG(p_checker: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_mcc_CCheckerDraw_delete(instance: *mut c_void);
		pub fn cv_mcc_DetectorParameters_DetectorParameters(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_mcc_DetectorParameters_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_mcc_DetectorParameters_propAdaptiveThreshWinSizeMin_const(instance: *const c_void) -> i32;
		pub fn cv_mcc_DetectorParameters_propAdaptiveThreshWinSizeMin_int(instance: *mut c_void, val: i32);
		pub fn cv_mcc_DetectorParameters_propAdaptiveThreshWinSizeMax_const(instance: *const c_void) -> i32;
		pub fn cv_mcc_DetectorParameters_propAdaptiveThreshWinSizeMax_int(instance: *mut c_void, val: i32);
		pub fn cv_mcc_DetectorParameters_propAdaptiveThreshWinSizeStep_const(instance: *const c_void) -> i32;
		pub fn cv_mcc_DetectorParameters_propAdaptiveThreshWinSizeStep_int(instance: *mut c_void, val: i32);
		pub fn cv_mcc_DetectorParameters_propAdaptiveThreshConstant_const(instance: *const c_void) -> f64;
		pub fn cv_mcc_DetectorParameters_propAdaptiveThreshConstant_double(instance: *mut c_void, val: f64);
		pub fn cv_mcc_DetectorParameters_propMinContoursAreaRate_const(instance: *const c_void) -> f64;
		pub fn cv_mcc_DetectorParameters_propMinContoursAreaRate_double(instance: *mut c_void, val: f64);
		pub fn cv_mcc_DetectorParameters_propMinContoursArea_const(instance: *const c_void) -> f64;
		pub fn cv_mcc_DetectorParameters_propMinContoursArea_double(instance: *mut c_void, val: f64);
		pub fn cv_mcc_DetectorParameters_propConfidenceThreshold_const(instance: *const c_void) -> f64;
		pub fn cv_mcc_DetectorParameters_propConfidenceThreshold_double(instance: *mut c_void, val: f64);
		pub fn cv_mcc_DetectorParameters_propMinContourSolidity_const(instance: *const c_void) -> f64;
		pub fn cv_mcc_DetectorParameters_propMinContourSolidity_double(instance: *mut c_void, val: f64);
		pub fn cv_mcc_DetectorParameters_propFindCandidatesApproxPolyDPEpsMultiplier_const(instance: *const c_void) -> f64;
		pub fn cv_mcc_DetectorParameters_propFindCandidatesApproxPolyDPEpsMultiplier_double(instance: *mut c_void, val: f64);
		pub fn cv_mcc_DetectorParameters_propBorderWidth_const(instance: *const c_void) -> i32;
		pub fn cv_mcc_DetectorParameters_propBorderWidth_int(instance: *mut c_void, val: i32);
		pub fn cv_mcc_DetectorParameters_propB0factor_const(instance: *const c_void) -> f32;
		pub fn cv_mcc_DetectorParameters_propB0factor_float(instance: *mut c_void, val: f32);
		pub fn cv_mcc_DetectorParameters_propMaxError_const(instance: *const c_void) -> f32;
		pub fn cv_mcc_DetectorParameters_propMaxError_float(instance: *mut c_void, val: f32);
		pub fn cv_mcc_DetectorParameters_propMinContourPointsAllowed_const(instance: *const c_void) -> i32;
		pub fn cv_mcc_DetectorParameters_propMinContourPointsAllowed_int(instance: *mut c_void, val: i32);
		pub fn cv_mcc_DetectorParameters_propMinContourLengthAllowed_const(instance: *const c_void) -> i32;
		pub fn cv_mcc_DetectorParameters_propMinContourLengthAllowed_int(instance: *mut c_void, val: i32);
		pub fn cv_mcc_DetectorParameters_propMinInterContourDistance_const(instance: *const c_void) -> i32;
		pub fn cv_mcc_DetectorParameters_propMinInterContourDistance_int(instance: *mut c_void, val: i32);
		pub fn cv_mcc_DetectorParameters_propMinInterCheckerDistance_const(instance: *const c_void) -> i32;
		pub fn cv_mcc_DetectorParameters_propMinInterCheckerDistance_int(instance: *mut c_void, val: i32);
		pub fn cv_mcc_DetectorParameters_propMinImageSize_const(instance: *const c_void) -> i32;
		pub fn cv_mcc_DetectorParameters_propMinImageSize_int(instance: *mut c_void, val: i32);
		pub fn cv_mcc_DetectorParameters_propMinGroupSize_const(instance: *const c_void) -> u32;
		pub fn cv_mcc_DetectorParameters_propMinGroupSize_unsigned_int(instance: *mut c_void, val: u32);
		pub fn cv_mcc_DetectorParameters_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_mcc_CCheckerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_mcc_CCheckerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_mcc_CCheckerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_mcc_CCheckerDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_mcc_CCheckerDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_mcc_CCheckerDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_mcc_CCheckerDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_mcc_CCheckerDrawG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_mcc_CCheckerDrawG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_mcc_CCheckerDrawG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_mcc_DetectorParametersG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_mcc_DetectorParametersG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_mcc_DetectorParametersG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_mcc_DetectorParametersG_new_const_DetectorParameters(val: *mut c_void) -> *mut c_void;
		pub fn std_vectorLcv_PtrLcv_mcc_CCheckerGG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_PtrLcv_mcc_CCheckerGG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_PtrLcv_mcc_CCheckerGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_PtrLcv_mcc_CCheckerGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_PtrLcv_mcc_CCheckerGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_PtrLcv_mcc_CCheckerGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_PtrLcv_mcc_CCheckerGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_PtrLcv_mcc_CCheckerGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_PtrLcv_mcc_CCheckerGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_PtrLcv_mcc_CCheckerGG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_PtrLcv_mcc_CCheckerGG_push_const_PtrLCCheckerG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_PtrLcv_mcc_CCheckerGG_insert_size_t_const_PtrLCCheckerG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_PtrLcv_mcc_CCheckerGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_PtrLcv_mcc_CCheckerGG_set_size_t_const_PtrLCCheckerG(instance: *mut c_void, index: size_t, val: *const c_void);
	}
}
#[cfg(ocvrs_has_module_mcc)]
pub use mcc_sys::*;

#[cfg(ocvrs_has_module_ml)]
mod ml_sys {
	use super::*;

	extern "C" {
		pub fn cv_ml_createConcentricSpheresTestSet_int_int_int_const__OutputArrayR_const__OutputArrayR(nsamples: i32, nfeatures: i32, nclasses: i32, samples: *const c_void, responses: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_randMVNormal_const__InputArrayR_const__InputArrayR_int_const__OutputArrayR(mean: *const c_void, cov: *const c_void, nsamples: i32, samples: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_setTrainMethod_int_double_double(instance: *mut c_void, method: i32, param1: f64, param2: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_setTrainMethod_int(instance: *mut c_void, method: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getTrainMethod_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_ANN_MLP_setActivationFunction_int_double_double(instance: *mut c_void, typ: i32, param1: f64, param2: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_setActivationFunction_int(instance: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_setLayerSizes_const__InputArrayR(instance: *mut c_void, _layer_sizes: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getLayerSizes_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_ANN_MLP_getTermCriteria_const(instance: *const c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_ml_ANN_MLP_setTermCriteria_TermCriteria(instance: *mut c_void, val: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getBackpropWeightScale_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setBackpropWeightScale_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getBackpropMomentumScale_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setBackpropMomentumScale_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getRpropDW0_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setRpropDW0_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getRpropDWPlus_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setRpropDWPlus_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getRpropDWMinus_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setRpropDWMinus_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getRpropDWMin_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setRpropDWMin_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getRpropDWMax_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setRpropDWMax_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getAnnealInitialT_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setAnnealInitialT_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getAnnealFinalT_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setAnnealFinalT_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getAnnealCoolingRatio_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_ANN_MLP_setAnnealCoolingRatio_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getAnnealItePerStep_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_ANN_MLP_setAnnealItePerStep_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_setAnnealEnergyRNG_const_RNGR(instance: *mut c_void, rng: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_ANN_MLP_getWeights_const_int(instance: *const c_void, layer_idx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_ANN_MLP_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_ANN_MLP_load_const_StringR(filepath: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_ANN_MLP_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_ANN_MLP_to_StatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_ANN_MLP_delete(instance: *mut c_void);
		pub fn cv_ml_Boost_getBoostType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_Boost_setBoostType_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_Boost_getWeakCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_Boost_setWeakCount_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_Boost_getWeightTrimRate_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_Boost_setWeightTrimRate_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_Boost_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_Boost_load_const_StringR_const_StringR(filepath: *const c_char, node_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_Boost_load_const_StringR(filepath: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_Boost_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_Boost_to_DTrees(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_Boost_to_StatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_Boost_delete(instance: *mut c_void);
		pub fn cv_ml_DTrees_getMaxCategories_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_DTrees_setMaxCategories_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_DTrees_getMaxDepth_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_DTrees_setMaxDepth_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_DTrees_getMinSampleCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_DTrees_setMinSampleCount_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_DTrees_getCVFolds_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_DTrees_setCVFolds_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_DTrees_getUseSurrogates_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_DTrees_setUseSurrogates_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ml_DTrees_getUse1SERule_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_DTrees_setUse1SERule_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ml_DTrees_getTruncatePrunedTree_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_DTrees_setTruncatePrunedTree_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ml_DTrees_getRegressionAccuracy_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_DTrees_setRegressionAccuracy_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_DTrees_getPriors_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_setPriors_const_MatR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_DTrees_getRoots_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_getNodes_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_getSplits_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_getSubsets_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_load_const_StringR_const_StringR(filepath: *const c_char, node_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_load_const_StringR(filepath: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_to_Boost(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_DTrees_to_RTrees(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_DTrees_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_DTrees_to_StatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_DTrees_delete(instance: *mut c_void);
		pub fn cv_ml_DTrees_Node_Node(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_Node_propValue_const(instance: *const c_void) -> f64;
		pub fn cv_ml_DTrees_Node_propValue_double(instance: *mut c_void, val: f64);
		pub fn cv_ml_DTrees_Node_propClassIdx_const(instance: *const c_void) -> i32;
		pub fn cv_ml_DTrees_Node_propClassIdx_int(instance: *mut c_void, val: i32);
		pub fn cv_ml_DTrees_Node_propParent_const(instance: *const c_void) -> i32;
		pub fn cv_ml_DTrees_Node_propParent_int(instance: *mut c_void, val: i32);
		pub fn cv_ml_DTrees_Node_propLeft_const(instance: *const c_void) -> i32;
		pub fn cv_ml_DTrees_Node_propLeft_int(instance: *mut c_void, val: i32);
		pub fn cv_ml_DTrees_Node_propRight_const(instance: *const c_void) -> i32;
		pub fn cv_ml_DTrees_Node_propRight_int(instance: *mut c_void, val: i32);
		pub fn cv_ml_DTrees_Node_propDefaultDir_const(instance: *const c_void) -> i32;
		pub fn cv_ml_DTrees_Node_propDefaultDir_int(instance: *mut c_void, val: i32);
		pub fn cv_ml_DTrees_Node_propSplit_const(instance: *const c_void) -> i32;
		pub fn cv_ml_DTrees_Node_propSplit_int(instance: *mut c_void, val: i32);
		pub fn cv_ml_DTrees_Node_delete(instance: *mut c_void);
		pub fn cv_ml_DTrees_Split_Split(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_DTrees_Split_propVarIdx_const(instance: *const c_void) -> i32;
		pub fn cv_ml_DTrees_Split_propVarIdx_int(instance: *mut c_void, val: i32);
		pub fn cv_ml_DTrees_Split_propInversed_const(instance: *const c_void) -> bool;
		pub fn cv_ml_DTrees_Split_propInversed_bool(instance: *mut c_void, val: bool);
		pub fn cv_ml_DTrees_Split_propQuality_const(instance: *const c_void) -> f32;
		pub fn cv_ml_DTrees_Split_propQuality_float(instance: *mut c_void, val: f32);
		pub fn cv_ml_DTrees_Split_propNext_const(instance: *const c_void) -> i32;
		pub fn cv_ml_DTrees_Split_propNext_int(instance: *mut c_void, val: i32);
		pub fn cv_ml_DTrees_Split_propC_const(instance: *const c_void) -> f32;
		pub fn cv_ml_DTrees_Split_propC_float(instance: *mut c_void, val: f32);
		pub fn cv_ml_DTrees_Split_propSubsetOfs_const(instance: *const c_void) -> i32;
		pub fn cv_ml_DTrees_Split_propSubsetOfs_int(instance: *mut c_void, val: i32);
		pub fn cv_ml_DTrees_Split_delete(instance: *mut c_void);
		pub fn cv_ml_EM_getClustersNumber_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_EM_setClustersNumber_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_EM_getCovarianceMatrixType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_EM_setCovarianceMatrixType_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_EM_getTermCriteria_const(instance: *const c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_ml_EM_setTermCriteria_const_TermCriteriaR(instance: *mut c_void, val: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_ml_EM_getWeights_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_EM_getMeans_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_EM_getCovs_const_vectorLMatGR(instance: *const c_void, covs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_EM_predict_const_const__InputArrayR_const__OutputArrayR_int(instance: *const c_void, samples: *const c_void, results: *const c_void, flags: i32, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_EM_predict_const_const__InputArrayR(instance: *const c_void, samples: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_EM_predict2_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, sample: *const c_void, probs: *const c_void, ocvrs_return: *mut Result<core::Vec2d>);
		pub fn cv_ml_EM_trainEM_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, samples: *const c_void, log_likelihoods: *const c_void, labels: *const c_void, probs: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_EM_trainEM_const__InputArrayR(instance: *mut c_void, samples: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_EM_trainE_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, samples: *const c_void, means0: *const c_void, covs0: *const c_void, weights0: *const c_void, log_likelihoods: *const c_void, labels: *const c_void, probs: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_EM_trainE_const__InputArrayR_const__InputArrayR(instance: *mut c_void, samples: *const c_void, means0: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_EM_trainM_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, samples: *const c_void, probs0: *const c_void, log_likelihoods: *const c_void, labels: *const c_void, probs: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_EM_trainM_const__InputArrayR_const__InputArrayR(instance: *mut c_void, samples: *const c_void, probs0: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_EM_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_EM_load_const_StringR_const_StringR(filepath: *const c_char, node_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_EM_load_const_StringR(filepath: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_EM_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_EM_to_StatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_EM_delete(instance: *mut c_void);
		pub fn cv_ml_KNearest_getDefaultK_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_KNearest_setDefaultK_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_KNearest_getIsClassifier_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_KNearest_setIsClassifier_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ml_KNearest_getEmax_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_KNearest_setEmax_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_KNearest_getAlgorithmType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_KNearest_setAlgorithmType_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_KNearest_findNearest_const_const__InputArrayR_int_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, samples: *const c_void, k: i32, results: *const c_void, neighbor_responses: *const c_void, dist: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_KNearest_findNearest_const_const__InputArrayR_int_const__OutputArrayR(instance: *const c_void, samples: *const c_void, k: i32, results: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_KNearest_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_KNearest_load_const_StringR(filepath: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_KNearest_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_KNearest_to_StatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_KNearest_delete(instance: *mut c_void);
		pub fn cv_ml_LogisticRegression_getLearningRate_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_LogisticRegression_setLearningRate_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_LogisticRegression_getIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_LogisticRegression_setIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_LogisticRegression_getRegularization_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_LogisticRegression_setRegularization_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_LogisticRegression_getTrainMethod_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_LogisticRegression_setTrainMethod_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_LogisticRegression_getMiniBatchSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_LogisticRegression_setMiniBatchSize_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_LogisticRegression_getTermCriteria_const(instance: *const c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_ml_LogisticRegression_setTermCriteria_TermCriteria(instance: *mut c_void, val: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_ml_LogisticRegression_predict_const_const__InputArrayR_const__OutputArrayR_int(instance: *const c_void, samples: *const c_void, results: *const c_void, flags: i32, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_LogisticRegression_predict_const_const__InputArrayR(instance: *const c_void, samples: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_LogisticRegression_get_learnt_thetas_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_LogisticRegression_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_LogisticRegression_load_const_StringR_const_StringR(filepath: *const c_char, node_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_LogisticRegression_load_const_StringR(filepath: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_LogisticRegression_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_LogisticRegression_to_StatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_LogisticRegression_delete(instance: *mut c_void);
		pub fn cv_ml_NormalBayesClassifier_predictProb_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int(instance: *const c_void, inputs: *const c_void, outputs: *const c_void, output_probs: *const c_void, flags: i32, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_NormalBayesClassifier_predictProb_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, inputs: *const c_void, outputs: *const c_void, output_probs: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_NormalBayesClassifier_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_NormalBayesClassifier_load_const_StringR_const_StringR(filepath: *const c_char, node_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_NormalBayesClassifier_load_const_StringR(filepath: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_NormalBayesClassifier_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_NormalBayesClassifier_to_StatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_NormalBayesClassifier_delete(instance: *mut c_void);
		pub fn cv_ml_ParamGrid_ParamGrid(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_ParamGrid_ParamGrid_double_double_double(_min_val: f64, _max_val: f64, _log_step: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_ParamGrid_create_double_double_double(min_val: f64, max_val: f64, logstep: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_ParamGrid_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_ParamGrid_propMinVal_const(instance: *const c_void) -> f64;
		pub fn cv_ml_ParamGrid_propMinVal_double(instance: *mut c_void, val: f64);
		pub fn cv_ml_ParamGrid_propMaxVal_const(instance: *const c_void) -> f64;
		pub fn cv_ml_ParamGrid_propMaxVal_double(instance: *mut c_void, val: f64);
		pub fn cv_ml_ParamGrid_propLogStep_const(instance: *const c_void) -> f64;
		pub fn cv_ml_ParamGrid_propLogStep_double(instance: *mut c_void, val: f64);
		pub fn cv_ml_ParamGrid_delete(instance: *mut c_void);
		pub fn cv_ml_RTrees_getCalculateVarImportance_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_RTrees_setCalculateVarImportance_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ml_RTrees_getActiveVarCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_RTrees_setActiveVarCount_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_RTrees_getTermCriteria_const(instance: *const c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_ml_RTrees_setTermCriteria_const_TermCriteriaR(instance: *mut c_void, val: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_ml_RTrees_getVarImportance_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_RTrees_getVotes_const_const__InputArrayR_const__OutputArrayR_int(instance: *const c_void, samples: *const c_void, results: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_RTrees_getOOBError_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_RTrees_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_RTrees_load_const_StringR_const_StringR(filepath: *const c_char, node_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_RTrees_load_const_StringR(filepath: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_RTrees_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_RTrees_to_DTrees(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_RTrees_to_StatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_RTrees_delete(instance: *mut c_void);
		pub fn cv_ml_SVM_getType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_SVM_setType_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_getGamma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_SVM_setGamma_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_getCoef0_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_SVM_setCoef0_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_getDegree_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_SVM_setDegree_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_getC_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_SVM_setC_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_getNu_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_SVM_setNu_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_getP_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_SVM_setP_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_getClassWeights_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVM_setClassWeights_const_MatR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_getTermCriteria_const(instance: *const c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_ml_SVM_setTermCriteria_const_TermCriteriaR(instance: *mut c_void, val: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_getKernelType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_SVM_setKernel_int(instance: *mut c_void, kernel_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_setCustomKernel_const_PtrLKernelGR(instance: *mut c_void, _kernel: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_trainAuto_const_PtrLTrainDataGR_int_ParamGrid_ParamGrid_ParamGrid_ParamGrid_ParamGrid_ParamGrid_bool(instance: *mut c_void, data: *const c_void, k_fold: i32, cgrid: *mut c_void, gamma_grid: *mut c_void, p_grid: *mut c_void, nu_grid: *mut c_void, coeff_grid: *mut c_void, degree_grid: *mut c_void, balanced: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_SVM_trainAuto_const_PtrLTrainDataGR(instance: *mut c_void, data: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_SVM_trainAuto_const__InputArrayR_int_const__InputArrayR_int_PtrLParamGridG_PtrLParamGridG_PtrLParamGridG_PtrLParamGridG_PtrLParamGridG_PtrLParamGridG_bool(instance: *mut c_void, samples: *const c_void, layout: i32, responses: *const c_void, k_fold: i32, cgrid: *mut c_void, gamma_grid: *mut c_void, p_grid: *mut c_void, nu_grid: *mut c_void, coeff_grid: *mut c_void, degree_grid: *mut c_void, balanced: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_SVM_trainAuto_const__InputArrayR_int_const__InputArrayR(instance: *mut c_void, samples: *const c_void, layout: i32, responses: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_SVM_getSupportVectors_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVM_getUncompressedSupportVectors_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVM_getDecisionFunction_const_int_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, i: i32, alpha: *const c_void, svidx: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ml_SVM_getDefaultGrid_int(param_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVM_getDefaultGridPtr_int(param_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVM_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVM_load_const_StringR(filepath: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVM_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_SVM_to_StatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_SVM_delete(instance: *mut c_void);
		pub fn cv_ml_SVM_Kernel_getType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_SVM_Kernel_calc_int_int_const_floatX_const_floatX_floatX(instance: *mut c_void, vcount: i32, n: i32, vecs: *const f32, another: *const f32, results: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVM_Kernel_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_SVM_Kernel_delete(instance: *mut c_void);
		pub fn cv_ml_SVMSGD_getWeights(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVMSGD_getShift(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_SVMSGD_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVMSGD_load_const_StringR_const_StringR(filepath: *const c_char, node_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVMSGD_load_const_StringR(filepath: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_SVMSGD_setOptimalParameters_int_int(instance: *mut c_void, svmsgd_type: i32, margin_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVMSGD_setOptimalParameters(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVMSGD_getSvmsgdType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_SVMSGD_setSvmsgdType_int(instance: *mut c_void, svmsgd_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVMSGD_getMarginType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_SVMSGD_setMarginType_int(instance: *mut c_void, margin_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVMSGD_getMarginRegularization_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_SVMSGD_setMarginRegularization_float(instance: *mut c_void, margin_regularization: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVMSGD_getInitialStepSize_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_SVMSGD_setInitialStepSize_float(instance: *mut c_void, initial_step_size: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVMSGD_getStepDecreasingPower_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_SVMSGD_setStepDecreasingPower_float(instance: *mut c_void, step_decreasing_power: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVMSGD_getTermCriteria_const(instance: *const c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_ml_SVMSGD_setTermCriteria_const_TermCriteriaR(instance: *mut c_void, val: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_ml_SVMSGD_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_SVMSGD_to_StatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_SVMSGD_delete(instance: *mut c_void);
		pub fn cv_ml_StatModel_getVarCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_StatModel_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_StatModel_isTrained_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_StatModel_isClassifier_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_StatModel_train_const_PtrLTrainDataGR_int(instance: *mut c_void, train_data: *const c_void, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_StatModel_train_const_PtrLTrainDataGR(instance: *mut c_void, train_data: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_StatModel_train_const__InputArrayR_int_const__InputArrayR(instance: *mut c_void, samples: *const c_void, layout: i32, responses: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ml_StatModel_calcError_const_const_PtrLTrainDataGR_bool_const__OutputArrayR(instance: *const c_void, data: *const c_void, test: bool, resp: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_StatModel_predict_const_const__InputArrayR_const__OutputArrayR_int(instance: *const c_void, samples: *const c_void, results: *const c_void, flags: i32, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_StatModel_predict_const_const__InputArrayR(instance: *const c_void, samples: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_StatModel_to_ANN_MLP(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_StatModel_to_Boost(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_StatModel_to_DTrees(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_StatModel_to_EM(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_StatModel_to_KNearest(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_StatModel_to_LogisticRegression(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_StatModel_to_NormalBayesClassifier(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_StatModel_to_RTrees(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_StatModel_to_SVM(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_StatModel_to_SVMSGD(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_StatModel_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ml_StatModel_delete(instance: *mut c_void);
		pub fn cv_ml_TrainData_missingValue(ocvrs_return: *mut Result<f32>);
		pub fn cv_ml_TrainData_getLayout_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_TrainData_getNTrainSamples_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_TrainData_getNTestSamples_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_TrainData_getNSamples_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_TrainData_getNVars_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_TrainData_getNAllVars_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_TrainData_getSample_const_const__InputArrayR_int_floatX(instance: *const c_void, var_idx: *const c_void, sidx: i32, buf: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_TrainData_getSamples_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getMissing_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getTrainSamples_const_int_bool_bool(instance: *const c_void, layout: i32, compress_samples: bool, compress_vars: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getTrainSamples_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getTrainResponses_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getTrainNormCatResponses_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getTestResponses_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getTestNormCatResponses_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getResponses_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getNormCatResponses_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getSampleWeights_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getTrainSampleWeights_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getTestSampleWeights_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getVarIdx_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getVarType_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getVarSymbolFlags_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getResponseType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_TrainData_getTrainSampleIdx_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getTestSampleIdx_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getValues_const_int_const__InputArrayR_floatX(instance: *const c_void, vi: i32, sidx: *const c_void, values: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_TrainData_getNormCatValues_const_int_const__InputArrayR_intX(instance: *const c_void, vi: i32, sidx: *const c_void, values: *mut i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_TrainData_getDefaultSubstValues_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getCatCount_const_int(instance: *const c_void, vi: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_ml_TrainData_getClassLabels_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getCatOfs_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getCatMap_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_setTrainTestSplit_int_bool(instance: *mut c_void, count: i32, shuffle: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ml_TrainData_setTrainTestSplit_int(instance: *mut c_void, count: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ml_TrainData_setTrainTestSplitRatio_double_bool(instance: *mut c_void, ratio: f64, shuffle: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ml_TrainData_setTrainTestSplitRatio_double(instance: *mut c_void, ratio: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ml_TrainData_shuffleTrainTest(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_TrainData_getTestSamples_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getNames_const_vectorLStringGR(instance: *const c_void, names: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ml_TrainData_getSubVector_const_MatR_const_MatR(vec: *const c_void, idx: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_getSubMatrix_const_MatR_const_MatR_int(matrix: *const c_void, idx: *const c_void, layout: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_loadFromCSV_const_StringR_int_int_int_const_StringR_char_char(filename: *const c_char, header_line_count: i32, response_start_idx: i32, response_end_idx: i32, var_type_spec: *const c_char, delimiter: c_char, missch: c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_loadFromCSV_const_StringR_int(filename: *const c_char, header_line_count: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_create_const__InputArrayR_int_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(samples: *const c_void, layout: i32, responses: *const c_void, var_idx: *const c_void, sample_idx: *const c_void, sample_weights: *const c_void, var_type: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_create_const__InputArrayR_int_const__InputArrayR(samples: *const c_void, layout: i32, responses: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ml_TrainData_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ml_ANN_MLPG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_ANN_MLPG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_ANN_MLPG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ml_ANN_MLPG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_ANN_MLPG_to_PtrOfStatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_BoostG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_BoostG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_BoostG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ml_BoostG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_BoostG_to_PtrOfDTrees(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_BoostG_to_PtrOfStatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_DTreesG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_DTreesG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_DTreesG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ml_DTreesG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_DTreesG_to_PtrOfStatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_EMG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_EMG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_EMG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ml_EMG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_EMG_to_PtrOfStatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_KNearestG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_KNearestG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_KNearestG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ml_KNearestG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_KNearestG_to_PtrOfStatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_LogisticRegressionG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_LogisticRegressionG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_LogisticRegressionG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ml_LogisticRegressionG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_LogisticRegressionG_to_PtrOfStatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_NormalBayesClassifierG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_NormalBayesClassifierG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_NormalBayesClassifierG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ml_NormalBayesClassifierG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_NormalBayesClassifierG_to_PtrOfStatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_ParamGridG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_ParamGridG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_ParamGridG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ml_ParamGridG_new_const_ParamGrid(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_RTreesG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_RTreesG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_RTreesG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ml_RTreesG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_RTreesG_to_PtrOfDTrees(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_RTreesG_to_PtrOfStatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_SVMG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_SVMG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_SVMG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ml_SVMG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_SVMG_to_PtrOfStatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_SVMSGDG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_SVMSGDG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_SVMSGDG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ml_SVMSGDG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_SVMSGDG_to_PtrOfStatModel(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_SVM_KernelG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_SVM_KernelG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_SVM_KernelG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ml_SVM_KernelG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_StatModelG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_StatModelG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_StatModelG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ml_StatModelG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_TrainDataG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_TrainDataG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ml_TrainDataG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_ml_DTrees_NodeG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_ml_DTrees_NodeG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_ml_DTrees_NodeG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_ml_DTrees_NodeG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_ml_DTrees_NodeG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_ml_DTrees_NodeG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_ml_DTrees_NodeG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_ml_DTrees_NodeG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_ml_DTrees_NodeG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_ml_DTrees_NodeG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_ml_DTrees_NodeG_push_const_Node(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_ml_DTrees_NodeG_insert_size_t_const_Node(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_ml_DTrees_NodeG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_ml_DTrees_NodeG_set_size_t_const_Node(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_ml_DTrees_SplitG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_ml_DTrees_SplitG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_ml_DTrees_SplitG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_ml_DTrees_SplitG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_ml_DTrees_SplitG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_ml_DTrees_SplitG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_ml_DTrees_SplitG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_ml_DTrees_SplitG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_ml_DTrees_SplitG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_ml_DTrees_SplitG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_ml_DTrees_SplitG_push_const_Split(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_ml_DTrees_SplitG_insert_size_t_const_Split(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_ml_DTrees_SplitG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_ml_DTrees_SplitG_set_size_t_const_Split(instance: *mut c_void, index: size_t, val: *const c_void);
	}
}
#[cfg(ocvrs_has_module_ml)]
pub use ml_sys::*;

#[cfg(ocvrs_has_module_objdetect)]
mod objdetect_sys {
	use super::*;

	extern "C" {
		pub fn cv_aruco_drawDetectedCornersCharuco_const__InputOutputArrayR_const__InputArrayR(image: *const c_void, charuco_corners: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_drawDetectedCornersCharuco_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR_Scalar(image: *const c_void, charuco_corners: *const c_void, charuco_ids: *const c_void, corner_color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_drawDetectedDiamonds_const__InputOutputArrayR_const__InputArrayR(image: *const c_void, diamond_corners: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_drawDetectedDiamonds_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR_Scalar(image: *const c_void, diamond_corners: *const c_void, diamond_ids: *const c_void, border_color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_drawDetectedMarkers_const__InputOutputArrayR_const__InputArrayR(image: *const c_void, corners: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_drawDetectedMarkers_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR_Scalar(image: *const c_void, corners: *const c_void, ids: *const c_void, border_color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_extendDictionary_int_int(n_markers: i32, marker_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_extendDictionary_int_int_const_DictionaryR_int(n_markers: i32, marker_size: i32, base_dictionary: *const c_void, random_seed: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_generateImageMarker_const_DictionaryR_int_int_const__OutputArrayR(dictionary: *const c_void, id: i32, side_pixels: i32, img: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_generateImageMarker_const_DictionaryR_int_int_const__OutputArrayR_int(dictionary: *const c_void, id: i32, side_pixels: i32, img: *const c_void, border_bits: i32, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_getPredefinedDictionary_PredefinedDictionaryType(name: crate::objdetect::PredefinedDictionaryType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_getPredefinedDictionary_int(dict: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createFaceDetectionMaskGenerator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_groupRectangles_meanshift_vectorLRectGR_vectorLdoubleGR_vectorLdoubleGR(rect_list: *mut c_void, found_weights: *mut c_void, found_scales: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_groupRectangles_meanshift_vectorLRectGR_vectorLdoubleGR_vectorLdoubleGR_double_Size(rect_list: *mut c_void, found_weights: *mut c_void, found_scales: *mut c_void, detect_threshold: f64, win_det_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_groupRectangles_vectorLRectGR_int(rect_list: *mut c_void, group_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_groupRectangles_vectorLRectGR_int_double(rect_list: *mut c_void, group_threshold: i32, eps: f64, ocvrs_return: *mut Result_void);
		pub fn cv_groupRectangles_vectorLRectGR_int_double_vectorLintGX_vectorLdoubleGX(rect_list: *mut c_void, group_threshold: i32, eps: f64, weights: *mut c_void, level_weights: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_groupRectangles_vectorLRectGR_vectorLintGR_int(rect_list: *mut c_void, weights: *mut c_void, group_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_groupRectangles_vectorLRectGR_vectorLintGR_int_double(rect_list: *mut c_void, weights: *mut c_void, group_threshold: i32, eps: f64, ocvrs_return: *mut Result_void);
		pub fn cv_groupRectangles_vectorLRectGR_vectorLintGR_vectorLdoubleGR_int(rect_list: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, group_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_groupRectangles_vectorLRectGR_vectorLintGR_vectorLdoubleGR_int_double(rect_list: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, group_threshold: i32, eps: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BaseCascadeClassifier_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_BaseCascadeClassifier_load_const_StringR(instance: *mut c_void, filename: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_BaseCascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_double_int_int_Size_Size(instance: *mut c_void, image: *const c_void, objects: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_BaseCascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_vectorLintGR_double_int_int_Size_Size(instance: *mut c_void, image: *const c_void, objects: *mut c_void, num_detections: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_BaseCascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_vectorLintGR_vectorLdoubleGR_double_int_int_Size_Size_bool(instance: *mut c_void, image: *const c_void, objects: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, output_reject_levels: bool, ocvrs_return: *mut Result_void);
		pub fn cv_BaseCascadeClassifier_isOldFormatCascade_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_BaseCascadeClassifier_getOriginalWindowSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_BaseCascadeClassifier_getFeatureType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BaseCascadeClassifier_getOldCascade(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BaseCascadeClassifier_setMaskGenerator_const_PtrLMaskGeneratorGR(instance: *mut c_void, mask_generator: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BaseCascadeClassifier_getMaskGenerator(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BaseCascadeClassifier_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_BaseCascadeClassifier_delete(instance: *mut c_void);
		pub fn cv_BaseCascadeClassifier_MaskGenerator_generateMask_const_MatR(instance: *mut c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BaseCascadeClassifier_MaskGenerator_initializeMask_const_MatR(instance: *mut c_void, unnamed: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BaseCascadeClassifier_MaskGenerator_delete(instance: *mut c_void);
		pub fn cv_CascadeClassifier_CascadeClassifier(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CascadeClassifier_CascadeClassifier_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CascadeClassifier_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_CascadeClassifier_load_const_StringR(instance: *mut c_void, filename: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_CascadeClassifier_read_const_FileNodeR(instance: *mut c_void, node: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_CascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_double_int_int_Size_Size(instance: *mut c_void, image: *const c_void, objects: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_CascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR(instance: *mut c_void, image: *const c_void, objects: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_CascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_vectorLintGR_double_int_int_Size_Size(instance: *mut c_void, image: *const c_void, objects: *mut c_void, num_detections: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_CascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_vectorLintGR(instance: *mut c_void, image: *const c_void, objects: *mut c_void, num_detections: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_CascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_vectorLintGR_vectorLdoubleGR_double_int_int_Size_Size_bool(instance: *mut c_void, image: *const c_void, objects: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, output_reject_levels: bool, ocvrs_return: *mut Result_void);
		pub fn cv_CascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_vectorLintGR_vectorLdoubleGR(instance: *mut c_void, image: *const c_void, objects: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_CascadeClassifier_isOldFormatCascade_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_CascadeClassifier_getOriginalWindowSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_CascadeClassifier_getFeatureType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_CascadeClassifier_getOldCascade(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CascadeClassifier_convert_const_StringR_const_StringR(oldcascade: *const c_char, newcascade: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_CascadeClassifier_setMaskGenerator_const_PtrLMaskGeneratorGR(instance: *mut c_void, mask_generator: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_CascadeClassifier_getMaskGenerator(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CascadeClassifier_propCc(instance: *mut c_void) -> *mut c_void;
		pub fn cv_CascadeClassifier_propCc_PtrLBaseCascadeClassifierG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_CascadeClassifier_delete(instance: *mut c_void);
		pub fn cv_DetectionBasedTracker_DetectionBasedTracker_PtrLIDetectorG_PtrLIDetectorG_const_ParametersR(main_detector: *mut c_void, tracking_detector: *mut c_void, params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DetectionBasedTracker_run(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_DetectionBasedTracker_stop(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_resetTracking(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_process_const_MatR(instance: *mut c_void, image_gray: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_setParameters_const_ParametersR(instance: *mut c_void, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_DetectionBasedTracker_getParameters_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DetectionBasedTracker_getObjects_const_vectorLRectGR(instance: *const c_void, result: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_getObjects_const_vectorLObjectGR(instance: *const c_void, result: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_getObjects_const_vectorLExtObjectGR(instance: *const c_void, result: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_addObject_const_RectR(instance: *mut c_void, location: *const core::Rect, ocvrs_return: *mut Result<i32>);
		pub fn cv_DetectionBasedTracker_delete(instance: *mut c_void);
		pub fn cv_DetectionBasedTracker_ExtObject_ExtObject_int_Rect_ObjectStatus(_id: i32, _location: *const core::Rect, _status: crate::objdetect::DetectionBasedTracker_ObjectStatus, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DetectionBasedTracker_ExtObject_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_DetectionBasedTracker_ExtObject_propId_const(instance: *const c_void) -> i32;
		pub fn cv_DetectionBasedTracker_ExtObject_propId_int(instance: *mut c_void, val: i32);
		pub fn cv_DetectionBasedTracker_ExtObject_propLocation_const(instance: *const c_void, ocvrs_return: *mut core::Rect);
		pub fn cv_DetectionBasedTracker_ExtObject_propLocation_Rect(instance: *mut c_void, val: *const core::Rect);
		pub fn cv_DetectionBasedTracker_ExtObject_propStatus_const(instance: *const c_void, ocvrs_return: *mut crate::objdetect::DetectionBasedTracker_ObjectStatus);
		pub fn cv_DetectionBasedTracker_ExtObject_propStatus_ObjectStatus(instance: *mut c_void, val: crate::objdetect::DetectionBasedTracker_ObjectStatus);
		pub fn cv_DetectionBasedTracker_ExtObject_delete(instance: *mut c_void);
		pub fn cv_DetectionBasedTracker_IDetector_detect_const_MatR_vectorLRectGR(instance: *mut c_void, image: *const c_void, objects: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_IDetector_setMinObjectSize_const_SizeR(instance: *mut c_void, min: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_IDetector_setMaxObjectSize_const_SizeR(instance: *mut c_void, max: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_IDetector_getMinObjectSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_DetectionBasedTracker_IDetector_getMaxObjectSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_DetectionBasedTracker_IDetector_getScaleFactor(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_DetectionBasedTracker_IDetector_setScaleFactor_float(instance: *mut c_void, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_IDetector_getMinNeighbours(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_DetectionBasedTracker_IDetector_setMinNeighbours_int(instance: *mut c_void, value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_DetectionBasedTracker_IDetector_delete(instance: *mut c_void);
		pub fn cv_DetectionBasedTracker_Parameters_Parameters(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DetectionBasedTracker_Parameters_propMaxTrackLifetime_const(instance: *const c_void) -> i32;
		pub fn cv_DetectionBasedTracker_Parameters_propMaxTrackLifetime_int(instance: *mut c_void, val: i32);
		pub fn cv_DetectionBasedTracker_Parameters_propMinDetectionPeriod_const(instance: *const c_void) -> i32;
		pub fn cv_DetectionBasedTracker_Parameters_propMinDetectionPeriod_int(instance: *mut c_void, val: i32);
		pub fn cv_DetectionBasedTracker_Parameters_delete(instance: *mut c_void);
		pub fn cv_DetectionROI_propScale_const(instance: *const c_void) -> f64;
		pub fn cv_DetectionROI_propScale_double(instance: *mut c_void, val: f64);
		pub fn cv_DetectionROI_propLocations_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_DetectionROI_propLocations_vectorLPointG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_DetectionROI_propConfidences_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_DetectionROI_propConfidences_vectorLdoubleG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_DetectionROI_delete(instance: *mut c_void);
		pub fn cv_FaceDetectorYN_setInputSize_const_SizeR(instance: *mut c_void, input_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_FaceDetectorYN_getInputSize(instance: *mut c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_FaceDetectorYN_setScoreThreshold_float(instance: *mut c_void, score_threshold: f32, ocvrs_return: *mut Result_void);
		pub fn cv_FaceDetectorYN_getScoreThreshold(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_FaceDetectorYN_setNMSThreshold_float(instance: *mut c_void, nms_threshold: f32, ocvrs_return: *mut Result_void);
		pub fn cv_FaceDetectorYN_getNMSThreshold(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_FaceDetectorYN_setTopK_int(instance: *mut c_void, top_k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FaceDetectorYN_getTopK(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FaceDetectorYN_detect_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, faces: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FaceDetectorYN_create_const_StringR_const_StringR_const_SizeR_float_float_int_int_int(model: *const c_char, config: *const c_char, input_size: *const core::Size, score_threshold: f32, nms_threshold: f32, top_k: i32, backend_id: i32, target_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FaceDetectorYN_create_const_StringR_const_StringR_const_SizeR(model: *const c_char, config: *const c_char, input_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FaceDetectorYN_delete(instance: *mut c_void);
		pub fn cv_FaceRecognizerSF_alignCrop_const_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *const c_void, src_img: *const c_void, face_box: *const c_void, aligned_img: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FaceRecognizerSF_feature_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, aligned_img: *const c_void, face_feature: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_FaceRecognizerSF_match_const_const__InputArrayR_const__InputArrayR_int(instance: *const c_void, face_feature1: *const c_void, face_feature2: *const c_void, dis_type: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_FaceRecognizerSF_match_const_const__InputArrayR_const__InputArrayR(instance: *const c_void, face_feature1: *const c_void, face_feature2: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_FaceRecognizerSF_create_const_StringR_const_StringR_int_int(model: *const c_char, config: *const c_char, backend_id: i32, target_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FaceRecognizerSF_create_const_StringR_const_StringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FaceRecognizerSF_delete(instance: *mut c_void);
		pub fn cv_GraphicalCodeDetector_GraphicalCodeDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GraphicalCodeDetector_GraphicalCodeDetector_const_GraphicalCodeDetectorR(unnamed: *const c_void) -> *mut c_void;
		pub fn cv_GraphicalCodeDetector_GraphicalCodeDetector_GraphicalCodeDetectorRR(unnamed: *mut c_void) -> *mut c_void;
		pub fn cv_GraphicalCodeDetector_operatorST_const_GraphicalCodeDetectorR(instance: *mut c_void, unnamed: *const c_void);
		pub fn cv_GraphicalCodeDetector_operatorST_GraphicalCodeDetectorRR(instance: *mut c_void, unnamed: *mut c_void);
		pub fn cv_GraphicalCodeDetector_detect_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, img: *const c_void, points: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GraphicalCodeDetector_decode_const_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *const c_void, img: *const c_void, points: *const c_void, straight_code: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GraphicalCodeDetector_decode_const_const__InputArrayR_const__InputArrayR(instance: *const c_void, img: *const c_void, points: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GraphicalCodeDetector_detectAndDecode_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, img: *const c_void, points: *const c_void, straight_code: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GraphicalCodeDetector_detectAndDecode_const_const__InputArrayR(instance: *const c_void, img: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GraphicalCodeDetector_detectMulti_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, img: *const c_void, points: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GraphicalCodeDetector_decodeMulti_const_const__InputArrayR_const__InputArrayR_vectorLstringGR_const__OutputArrayR(instance: *const c_void, img: *const c_void, points: *const c_void, decoded_info: *mut c_void, straight_code: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GraphicalCodeDetector_decodeMulti_const_const__InputArrayR_const__InputArrayR_vectorLstringGR(instance: *const c_void, img: *const c_void, points: *const c_void, decoded_info: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GraphicalCodeDetector_detectAndDecodeMulti_const_const__InputArrayR_vectorLstringGR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, img: *const c_void, decoded_info: *mut c_void, points: *const c_void, straight_code: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GraphicalCodeDetector_detectAndDecodeMulti_const_const__InputArrayR_vectorLstringGR(instance: *const c_void, img: *const c_void, decoded_info: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GraphicalCodeDetector_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GraphicalCodeDetector_delete(instance: *mut c_void);
		pub fn cv_HOGDescriptor_HOGDescriptor(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_HOGDescriptor_Size_Size_Size_Size_int_int_double_HistogramNormType_double_bool_int_bool(_win_size: *const core::Size, _block_size: *const core::Size, _block_stride: *const core::Size, _cell_size: *const core::Size, _nbins: i32, _deriv_aperture: i32, _win_sigma: f64, _histogram_norm_type: crate::objdetect::HOGDescriptor_HistogramNormType, _l2_hys_threshold: f64, _gamma_correction: bool, _nlevels: i32, _signed_gradient: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_HOGDescriptor_Size_Size_Size_Size_int(_win_size: *const core::Size, _block_size: *const core::Size, _block_stride: *const core::Size, _cell_size: *const core::Size, _nbins: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_HOGDescriptor_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_HOGDescriptor_const_HOGDescriptorR(d: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_getDescriptorSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_HOGDescriptor_checkDetectorSize_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_HOGDescriptor_getWinSigma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_HOGDescriptor_setSVMDetector_const__InputArrayR(instance: *mut c_void, svmdetector: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_read_FileNodeR(instance: *mut c_void, fn_: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_HOGDescriptor_write_const_FileStorageR_const_StringR(instance: *const c_void, fs: *mut c_void, objname: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_load_const_StringR_const_StringR(instance: *mut c_void, filename: *const c_char, objname: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_HOGDescriptor_load_const_StringR(instance: *mut c_void, filename: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_HOGDescriptor_save_const_const_StringR_const_StringR(instance: *const c_void, filename: *const c_char, objname: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_save_const_const_StringR(instance: *const c_void, filename: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_copyTo_const_HOGDescriptorR(instance: *const c_void, c: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_compute_const_const__InputArrayR_vectorLfloatGR_Size_Size_const_vectorLPointGR(instance: *const c_void, img: *const c_void, descriptors: *mut c_void, win_stride: *const core::Size, padding: *const core::Size, locations: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_compute_const_const__InputArrayR_vectorLfloatGR(instance: *const c_void, img: *const c_void, descriptors: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_detect_const_const__InputArrayR_vectorLPointGR_vectorLdoubleGR_double_Size_Size_const_vectorLPointGR(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, weights: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, search_locations: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_detect_const_const__InputArrayR_vectorLPointGR_vectorLdoubleGR(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, weights: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_detect_const_const__InputArrayR_vectorLPointGR_double_Size_Size_const_vectorLPointGR(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, search_locations: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_detect_const_const__InputArrayR_vectorLPointGR(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_detectMultiScale_const_const__InputArrayR_vectorLRectGR_vectorLdoubleGR_double_Size_Size_double_double_bool(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, found_weights: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, scale: f64, group_threshold: f64, use_meanshift_grouping: bool, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_detectMultiScale_const_const__InputArrayR_vectorLRectGR_vectorLdoubleGR(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, found_weights: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_detectMultiScale_const_const__InputArrayR_vectorLRectGR_double_Size_Size_double_double_bool(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, scale: f64, group_threshold: f64, use_meanshift_grouping: bool, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_detectMultiScale_const_const__InputArrayR_vectorLRectGR(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_computeGradient_const_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_Size(instance: *const c_void, img: *const c_void, grad: *const c_void, angle_ofs: *const c_void, padding_tl: *const core::Size, padding_br: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_computeGradient_const_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(instance: *const c_void, img: *const c_void, grad: *const c_void, angle_ofs: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_getDefaultPeopleDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_getDaimlerPeopleDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_detectROI_const_const__InputArrayR_const_vectorLPointGR_vectorLPointGR_vectorLdoubleGR_double_Size_Size(instance: *const c_void, img: *const c_void, locations: *const c_void, found_locations: *mut c_void, confidences: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_detectROI_const_const__InputArrayR_const_vectorLPointGR_vectorLPointGR_vectorLdoubleGR(instance: *const c_void, img: *const c_void, locations: *const c_void, found_locations: *mut c_void, confidences: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_detectMultiScaleROI_const_const__InputArrayR_vectorLRectGR_vectorLDetectionROIGR_double_int(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, locations: *mut c_void, hit_threshold: f64, group_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_detectMultiScaleROI_const_const__InputArrayR_vectorLRectGR_vectorLDetectionROIGR(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, locations: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_groupRectangles_const_vectorLRectGR_vectorLdoubleGR_int_double(instance: *const c_void, rect_list: *mut c_void, weights: *mut c_void, group_threshold: i32, eps: f64, ocvrs_return: *mut Result_void);
		pub fn cv_HOGDescriptor_propWinSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_HOGDescriptor_propWinSize_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_HOGDescriptor_propBlockSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_HOGDescriptor_propBlockSize_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_HOGDescriptor_propBlockStride_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_HOGDescriptor_propBlockStride_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_HOGDescriptor_propCellSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_HOGDescriptor_propCellSize_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_HOGDescriptor_propNbins_const(instance: *const c_void) -> i32;
		pub fn cv_HOGDescriptor_propNbins_int(instance: *mut c_void, val: i32);
		pub fn cv_HOGDescriptor_propDerivAperture_const(instance: *const c_void) -> i32;
		pub fn cv_HOGDescriptor_propDerivAperture_int(instance: *mut c_void, val: i32);
		pub fn cv_HOGDescriptor_propWinSigma_const(instance: *const c_void) -> f64;
		pub fn cv_HOGDescriptor_propWinSigma_double(instance: *mut c_void, val: f64);
		pub fn cv_HOGDescriptor_propHistogramNormType_const(instance: *const c_void, ocvrs_return: *mut crate::objdetect::HOGDescriptor_HistogramNormType);
		pub fn cv_HOGDescriptor_propHistogramNormType_HistogramNormType(instance: *mut c_void, val: crate::objdetect::HOGDescriptor_HistogramNormType);
		pub fn cv_HOGDescriptor_propL2HysThreshold_const(instance: *const c_void) -> f64;
		pub fn cv_HOGDescriptor_propL2HysThreshold_double(instance: *mut c_void, val: f64);
		pub fn cv_HOGDescriptor_propGammaCorrection_const(instance: *const c_void) -> bool;
		pub fn cv_HOGDescriptor_propGammaCorrection_bool(instance: *mut c_void, val: bool);
		pub fn cv_HOGDescriptor_propSvmDetector_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_HOGDescriptor_propSvmDetector_vectorLfloatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_HOGDescriptor_propOclSvmDetector_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_HOGDescriptor_propOclSvmDetector_UMat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_HOGDescriptor_propFree_coef_const(instance: *const c_void) -> f32;
		pub fn cv_HOGDescriptor_propFree_coef_float(instance: *mut c_void, val: f32);
		pub fn cv_HOGDescriptor_propNlevels_const(instance: *const c_void) -> i32;
		pub fn cv_HOGDescriptor_propNlevels_int(instance: *mut c_void, val: i32);
		pub fn cv_HOGDescriptor_propSignedGradient_const(instance: *const c_void) -> bool;
		pub fn cv_HOGDescriptor_propSignedGradient_bool(instance: *mut c_void, val: bool);
		pub fn cv_HOGDescriptor_delete(instance: *mut c_void);
		pub fn cv_QRCodeDetector_QRCodeDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_setEpsX_double(instance: *mut c_void, eps_x: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_setEpsY_double(instance: *mut c_void, eps_y: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_setUseAlignmentMarkers_bool(instance: *mut c_void, use_alignment_markers: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_decodeCurved_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, img: *const c_void, points: *const c_void, straight_qrcode: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_decodeCurved_const__InputArrayR_const__InputArrayR(instance: *mut c_void, img: *const c_void, points: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_detectAndDecodeCurved_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, img: *const c_void, points: *const c_void, straight_qrcode: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_detectAndDecodeCurved_const__InputArrayR(instance: *mut c_void, img: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_QRCodeDetector_to_GraphicalCodeDetector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_QRCodeDetector_delete(instance: *mut c_void);
		pub fn cv_QRCodeDetectorAruco_QRCodeDetectorAruco(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetectorAruco_QRCodeDetectorAruco_const_ParamsR(params: *const crate::objdetect::QRCodeDetectorAruco_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetectorAruco_getDetectorParameters_const(instance: *const c_void, ocvrs_return: *mut Result<crate::objdetect::QRCodeDetectorAruco_Params>);
		pub fn cv_QRCodeDetectorAruco_setDetectorParameters_const_ParamsR(instance: *mut c_void, params: *const crate::objdetect::QRCodeDetectorAruco_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetectorAruco_getArucoParameters(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetectorAruco_setArucoParameters_const_DetectorParametersR(instance: *mut c_void, params: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_QRCodeDetectorAruco_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_QRCodeDetectorAruco_to_GraphicalCodeDetector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_QRCodeDetectorAruco_delete(instance: *mut c_void);
		pub fn cv_QRCodeDetectorAruco_Params_Params(ocvrs_return: *mut Result<crate::objdetect::QRCodeDetectorAruco_Params>);
		pub fn cv_QRCodeEncoder_create_const_ParamsR(parameters: *const crate::objdetect::QRCodeEncoder_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeEncoder_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeEncoder_encode_const_StringR_const__OutputArrayR(instance: *mut c_void, encoded_info: *const c_char, qrcode: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_QRCodeEncoder_encodeStructuredAppend_const_StringR_const__OutputArrayR(instance: *mut c_void, encoded_info: *const c_char, qrcodes: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_QRCodeEncoder_delete(instance: *mut c_void);
		pub fn cv_QRCodeEncoder_Params_Params(ocvrs_return: *mut Result<crate::objdetect::QRCodeEncoder_Params>);
		pub fn cv_SimilarRects_SimilarRects_double(_eps: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SimilarRects_operator___const_const_RectR_const_RectR(instance: *const c_void, r1: *const core::Rect, r2: *const core::Rect, ocvrs_return: *mut Result<bool>);
		pub fn cv_SimilarRects_propEps_const(instance: *const c_void) -> f64;
		pub fn cv_SimilarRects_propEps_double(instance: *mut c_void, val: f64);
		pub fn cv_SimilarRects_delete(instance: *mut c_void);
		pub fn cv_aruco_ArucoDetector_ArucoDetector_const_DictionaryR_const_DetectorParametersR_const_RefineParametersR(dictionary: *const c_void, detector_params: *const c_void, refine_params: *const crate::objdetect::RefineParameters, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_ArucoDetector_ArucoDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_ArucoDetector_detectMarkers_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, image: *const c_void, corners: *const c_void, ids: *const c_void, rejected_img_points: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_ArucoDetector_detectMarkers_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, image: *const c_void, corners: *const c_void, ids: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_ArucoDetector_refineDetectedMarkers_const_const__InputArrayR_const_BoardR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *const c_void, image: *const c_void, board: *const c_void, detected_corners: *const c_void, detected_ids: *const c_void, rejected_corners: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, recovered_idxs: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_ArucoDetector_refineDetectedMarkers_const_const__InputArrayR_const_BoardR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(instance: *const c_void, image: *const c_void, board: *const c_void, detected_corners: *const c_void, detected_ids: *const c_void, rejected_corners: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_ArucoDetector_getDictionary_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_ArucoDetector_setDictionary_const_DictionaryR(instance: *mut c_void, dictionary: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_ArucoDetector_getDetectorParameters_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_ArucoDetector_setDetectorParameters_const_DetectorParametersR(instance: *mut c_void, detector_parameters: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_ArucoDetector_getRefineParameters_const(instance: *const c_void, ocvrs_return: *mut Result<crate::objdetect::RefineParameters>);
		pub fn cv_aruco_ArucoDetector_setRefineParameters_const_RefineParametersR(instance: *mut c_void, refine_parameters: *const crate::objdetect::RefineParameters, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_ArucoDetector_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_ArucoDetector_write_FileStorageR_const_StringR(instance: *mut c_void, fs: *mut c_void, name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_ArucoDetector_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_ArucoDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_aruco_ArucoDetector_delete(instance: *mut c_void);
		pub fn cv_aruco_Board_Board_const__InputArrayR_const_DictionaryR_const__InputArrayR(obj_points: *const c_void, dictionary: *const c_void, ids: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Board_getDictionary_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Board_getObjPoints_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Board_getIds_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Board_getRightBottomCorner_const(instance: *const c_void, ocvrs_return: *mut Result<core::Point3f>);
		pub fn cv_aruco_Board_matchImagePoints_const_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, detected_corners: *const c_void, detected_ids: *const c_void, obj_points: *const c_void, img_points: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_Board_generateImage_const_Size_const__OutputArrayR_int_int(instance: *const c_void, out_size: *const core::Size, img: *const c_void, margin_size: i32, border_bits: i32, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_Board_generateImage_const_Size_const__OutputArrayR(instance: *const c_void, out_size: *const core::Size, img: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_Board_Board(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Board_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_Board_delete(instance: *mut c_void);
		pub fn cv_aruco_CharucoBoard_CharucoBoard_const_SizeR_float_float_const_DictionaryR_const__InputArrayR(size: *const core::Size, square_length: f32, marker_length: f32, dictionary: *const c_void, ids: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoBoard_CharucoBoard_const_SizeR_float_float_const_DictionaryR(size: *const core::Size, square_length: f32, marker_length: f32, dictionary: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoBoard_setLegacyPattern_bool(instance: *mut c_void, legacy_pattern: bool, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_CharucoBoard_getLegacyPattern_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_CharucoBoard_getChessboardSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_aruco_CharucoBoard_getSquareLength_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_aruco_CharucoBoard_getMarkerLength_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_aruco_CharucoBoard_getChessboardCorners_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoBoard_getNearestMarkerIdx_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoBoard_getNearestMarkerCorners_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoBoard_checkCharucoCornersCollinear_const_const__InputArrayR(instance: *const c_void, charuco_ids: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_CharucoBoard_CharucoBoard(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoBoard_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_CharucoBoard_to_Board(instance: *mut c_void) -> *mut c_void;
		pub fn cv_aruco_CharucoBoard_delete(instance: *mut c_void);
		pub fn cv_aruco_CharucoDetector_CharucoDetector_const_CharucoBoardR_const_CharucoParametersR_const_DetectorParametersR_const_RefineParametersR(board: *const c_void, charuco_params: *const c_void, detector_params: *const c_void, refine_params: *const crate::objdetect::RefineParameters, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoDetector_CharucoDetector_const_CharucoBoardR(board: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoDetector_getBoard_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoDetector_setBoard_const_CharucoBoardR(instance: *mut c_void, board: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_CharucoDetector_getCharucoParameters_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoDetector_setCharucoParameters_CharucoParametersR(instance: *mut c_void, charuco_parameters: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_CharucoDetector_getDetectorParameters_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoDetector_setDetectorParameters_const_DetectorParametersR(instance: *mut c_void, detector_parameters: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_CharucoDetector_getRefineParameters_const(instance: *const c_void, ocvrs_return: *mut Result<crate::objdetect::RefineParameters>);
		pub fn cv_aruco_CharucoDetector_setRefineParameters_const_RefineParametersR(instance: *mut c_void, refine_parameters: *const crate::objdetect::RefineParameters, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_CharucoDetector_detectBoard_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(instance: *const c_void, image: *const c_void, charuco_corners: *const c_void, charuco_ids: *const c_void, marker_corners: *const c_void, marker_ids: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_CharucoDetector_detectBoard_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, image: *const c_void, charuco_corners: *const c_void, charuco_ids: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_CharucoDetector_detectDiamonds_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(instance: *const c_void, image: *const c_void, diamond_corners: *const c_void, diamond_ids: *const c_void, marker_corners: *const c_void, marker_ids: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_CharucoDetector_detectDiamonds_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, image: *const c_void, diamond_corners: *const c_void, diamond_ids: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_CharucoDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_aruco_CharucoDetector_delete(instance: *mut c_void);
		pub fn cv_aruco_CharucoParameters_CharucoParameters(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoParameters_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_CharucoParameters_propCameraMatrix_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_CharucoParameters_propCameraMatrix_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_aruco_CharucoParameters_propDistCoeffs_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_CharucoParameters_propDistCoeffs_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_aruco_CharucoParameters_propMinMarkers_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_CharucoParameters_propMinMarkers_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_CharucoParameters_propTryRefineMarkers_const(instance: *const c_void) -> bool;
		pub fn cv_aruco_CharucoParameters_propTryRefineMarkers_bool(instance: *mut c_void, val: bool);
		pub fn cv_aruco_CharucoParameters_delete(instance: *mut c_void);
		pub fn cv_aruco_DetectorParameters_DetectorParameters(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_DetectorParameters_readDetectorParameters_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_DetectorParameters_writeDetectorParameters_FileStorageR_const_StringR(instance: *mut c_void, fs: *mut c_void, name: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_DetectorParameters_writeDetectorParameters_FileStorageR(instance: *mut c_void, fs: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_DetectorParameters_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_DetectorParameters_propAdaptiveThreshWinSizeMin_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propAdaptiveThreshWinSizeMin_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propAdaptiveThreshWinSizeMax_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propAdaptiveThreshWinSizeMax_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propAdaptiveThreshWinSizeStep_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propAdaptiveThreshWinSizeStep_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propAdaptiveThreshConstant_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propAdaptiveThreshConstant_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propMinMarkerPerimeterRate_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propMinMarkerPerimeterRate_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propMaxMarkerPerimeterRate_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propMaxMarkerPerimeterRate_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propPolygonalApproxAccuracyRate_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propPolygonalApproxAccuracyRate_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propMinCornerDistanceRate_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propMinCornerDistanceRate_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propMinDistanceToBorder_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propMinDistanceToBorder_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propMinMarkerDistanceRate_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propMinMarkerDistanceRate_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propCornerRefinementMethod_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propCornerRefinementMethod_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propCornerRefinementWinSize_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propCornerRefinementWinSize_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propCornerRefinementMaxIterations_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propCornerRefinementMaxIterations_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propCornerRefinementMinAccuracy_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propCornerRefinementMinAccuracy_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propMarkerBorderBits_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propMarkerBorderBits_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propPerspectiveRemovePixelPerCell_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propPerspectiveRemovePixelPerCell_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propPerspectiveRemoveIgnoredMarginPerCell_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propPerspectiveRemoveIgnoredMarginPerCell_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propMaxErroneousBitsInBorderRate_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propMaxErroneousBitsInBorderRate_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propMinOtsuStdDev_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propMinOtsuStdDev_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propErrorCorrectionRate_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propErrorCorrectionRate_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propAprilTagQuadDecimate_const(instance: *const c_void) -> f32;
		pub fn cv_aruco_DetectorParameters_propAprilTagQuadDecimate_float(instance: *mut c_void, val: f32);
		pub fn cv_aruco_DetectorParameters_propAprilTagQuadSigma_const(instance: *const c_void) -> f32;
		pub fn cv_aruco_DetectorParameters_propAprilTagQuadSigma_float(instance: *mut c_void, val: f32);
		pub fn cv_aruco_DetectorParameters_propAprilTagMinClusterPixels_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propAprilTagMinClusterPixels_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propAprilTagMaxNmaxima_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propAprilTagMaxNmaxima_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propAprilTagCriticalRad_const(instance: *const c_void) -> f32;
		pub fn cv_aruco_DetectorParameters_propAprilTagCriticalRad_float(instance: *mut c_void, val: f32);
		pub fn cv_aruco_DetectorParameters_propAprilTagMaxLineFitMse_const(instance: *const c_void) -> f32;
		pub fn cv_aruco_DetectorParameters_propAprilTagMaxLineFitMse_float(instance: *mut c_void, val: f32);
		pub fn cv_aruco_DetectorParameters_propAprilTagMinWhiteBlackDiff_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propAprilTagMinWhiteBlackDiff_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propAprilTagDeglitch_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propAprilTagDeglitch_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propDetectInvertedMarker_const(instance: *const c_void) -> bool;
		pub fn cv_aruco_DetectorParameters_propDetectInvertedMarker_bool(instance: *mut c_void, val: bool);
		pub fn cv_aruco_DetectorParameters_propUseAruco3Detection_const(instance: *const c_void) -> bool;
		pub fn cv_aruco_DetectorParameters_propUseAruco3Detection_bool(instance: *mut c_void, val: bool);
		pub fn cv_aruco_DetectorParameters_propMinSideLengthCanonicalImg_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propMinSideLengthCanonicalImg_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propMinMarkerLengthRatioOriginalImg_const(instance: *const c_void) -> f32;
		pub fn cv_aruco_DetectorParameters_propMinMarkerLengthRatioOriginalImg_float(instance: *mut c_void, val: f32);
		pub fn cv_aruco_DetectorParameters_delete(instance: *mut c_void);
		pub fn cv_aruco_Dictionary_Dictionary(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Dictionary_Dictionary_const_MatR_int_int(bytes_list: *const c_void, _marker_size: i32, maxcorr: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Dictionary_Dictionary_const_MatR_int(bytes_list: *const c_void, _marker_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Dictionary_readDictionary_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_Dictionary_writeDictionary_FileStorageR_const_StringR(instance: *mut c_void, fs: *mut c_void, name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_Dictionary_writeDictionary_FileStorageR(instance: *mut c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_Dictionary_identify_const_const_MatR_intR_intR_double(instance: *const c_void, only_bits: *const c_void, idx: *mut i32, rotation: *mut i32, max_correction_rate: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_Dictionary_getDistanceToId_const_const__InputArrayR_int_bool(instance: *const c_void, bits: *const c_void, id: i32, all_rotations: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_aruco_Dictionary_getDistanceToId_const_const__InputArrayR_int(instance: *const c_void, bits: *const c_void, id: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_aruco_Dictionary_generateImageMarker_const_int_int_const__OutputArrayR_int(instance: *const c_void, id: i32, side_pixels: i32, _img: *const c_void, border_bits: i32, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_Dictionary_generateImageMarker_const_int_int_const__OutputArrayR(instance: *const c_void, id: i32, side_pixels: i32, _img: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_aruco_Dictionary_getByteListFromBits_const_MatR(bits: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Dictionary_getBitsFromByteList_const_MatR_int(byte_list: *const c_void, marker_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Dictionary_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_Dictionary_propBytesList_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_Dictionary_propBytesList_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_aruco_Dictionary_propMarkerSize_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_Dictionary_propMarkerSize_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_Dictionary_propMaxCorrectionBits_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_Dictionary_propMaxCorrectionBits_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_Dictionary_delete(instance: *mut c_void);
		pub fn cv_aruco_GridBoard_GridBoard_const_SizeR_float_float_const_DictionaryR_const__InputArrayR(size: *const core::Size, marker_length: f32, marker_separation: f32, dictionary: *const c_void, ids: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_GridBoard_GridBoard_const_SizeR_float_float_const_DictionaryR(size: *const core::Size, marker_length: f32, marker_separation: f32, dictionary: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_GridBoard_getGridSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_aruco_GridBoard_getMarkerLength_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_aruco_GridBoard_getMarkerSeparation_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_aruco_GridBoard_GridBoard(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_GridBoard_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_GridBoard_to_Board(instance: *mut c_void) -> *mut c_void;
		pub fn cv_aruco_GridBoard_delete(instance: *mut c_void);
		pub fn cv_aruco_RefineParameters_RefineParameters_float_float_bool(min_rep_distance: f32, error_correction_rate: f32, check_all_orders: bool, ocvrs_return: *mut Result<crate::objdetect::RefineParameters>);
		pub fn cv_aruco_RefineParameters_RefineParameters(ocvrs_return: *mut Result<crate::objdetect::RefineParameters>);
		pub fn cv_aruco_RefineParameters_readRefineParameters_const_FileNodeR(instance: *const crate::objdetect::RefineParameters, fn_: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_RefineParameters_writeRefineParameters_FileStorageR_const_StringR(instance: *const crate::objdetect::RefineParameters, fs: *mut c_void, name: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_RefineParameters_writeRefineParameters_FileStorageR(instance: *const crate::objdetect::RefineParameters, fs: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_barcode_BarcodeDetector_BarcodeDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_barcode_BarcodeDetector_BarcodeDetector_const_stringR_const_stringR(prototxt_path: *const c_char, model_path: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_barcode_BarcodeDetector_decodeWithType_const_const__InputArrayR_const__InputArrayR_vectorLstringGR_vectorLstringGR(instance: *const c_void, img: *const c_void, points: *const c_void, decoded_info: *mut c_void, decoded_type: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_barcode_BarcodeDetector_detectAndDecodeWithType_const_const__InputArrayR_vectorLstringGR_vectorLstringGR_const__OutputArrayR(instance: *const c_void, img: *const c_void, decoded_info: *mut c_void, decoded_type: *mut c_void, points: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_barcode_BarcodeDetector_detectAndDecodeWithType_const_const__InputArrayR_vectorLstringGR_vectorLstringGR(instance: *const c_void, img: *const c_void, decoded_info: *mut c_void, decoded_type: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_barcode_BarcodeDetector_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_barcode_BarcodeDetector_to_GraphicalCodeDetector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_barcode_BarcodeDetector_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_aruco_ArucoDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_ArucoDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_ArucoDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_aruco_ArucoDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_ArucoDetectorG_new_const_ArucoDetector(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BaseCascadeClassifierG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BaseCascadeClassifierG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BaseCascadeClassifierG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_BaseCascadeClassifierG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BaseCascadeClassifier_MaskGeneratorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BaseCascadeClassifier_MaskGeneratorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BaseCascadeClassifier_MaskGeneratorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_aruco_BoardG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_BoardG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_BoardG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_aruco_BoardG_new_const_Board(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_CharucoBoardG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_CharucoBoardG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_CharucoBoardG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_aruco_CharucoBoardG_to_PtrOfBoard(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_CharucoBoardG_new_const_CharucoBoard(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_CharucoDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_CharucoDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_CharucoDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_aruco_CharucoDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_CharucoDetectorG_new_const_CharucoDetector(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DetectionBasedTracker_IDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DetectionBasedTracker_IDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DetectionBasedTracker_IDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_aruco_DetectorParametersG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_DetectorParametersG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_DetectorParametersG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_aruco_DetectorParametersG_new_const_DetectorParameters(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_DictionaryG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_DictionaryG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_DictionaryG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_aruco_DictionaryG_new_const_Dictionary(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FaceDetectorYNG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FaceDetectorYNG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FaceDetectorYNG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_FaceRecognizerSFG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FaceRecognizerSFG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FaceRecognizerSFG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_aruco_GridBoardG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_GridBoardG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_GridBoardG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_aruco_GridBoardG_to_PtrOfBoard(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_GridBoardG_new_const_GridBoard(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_QRCodeEncoderG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_QRCodeEncoderG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_QRCodeEncoderG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_push_const_ExtObject(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_insert_size_t_const_ExtObject(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_set_size_t_const_ExtObject(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_push_const_Object(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_insert_size_t_const_Object(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_set_size_t_const_Object(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_DetectionROIG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_DetectionROIG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionROIG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_DetectionROIG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_DetectionROIG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_DetectionROIG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionROIG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_DetectionROIG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_DetectionROIG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_DetectionROIG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionROIG_push_const_DetectionROI(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_DetectionROIG_insert_size_t_const_DetectionROI(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_DetectionROIG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_DetectionROIG_set_size_t_const_DetectionROI(instance: *mut c_void, index: size_t, val: *const c_void);
	}
}
#[cfg(ocvrs_has_module_objdetect)]
pub use objdetect_sys::*;

#[cfg(ocvrs_has_module_optflow)]
mod optflow_sys {
	use super::*;

	extern "C" {
		pub fn cv_motempl_calcGlobalOrientation_const__InputArrayR_const__InputArrayR_const__InputArrayR_double_double(orientation: *const c_void, mask: *const c_void, mhi: *const c_void, timestamp: f64, duration: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_motempl_calcMotionGradient_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double_double(mhi: *const c_void, mask: *const c_void, orientation: *const c_void, delta1: f64, delta2: f64, ocvrs_return: *mut Result_void);
		pub fn cv_motempl_calcMotionGradient_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double_double_int(mhi: *const c_void, mask: *const c_void, orientation: *const c_void, delta1: f64, delta2: f64, aperture_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_motempl_segmentMotion_const__InputArrayR_const__OutputArrayR_vectorLRectGR_double_double(mhi: *const c_void, segmask: *const c_void, bounding_rects: *mut c_void, timestamp: f64, seg_thresh: f64, ocvrs_return: *mut Result_void);
		pub fn cv_motempl_updateMotionHistory_const__InputArrayR_const__InputOutputArrayR_double_double(silhouette: *const c_void, mhi: *const c_void, timestamp: f64, duration: f64, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_calcOpticalFlowDenseRLOF_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR(i0: *const c_void, i1: *const c_void, flow: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_calcOpticalFlowDenseRLOF_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_PtrLRLOFOpticalFlowParameterG_float_Size_InterpolationType_int_float_float_int_int_bool_float_float_bool(i0: *const c_void, i1: *const c_void, flow: *const c_void, rlof_param: *mut c_void, forward_backward_threshold: f32, grid_step: *const core::Size, interp_type: crate::optflow::InterpolationType, epic_k: i32, epic_sigma: f32, epic_lambda: f32, ric_sp_size: i32, ric_slic_type: i32, use_post_proc: bool, fgs_lambda: f32, fgs_sigma: f32, use_variational_refinement: bool, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_calcOpticalFlowSF_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_int_int(from: *const c_void, to: *const c_void, flow: *const c_void, layers: i32, averaging_block_size: i32, max_flow: i32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_calcOpticalFlowSF_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_int_int_double_double_int_double_double_double_int_double_double_double(from: *const c_void, to: *const c_void, flow: *const c_void, layers: i32, averaging_block_size: i32, max_flow: i32, sigma_dist: f64, sigma_color: f64, postprocess_window: i32, sigma_dist_fix: f64, sigma_color_fix: f64, occ_thr: f64, upscale_averaging_radius: i32, upscale_sigma_dist: f64, upscale_sigma_color: f64, speed_up_thr: f64, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_calcOpticalFlowSparseRLOF_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR(prev_img: *const c_void, next_img: *const c_void, prev_pts: *const c_void, next_pts: *const c_void, status: *const c_void, err: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_calcOpticalFlowSparseRLOF_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_PtrLRLOFOpticalFlowParameterG_float(prev_img: *const c_void, next_img: *const c_void, prev_pts: *const c_void, next_pts: *const c_void, status: *const c_void, err: *const c_void, rlof_param: *mut c_void, forward_backward_threshold: f32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_calcOpticalFlowSparseToDense_const__InputArrayR_const__InputArrayR_const__OutputArrayR(from: *const c_void, to: *const c_void, flow: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_calcOpticalFlowSparseToDense_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_int_float_bool_float_float(from: *const c_void, to: *const c_void, flow: *const c_void, grid_step: i32, k: i32, sigma: f32, use_post_proc: bool, fgs_lambda: f32, fgs_sigma: f32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_createOptFlow_DeepFlow(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_createOptFlow_DenseRLOF(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_createOptFlow_DualTVL1(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_createOptFlow_Farneback(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_createOptFlow_PCAFlow(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_createOptFlow_SimpleFlow(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_createOptFlow_SparseRLOF(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_createOptFlow_SparseToDense(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_read_const_FileNodeR_NodeR_Node(fn_: *const c_void, node: *mut crate::optflow::GPCTree_Node, unnamed: *const crate::optflow::GPCTree_Node, ocvrs_return: *mut Result_void);
		pub fn cv_write_FileStorageR_const_StringR_const_NodeR(fs: *mut c_void, name: *const c_char, node: *const crate::optflow::GPCTree_Node, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DenseRLOFOpticalFlow_setRLOFOpticalFlowParameter_PtrLRLOFOpticalFlowParameterG(instance: *mut c_void, val: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DenseRLOFOpticalFlow_getRLOFOpticalFlowParameter_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_DenseRLOFOpticalFlow_setForwardBackward_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DenseRLOFOpticalFlow_getForwardBackward_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_optflow_DenseRLOFOpticalFlow_getGridStep_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_optflow_DenseRLOFOpticalFlow_setGridStep_Size(instance: *mut c_void, val: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DenseRLOFOpticalFlow_setInterpolation_InterpolationType(instance: *mut c_void, val: crate::optflow::InterpolationType, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DenseRLOFOpticalFlow_getInterpolation_const(instance: *const c_void, ocvrs_return: *mut Result<crate::optflow::InterpolationType>);
		pub fn cv_optflow_DenseRLOFOpticalFlow_getEPICK_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_optflow_DenseRLOFOpticalFlow_setEPICK_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DenseRLOFOpticalFlow_getEPICSigma_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_optflow_DenseRLOFOpticalFlow_setEPICSigma_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DenseRLOFOpticalFlow_getEPICLambda_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_optflow_DenseRLOFOpticalFlow_setEPICLambda_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DenseRLOFOpticalFlow_getFgsLambda_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_optflow_DenseRLOFOpticalFlow_setFgsLambda_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DenseRLOFOpticalFlow_getFgsSigma_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_optflow_DenseRLOFOpticalFlow_setFgsSigma_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DenseRLOFOpticalFlow_setUsePostProc_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DenseRLOFOpticalFlow_getUsePostProc_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_optflow_DenseRLOFOpticalFlow_setUseVariationalRefinement_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DenseRLOFOpticalFlow_getUseVariationalRefinement_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_optflow_DenseRLOFOpticalFlow_setRICSPSize_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DenseRLOFOpticalFlow_getRICSPSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_optflow_DenseRLOFOpticalFlow_setRICSLICType_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DenseRLOFOpticalFlow_getRICSLICType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_optflow_DenseRLOFOpticalFlow_create_PtrLRLOFOpticalFlowParameterG_float_Size_InterpolationType_int_float_float_int_int_bool_float_float_bool(rlof_param: *mut c_void, forward_backward_threshold: f32, grid_step: *const core::Size, interp_type: crate::optflow::InterpolationType, epic_k: i32, epic_sigma: f32, epic_lambda: f32, ric_sp_size: i32, ric_slic_type: i32, use_post_proc: bool, fgs_lambda: f32, fgs_sigma: f32, use_variational_refinement: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_DenseRLOFOpticalFlow_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_DenseRLOFOpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_optflow_DenseRLOFOpticalFlow_to_DenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_optflow_DenseRLOFOpticalFlow_delete(instance: *mut c_void);
		pub fn cv_optflow_DualTVL1OpticalFlow_getTau_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_optflow_DualTVL1OpticalFlow_setTau_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DualTVL1OpticalFlow_getLambda_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_optflow_DualTVL1OpticalFlow_setLambda_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DualTVL1OpticalFlow_getTheta_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_optflow_DualTVL1OpticalFlow_setTheta_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DualTVL1OpticalFlow_getGamma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_optflow_DualTVL1OpticalFlow_setGamma_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DualTVL1OpticalFlow_getScalesNumber_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_optflow_DualTVL1OpticalFlow_setScalesNumber_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DualTVL1OpticalFlow_getWarpingsNumber_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_optflow_DualTVL1OpticalFlow_setWarpingsNumber_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DualTVL1OpticalFlow_getEpsilon_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_optflow_DualTVL1OpticalFlow_setEpsilon_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DualTVL1OpticalFlow_getInnerIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_optflow_DualTVL1OpticalFlow_setInnerIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DualTVL1OpticalFlow_getOuterIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_optflow_DualTVL1OpticalFlow_setOuterIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DualTVL1OpticalFlow_getUseInitialFlow_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_optflow_DualTVL1OpticalFlow_setUseInitialFlow_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DualTVL1OpticalFlow_getScaleStep_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_optflow_DualTVL1OpticalFlow_setScaleStep_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DualTVL1OpticalFlow_getMedianFiltering_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_optflow_DualTVL1OpticalFlow_setMedianFiltering_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_DualTVL1OpticalFlow_create_double_double_double_int_int_double_int_int_double_double_int_bool(tau: f64, lambda: f64, theta: f64, nscales: i32, warps: i32, epsilon: f64, innner_iterations: i32, outer_iterations: i32, scale_step: f64, gamma: f64, median_filtering: i32, use_initial_flow: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_DualTVL1OpticalFlow_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_DualTVL1OpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_optflow_DualTVL1OpticalFlow_to_DenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_optflow_DualTVL1OpticalFlow_delete(instance: *mut c_void);
		pub fn cv_optflow_GPCDetails_dropOutliers_vectorLpairLcv_Point2i__cv_Point2iGGR(corr: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_GPCDetails_getAllDescriptorsForImage_const_MatX_vectorLGPCPatchDescriptorGR_const_GPCMatchingParamsR_int(img_ch: *const c_void, descr: *mut c_void, mp: *const crate::optflow::GPCMatchingParams, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_GPCDetails_getCoordinatesFromIndex_size_t_Size_intR_intR(index: size_t, sz: *const core::Size, x: *mut i32, y: *mut i32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_GPCDetails_delete(instance: *mut c_void);
		pub fn cv_optflow_GPCMatchingParams_GPCMatchingParams_bool(_use_opencl: bool, ocvrs_return: *mut Result<crate::optflow::GPCMatchingParams>);
		pub fn cv_optflow_GPCMatchingParams_GPCMatchingParams(ocvrs_return: *mut Result<crate::optflow::GPCMatchingParams>);
		pub fn cv_optflow_GPCMatchingParams_GPCMatchingParams_const_GPCMatchingParamsR(params: *const crate::optflow::GPCMatchingParams, ocvrs_return: *mut Result<crate::optflow::GPCMatchingParams>);
		pub fn cv_optflow_GPCPatchDescriptor_dot_const_const_VecLdouble__18GR(instance: *const c_void, coef: *const core::VecN<f64, 18>, ocvrs_return: *mut Result<f64>);
		pub fn cv_optflow_GPCPatchDescriptor_markAsSeparated(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_GPCPatchDescriptor_isSeparated_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_optflow_GPCPatchDescriptor_propFeature_const(instance: *const c_void, ocvrs_return: *mut core::VecN<f64, 18>);
		pub fn cv_optflow_GPCPatchDescriptor_propFeature_VecLdouble__18G(instance: *mut c_void, val: *const core::VecN<f64, 18>);
		pub fn cv_optflow_GPCPatchDescriptor_delete(instance: *mut c_void);
		pub fn cv_optflow_GPCPatchSample_getDirections_const_boolR_boolR_boolR_const_VecLdouble__18GR_double(instance: *const c_void, refdir: *mut bool, posdir: *mut bool, negdir: *mut bool, coef: *const core::VecN<f64, 18>, rhs: f64, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_GPCPatchSample_propRef_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_optflow_GPCPatchSample_propRef_GPCPatchDescriptor(instance: *mut c_void, val: *mut c_void);
		pub fn cv_optflow_GPCPatchSample_propPos_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_optflow_GPCPatchSample_propPos_GPCPatchDescriptor(instance: *mut c_void, val: *mut c_void);
		pub fn cv_optflow_GPCPatchSample_propNeg_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_optflow_GPCPatchSample_propNeg_GPCPatchDescriptor(instance: *mut c_void, val: *mut c_void);
		pub fn cv_optflow_GPCPatchSample_delete(instance: *mut c_void);
		pub fn cv_optflow_GPCTrainingParams_GPCTrainingParams_unsigned_int_int_GPCDescType_bool(_max_tree_depth: u32, _min_number_of_samples: i32, _descriptor_type: crate::optflow::GPCDescType, _print_progress: bool, ocvrs_return: *mut Result<crate::optflow::GPCTrainingParams>);
		pub fn cv_optflow_GPCTrainingParams_GPCTrainingParams(ocvrs_return: *mut Result<crate::optflow::GPCTrainingParams>);
		pub fn cv_optflow_GPCTrainingParams_check_const(instance: *const crate::optflow::GPCTrainingParams, ocvrs_return: *mut Result<bool>);
		pub fn cv_optflow_GPCTrainingSamples_create_const_vectorLStringGR_const_vectorLStringGR_const_vectorLStringGR_int(images_from: *const c_void, images_to: *const c_void, gt: *const c_void, descriptor_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_GPCTrainingSamples_create_const__InputArrayR_const__InputArrayR_const__InputArrayR_int(images_from: *const c_void, images_to: *const c_void, gt: *const c_void, descriptor_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_GPCTrainingSamples_size_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_optflow_GPCTrainingSamples_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_optflow_GPCTrainingSamples_delete(instance: *mut c_void);
		pub fn cv_optflow_GPCTree_train_GPCTrainingSamplesR_const_GPCTrainingParams(instance: *mut c_void, samples: *mut c_void, params: *const crate::optflow::GPCTrainingParams, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_GPCTree_train_GPCTrainingSamplesR(instance: *mut c_void, samples: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_GPCTree_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_GPCTree_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_GPCTree_findLeafForPatch_const_const_GPCPatchDescriptorR(instance: *const c_void, descr: *const c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_optflow_GPCTree_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_GPCTree_operatorEQ_const_const_GPCTreeR(instance: *const c_void, t: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_optflow_GPCTree_getDescriptorType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_optflow_GPCTree_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_optflow_GPCTree_delete(instance: *mut c_void);
		pub fn cv_optflow_GPCTree_Node_operatorEQ_const_const_NodeR(instance: *const crate::optflow::GPCTree_Node, n: *const crate::optflow::GPCTree_Node, ocvrs_return: *mut Result<bool>);
		pub fn cv_optflow_OpticalFlowPCAFlow_OpticalFlowPCAFlow_PtrLconst_PCAPriorG_const_Size_float_float_float_float_float(_prior: *const c_void, _basis_size: *const core::Size, _sparse_rate: f32, _retained_corners_fraction: f32, _occlusions_threshold: f32, _damping_factor: f32, _clahe_clip: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_OpticalFlowPCAFlow_OpticalFlowPCAFlow(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_OpticalFlowPCAFlow_calc_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR(instance: *mut c_void, i0: *const c_void, i1: *const c_void, flow: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_OpticalFlowPCAFlow_collectGarbage(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_OpticalFlowPCAFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_optflow_OpticalFlowPCAFlow_to_DenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_optflow_OpticalFlowPCAFlow_delete(instance: *mut c_void);
		pub fn cv_optflow_PCAPrior_PCAPrior_const_charX(path_to_prior: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_PCAPrior_getPadding_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_optflow_PCAPrior_getBasisSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_optflow_PCAPrior_fillConstraints_const_floatX_floatX_floatX_floatX(instance: *const c_void, a1: *mut f32, a2: *mut f32, b1: *mut f32, b2: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_PCAPrior_delete(instance: *mut c_void);
		pub fn cv_optflow_RLOFOpticalFlowParameter_RLOFOpticalFlowParameter(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_RLOFOpticalFlowParameter_setUseMEstimator_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_RLOFOpticalFlowParameter_setSolverType_SolverType(instance: *mut c_void, val: crate::optflow::SolverType, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_RLOFOpticalFlowParameter_getSolverType_const(instance: *const c_void, ocvrs_return: *mut Result<crate::optflow::SolverType>);
		pub fn cv_optflow_RLOFOpticalFlowParameter_setSupportRegionType_SupportRegionType(instance: *mut c_void, val: crate::optflow::SupportRegionType, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_RLOFOpticalFlowParameter_getSupportRegionType_const(instance: *const c_void, ocvrs_return: *mut Result<crate::optflow::SupportRegionType>);
		pub fn cv_optflow_RLOFOpticalFlowParameter_setNormSigma0_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_RLOFOpticalFlowParameter_getNormSigma0_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_optflow_RLOFOpticalFlowParameter_setNormSigma1_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_RLOFOpticalFlowParameter_getNormSigma1_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_optflow_RLOFOpticalFlowParameter_setSmallWinSize_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_RLOFOpticalFlowParameter_getSmallWinSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_optflow_RLOFOpticalFlowParameter_setLargeWinSize_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_RLOFOpticalFlowParameter_getLargeWinSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_optflow_RLOFOpticalFlowParameter_setCrossSegmentationThreshold_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_RLOFOpticalFlowParameter_getCrossSegmentationThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_optflow_RLOFOpticalFlowParameter_setMaxLevel_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_RLOFOpticalFlowParameter_getMaxLevel_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_optflow_RLOFOpticalFlowParameter_setUseInitialFlow_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_RLOFOpticalFlowParameter_getUseInitialFlow_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_optflow_RLOFOpticalFlowParameter_setUseIlluminationModel_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_RLOFOpticalFlowParameter_getUseIlluminationModel_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_optflow_RLOFOpticalFlowParameter_setUseGlobalMotionPrior_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_RLOFOpticalFlowParameter_getUseGlobalMotionPrior_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_optflow_RLOFOpticalFlowParameter_setMaxIteration_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_RLOFOpticalFlowParameter_getMaxIteration_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_optflow_RLOFOpticalFlowParameter_setMinEigenValue_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_RLOFOpticalFlowParameter_getMinEigenValue_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_optflow_RLOFOpticalFlowParameter_setGlobalMotionRansacThreshold_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_RLOFOpticalFlowParameter_getGlobalMotionRansacThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_optflow_RLOFOpticalFlowParameter_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_RLOFOpticalFlowParameter_propSolverType_const(instance: *const c_void, ocvrs_return: *mut crate::optflow::SolverType);
		pub fn cv_optflow_RLOFOpticalFlowParameter_propSolverType_SolverType(instance: *mut c_void, val: crate::optflow::SolverType);
		pub fn cv_optflow_RLOFOpticalFlowParameter_propSupportRegionType_const(instance: *const c_void, ocvrs_return: *mut crate::optflow::SupportRegionType);
		pub fn cv_optflow_RLOFOpticalFlowParameter_propSupportRegionType_SupportRegionType(instance: *mut c_void, val: crate::optflow::SupportRegionType);
		pub fn cv_optflow_RLOFOpticalFlowParameter_propNormSigma0_const(instance: *const c_void) -> f32;
		pub fn cv_optflow_RLOFOpticalFlowParameter_propNormSigma0_float(instance: *mut c_void, val: f32);
		pub fn cv_optflow_RLOFOpticalFlowParameter_propNormSigma1_const(instance: *const c_void) -> f32;
		pub fn cv_optflow_RLOFOpticalFlowParameter_propNormSigma1_float(instance: *mut c_void, val: f32);
		pub fn cv_optflow_RLOFOpticalFlowParameter_propSmallWinSize_const(instance: *const c_void) -> i32;
		pub fn cv_optflow_RLOFOpticalFlowParameter_propSmallWinSize_int(instance: *mut c_void, val: i32);
		pub fn cv_optflow_RLOFOpticalFlowParameter_propLargeWinSize_const(instance: *const c_void) -> i32;
		pub fn cv_optflow_RLOFOpticalFlowParameter_propLargeWinSize_int(instance: *mut c_void, val: i32);
		pub fn cv_optflow_RLOFOpticalFlowParameter_propCrossSegmentationThreshold_const(instance: *const c_void) -> i32;
		pub fn cv_optflow_RLOFOpticalFlowParameter_propCrossSegmentationThreshold_int(instance: *mut c_void, val: i32);
		pub fn cv_optflow_RLOFOpticalFlowParameter_propMaxLevel_const(instance: *const c_void) -> i32;
		pub fn cv_optflow_RLOFOpticalFlowParameter_propMaxLevel_int(instance: *mut c_void, val: i32);
		pub fn cv_optflow_RLOFOpticalFlowParameter_propUseInitialFlow_const(instance: *const c_void) -> bool;
		pub fn cv_optflow_RLOFOpticalFlowParameter_propUseInitialFlow_bool(instance: *mut c_void, val: bool);
		pub fn cv_optflow_RLOFOpticalFlowParameter_propUseIlluminationModel_const(instance: *const c_void) -> bool;
		pub fn cv_optflow_RLOFOpticalFlowParameter_propUseIlluminationModel_bool(instance: *mut c_void, val: bool);
		pub fn cv_optflow_RLOFOpticalFlowParameter_propUseGlobalMotionPrior_const(instance: *const c_void) -> bool;
		pub fn cv_optflow_RLOFOpticalFlowParameter_propUseGlobalMotionPrior_bool(instance: *mut c_void, val: bool);
		pub fn cv_optflow_RLOFOpticalFlowParameter_propMaxIteration_const(instance: *const c_void) -> i32;
		pub fn cv_optflow_RLOFOpticalFlowParameter_propMaxIteration_int(instance: *mut c_void, val: i32);
		pub fn cv_optflow_RLOFOpticalFlowParameter_propMinEigenValue_const(instance: *const c_void) -> f32;
		pub fn cv_optflow_RLOFOpticalFlowParameter_propMinEigenValue_float(instance: *mut c_void, val: f32);
		pub fn cv_optflow_RLOFOpticalFlowParameter_propGlobalMotionRansacThreshold_const(instance: *const c_void) -> f32;
		pub fn cv_optflow_RLOFOpticalFlowParameter_propGlobalMotionRansacThreshold_float(instance: *mut c_void, val: f32);
		pub fn cv_optflow_RLOFOpticalFlowParameter_delete(instance: *mut c_void);
		pub fn cv_optflow_SparseRLOFOpticalFlow_setRLOFOpticalFlowParameter_PtrLRLOFOpticalFlowParameterG(instance: *mut c_void, val: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_SparseRLOFOpticalFlow_getRLOFOpticalFlowParameter_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_SparseRLOFOpticalFlow_setForwardBackward_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_optflow_SparseRLOFOpticalFlow_getForwardBackward_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_optflow_SparseRLOFOpticalFlow_create_PtrLRLOFOpticalFlowParameterG_float(rlof_param: *mut c_void, forward_backward_threshold: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_SparseRLOFOpticalFlow_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_optflow_SparseRLOFOpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_optflow_SparseRLOFOpticalFlow_to_SparseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_optflow_SparseRLOFOpticalFlow_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_optflow_DenseRLOFOpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_DenseRLOFOpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_DenseRLOFOpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_optflow_DenseRLOFOpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_DenseRLOFOpticalFlowG_to_PtrOfDenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_DualTVL1OpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_DualTVL1OpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_DualTVL1OpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_optflow_DualTVL1OpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_DualTVL1OpticalFlowG_to_PtrOfDenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_GPCTrainingSamplesG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_GPCTrainingSamplesG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_GPCTrainingSamplesG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_optflow_GPCTrainingSamplesG_new_const_GPCTrainingSamples(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_GPCTreeG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_GPCTreeG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_GPCTreeG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_optflow_GPCTreeG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_GPCTreeG_new_const_GPCTree(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_OpticalFlowPCAFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_OpticalFlowPCAFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_OpticalFlowPCAFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_optflow_OpticalFlowPCAFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_OpticalFlowPCAFlowG_to_PtrOfDenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_OpticalFlowPCAFlowG_new_const_OpticalFlowPCAFlow(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_PCAPriorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_PCAPriorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_PCAPriorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_optflow_PCAPriorG_new_const_PCAPrior(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_RLOFOpticalFlowParameterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_RLOFOpticalFlowParameterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_RLOFOpticalFlowParameterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_optflow_RLOFOpticalFlowParameterG_new_const_RLOFOpticalFlowParameter(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_SparseRLOFOpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_SparseRLOFOpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_SparseRLOFOpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_optflow_SparseRLOFOpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_optflow_SparseRLOFOpticalFlowG_to_PtrOfSparseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn std_vectorLcv_optflow_GPCPatchDescriptorG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_optflow_GPCPatchDescriptorG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_optflow_GPCPatchDescriptorG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_optflow_GPCPatchDescriptorG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_optflow_GPCPatchDescriptorG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_optflow_GPCPatchDescriptorG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_optflow_GPCPatchDescriptorG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_optflow_GPCPatchDescriptorG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_optflow_GPCPatchDescriptorG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_optflow_GPCPatchDescriptorG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_optflow_GPCPatchDescriptorG_push_const_GPCPatchDescriptor(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_optflow_GPCPatchDescriptorG_insert_size_t_const_GPCPatchDescriptor(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_optflow_GPCPatchDescriptorG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_optflow_GPCPatchDescriptorG_set_size_t_const_GPCPatchDescriptor(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_optflow_GPCPatchSampleG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_optflow_GPCPatchSampleG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_optflow_GPCPatchSampleG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_optflow_GPCPatchSampleG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_optflow_GPCPatchSampleG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_optflow_GPCPatchSampleG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_optflow_GPCPatchSampleG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_optflow_GPCPatchSampleG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_optflow_GPCPatchSampleG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_optflow_GPCPatchSampleG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_optflow_GPCPatchSampleG_push_const_GPCPatchSample(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_optflow_GPCPatchSampleG_insert_size_t_const_GPCPatchSample(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_optflow_GPCPatchSampleG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_optflow_GPCPatchSampleG_set_size_t_const_GPCPatchSample(instance: *mut c_void, index: size_t, val: *const c_void);
	}
}
#[cfg(ocvrs_has_module_optflow)]
pub use optflow_sys::*;

#[cfg(ocvrs_has_module_ovis)]
mod ovis_sys {
	use super::*;

	extern "C" {
		pub fn cv_ovis_addResourceLocation_const_StringR(path: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_createGridMesh_const_StringR_const_Size2fR(name: *const c_char, size: *const core::Size2f, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_createGridMesh_const_StringR_const_Size2fR_const_SizeR(name: *const c_char, size: *const core::Size2f, segments: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_createPlaneMesh_const_StringR_const_Size2fR(name: *const c_char, size: *const core::Size2f, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_createPlaneMesh_const_StringR_const_Size2fR_const__InputArrayR(name: *const c_char, size: *const core::Size2f, image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_createPointCloudMesh_const_StringR_const__InputArrayR(name: *const c_char, vertices: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_createPointCloudMesh_const_StringR_const__InputArrayR_const__InputArrayR(name: *const c_char, vertices: *const c_void, colors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_createTriangleMesh_const_StringR_const__InputArrayR(name: *const c_char, vertices: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_createTriangleMesh_const_StringR_const__InputArrayR_const__InputArrayR_const__InputArrayR(name: *const c_char, vertices: *const c_void, normals: *const c_void, indices: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_createWindow_const_StringR_const_SizeR(title: *const c_char, size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ovis_createWindow_const_StringR_const_SizeR_int(title: *const c_char, size: *const core::Size, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ovis_setMaterialProperty_const_StringR_const_StringR_const_ScalarR(name: *const c_char, prop: *const c_char, value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_setMaterialProperty_const_StringR_int_const_ScalarR(name: *const c_char, prop: i32, value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_setMaterialProperty_const_StringR_int_const_StringR(name: *const c_char, prop: i32, value: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_setMaterialProperty_const_StringR_int_const__InputArrayR(name: *const c_char, prop: i32, value: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_updateTexture_const_StringR_const__InputArrayR(name: *const c_char, image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_waitKey(ocvrs_return: *mut Result<i32>);
		pub fn cv_ovis_waitKey_int(delay: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_ovis_WindowScene_setBackground_const__InputArrayR(instance: *mut c_void, image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_setBackground_const_ScalarR(instance: *mut c_void, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_setCompositors_const_vectorLStringGR(instance: *mut c_void, names: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_createEntity_const_StringR_const_StringR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, name: *const c_char, meshname: *const c_char, tvec: *const c_void, rot: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_createEntity_const_StringR_const_StringR(instance: *mut c_void, name: *const c_char, meshname: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_removeEntity_const_StringR(instance: *mut c_void, name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_setEntityProperty_const_StringR_int_const_StringR_int(instance: *mut c_void, name: *const c_char, prop: i32, value: *const c_char, sub_entity_idx: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_setEntityProperty_const_StringR_int_const_StringR(instance: *mut c_void, name: *const c_char, prop: i32, value: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_setEntityProperty_const_StringR_int_const_ScalarR(instance: *mut c_void, name: *const c_char, prop: i32, value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_getEntityProperty_const_StringR_int_const__OutputArrayR(instance: *mut c_void, name: *const c_char, prop: i32, value: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_createCameraEntity_const_StringR_const__InputArrayR_const_SizeR_float_const__InputArrayR_const__InputArrayR_const_ScalarR(instance: *mut c_void, name: *const c_char, k: *const c_void, imsize: *const core::Size, z_far: f32, tvec: *const c_void, rot: *const c_void, color: *const core::Scalar, ocvrs_return: *mut Result<core::Rect2d>);
		pub fn cv_ovis_WindowScene_createCameraEntity_const_StringR_const__InputArrayR_const_SizeR_float(instance: *mut c_void, name: *const c_char, k: *const c_void, imsize: *const core::Size, z_far: f32, ocvrs_return: *mut Result<core::Rect2d>);
		pub fn cv_ovis_WindowScene_createLightEntity_const_StringR_const__InputArrayR_const__InputArrayR_const_ScalarR_const_ScalarR(instance: *mut c_void, name: *const c_char, tvec: *const c_void, rot: *const c_void, diffuse_color: *const core::Scalar, specular_color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_createLightEntity_const_StringR(instance: *mut c_void, name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_updateEntityPose_const_StringR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, name: *const c_char, tvec: *const c_void, rot: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_updateEntityPose_const_StringR(instance: *mut c_void, name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_setEntityPose_const_StringR_const__InputArrayR_const__InputArrayR_bool(instance: *mut c_void, name: *const c_char, tvec: *const c_void, rot: *const c_void, invert: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_setEntityPose_const_StringR(instance: *mut c_void, name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_getEntityPose_const_StringR_const__OutputArrayR_const__OutputArrayR_bool(instance: *mut c_void, name: *const c_char, r: *const c_void, tvec: *const c_void, invert: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_getEntityPose_const_StringR(instance: *mut c_void, name: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_getEntityAnimations_const_StringR_vectorLStringGR(instance: *mut c_void, name: *const c_char, out: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_playEntityAnimation_const_StringR_const_StringR_bool(instance: *mut c_void, name: *const c_char, animname: *const c_char, loop_: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_playEntityAnimation_const_StringR_const_StringR(instance: *mut c_void, name: *const c_char, animname: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_stopEntityAnimation_const_StringR_const_StringR(instance: *mut c_void, name: *const c_char, animname: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_getScreenshot_const__OutputArrayR(instance: *mut c_void, frame: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_getCompositorTexture_const_StringR_const_StringR_const__OutputArrayR_int(instance: *mut c_void, compname: *const c_char, texname: *const c_char, out: *const c_void, mrt_index: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_getCompositorTexture_const_StringR_const_StringR_const__OutputArrayR(instance: *mut c_void, compname: *const c_char, texname: *const c_char, out: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_getDepth_const__OutputArrayR(instance: *mut c_void, depth: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_fixCameraYawAxis_bool_const__InputArrayR(instance: *mut c_void, use_fixed: bool, up: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_fixCameraYawAxis_bool(instance: *mut c_void, use_fixed: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_setCameraPose_const__InputArrayR_const__InputArrayR_bool(instance: *mut c_void, tvec: *const c_void, rot: *const c_void, invert: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_setCameraPose(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_setCameraLookAt_const_StringR_const__InputArrayR(instance: *mut c_void, target: *const c_char, offset: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_setCameraLookAt_const_StringR(instance: *mut c_void, target: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_setEntityLookAt_const_StringR_const_StringR_const__InputArrayR(instance: *mut c_void, origin: *const c_char, target: *const c_char, offset: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_setEntityLookAt_const_StringR_const_StringR(instance: *mut c_void, origin: *const c_char, target: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_getCameraPose_const__OutputArrayR_const__OutputArrayR_bool(instance: *mut c_void, r: *const c_void, tvec: *const c_void, invert: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_getCameraPose(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_setCameraIntrinsics_const__InputArrayR_const_SizeR_float_float(instance: *mut c_void, k: *const c_void, imsize: *const core::Size, z_near: f32, z_far: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_setCameraIntrinsics_const__InputArrayR_const_SizeR(instance: *mut c_void, k: *const c_void, imsize: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_update(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ovis_WindowScene_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ovis_WindowSceneG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ovis_WindowSceneG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ovis_WindowSceneG_delete(instance: *mut c_void);
	}
}
#[cfg(ocvrs_has_module_ovis)]
pub use ovis_sys::*;

#[cfg(ocvrs_has_module_phase_unwrapping)]
mod phase_unwrapping_sys {
	use super::*;

	extern "C" {
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_create_const_ParamsR(parameters: *const crate::phase_unwrapping::HistogramPhaseUnwrapping_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_getInverseReliabilityMap_const__OutputArrayR(instance: *mut c_void, reliability_map: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_to_PhaseUnwrapping(instance: *mut c_void) -> *mut c_void;
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_delete(instance: *mut c_void);
		pub fn cv_phase_unwrapping_HistogramPhaseUnwrapping_Params_Params(ocvrs_return: *mut Result<crate::phase_unwrapping::HistogramPhaseUnwrapping_Params>);
		pub fn cv_phase_unwrapping_PhaseUnwrapping_unwrapPhaseMap_const__InputArrayR_const__OutputArrayR_const__InputArrayR(instance: *mut c_void, wrapped_phase_map: *const c_void, unwrapped_phase_map: *const c_void, shadow_mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_phase_unwrapping_PhaseUnwrapping_unwrapPhaseMap_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, wrapped_phase_map: *const c_void, unwrapped_phase_map: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_phase_unwrapping_PhaseUnwrapping_to_HistogramPhaseUnwrapping(instance: *mut c_void) -> *mut c_void;
		pub fn cv_phase_unwrapping_PhaseUnwrapping_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_phase_unwrapping_PhaseUnwrapping_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_phase_unwrapping_HistogramPhaseUnwrappingG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_phase_unwrapping_HistogramPhaseUnwrappingG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_phase_unwrapping_HistogramPhaseUnwrappingG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_phase_unwrapping_HistogramPhaseUnwrappingG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_phase_unwrapping_HistogramPhaseUnwrappingG_to_PtrOfPhaseUnwrapping(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_phase_unwrapping_PhaseUnwrappingG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_phase_unwrapping_PhaseUnwrappingG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_phase_unwrapping_PhaseUnwrappingG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_phase_unwrapping_PhaseUnwrappingG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_phase_unwrapping)]
pub use phase_unwrapping_sys::*;

#[cfg(ocvrs_has_module_photo)]
mod photo_sys {
	use super::*;

	extern "C" {
		pub fn cv_colorChange_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src: *const c_void, mask: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_colorChange_const__InputArrayR_const__InputArrayR_const__OutputArrayR_float_float_float(src: *const c_void, mask: *const c_void, dst: *const c_void, red_mul: f32, green_mul: f32, blue_mul: f32, ocvrs_return: *mut Result_void);
		pub fn cv_createAlignMTB(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createAlignMTB_int_int_bool(max_bits: i32, exclude_range: i32, cut: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createCalibrateDebevec(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createCalibrateDebevec_int_float_bool(samples: i32, lambda: f32, random: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createCalibrateRobertson(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createCalibrateRobertson_int_float(max_iter: i32, threshold: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createMergeDebevec(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createMergeMertens(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createMergeMertens_float_float_float(contrast_weight: f32, saturation_weight: f32, exposure_weight: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createMergeRobertson(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createTonemap(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createTonemapDrago(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createTonemapDrago_float_float_float(gamma: f32, saturation: f32, bias: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createTonemapMantiuk(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createTonemapMantiuk_float_float_float(gamma: f32, scale: f32, saturation: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createTonemapReinhard(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createTonemapReinhard_float_float_float_float(gamma: f32, intensity: f32, light_adapt: f32, color_adapt: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createTonemap_float(gamma: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_fastNlMeansDenoisingColored_const_GpuMatR_GpuMatR_float_float(src: *const c_void, dst: *mut c_void, h_luminance: f32, photo_render: f32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_fastNlMeansDenoisingColored_const_GpuMatR_GpuMatR_float_float_int_int_StreamR(src: *const c_void, dst: *mut c_void, h_luminance: f32, photo_render: f32, search_window: i32, block_size: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_fastNlMeansDenoisingColored_const__InputArrayR_const__OutputArrayR_float_float(src: *const c_void, dst: *const c_void, h_luminance: f32, photo_render: f32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_fastNlMeansDenoisingColored_const__InputArrayR_const__OutputArrayR_float_float_int_int_StreamR(src: *const c_void, dst: *const c_void, h_luminance: f32, photo_render: f32, search_window: i32, block_size: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_fastNlMeansDenoising_const_GpuMatR_GpuMatR_float(src: *const c_void, dst: *mut c_void, h: f32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_fastNlMeansDenoising_const_GpuMatR_GpuMatR_float_int_int_StreamR(src: *const c_void, dst: *mut c_void, h: f32, search_window: i32, block_size: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_fastNlMeansDenoising_const__InputArrayR_const__OutputArrayR_float(src: *const c_void, dst: *const c_void, h: f32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_fastNlMeansDenoising_const__InputArrayR_const__OutputArrayR_float_int_int_StreamR(src: *const c_void, dst: *const c_void, h: f32, search_window: i32, block_size: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_nonLocalMeans_const_GpuMatR_GpuMatR_float(src: *const c_void, dst: *mut c_void, h: f32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_nonLocalMeans_const_GpuMatR_GpuMatR_float_int_int_int_StreamR(src: *const c_void, dst: *mut c_void, h: f32, search_window: i32, block_size: i32, border_mode: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_nonLocalMeans_const__InputArrayR_const__OutputArrayR_float(src: *const c_void, dst: *const c_void, h: f32, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_nonLocalMeans_const__InputArrayR_const__OutputArrayR_float_int_int_int_StreamR(src: *const c_void, dst: *const c_void, h: f32, search_window: i32, block_size: i32, border_mode: i32, stream: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_decolor_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, grayscale: *const c_void, color_boost: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_denoise_TVL1_const_vectorLMatGR_MatR(observations: *const c_void, result: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_denoise_TVL1_const_vectorLMatGR_MatR_double_int(observations: *const c_void, result: *mut c_void, lambda: f64, niters: i32, ocvrs_return: *mut Result_void);
		pub fn cv_detailEnhance_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detailEnhance_const__InputArrayR_const__OutputArrayR_float_float(src: *const c_void, dst: *const c_void, sigma_s: f32, sigma_r: f32, ocvrs_return: *mut Result_void);
		pub fn cv_edgePreservingFilter_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_edgePreservingFilter_const__InputArrayR_const__OutputArrayR_int_float_float(src: *const c_void, dst: *const c_void, flags: i32, sigma_s: f32, sigma_r: f32, ocvrs_return: *mut Result_void);
		pub fn cv_fastNlMeansDenoisingColoredMulti_const__InputArrayR_const__OutputArrayR_int_int(src_imgs: *const c_void, dst: *const c_void, img_to_denoise_index: i32, temporal_window_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fastNlMeansDenoisingColoredMulti_const__InputArrayR_const__OutputArrayR_int_int_float_float_int_int(src_imgs: *const c_void, dst: *const c_void, img_to_denoise_index: i32, temporal_window_size: i32, h: f32, h_color: f32, template_window_size: i32, search_window_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fastNlMeansDenoisingColored_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_fastNlMeansDenoisingColored_const__InputArrayR_const__OutputArrayR_float_float_int_int(src: *const c_void, dst: *const c_void, h: f32, h_color: f32, template_window_size: i32, search_window_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fastNlMeansDenoisingMulti_const__InputArrayR_const__OutputArrayR_int_int(src_imgs: *const c_void, dst: *const c_void, img_to_denoise_index: i32, temporal_window_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fastNlMeansDenoisingMulti_const__InputArrayR_const__OutputArrayR_int_int_const_vectorLfloatGR(src_imgs: *const c_void, dst: *const c_void, img_to_denoise_index: i32, temporal_window_size: i32, h: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_fastNlMeansDenoisingMulti_const__InputArrayR_const__OutputArrayR_int_int_const_vectorLfloatGR_int_int_int(src_imgs: *const c_void, dst: *const c_void, img_to_denoise_index: i32, temporal_window_size: i32, h: *const c_void, template_window_size: i32, search_window_size: i32, norm_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fastNlMeansDenoisingMulti_const__InputArrayR_const__OutputArrayR_int_int_float_int_int(src_imgs: *const c_void, dst: *const c_void, img_to_denoise_index: i32, temporal_window_size: i32, h: f32, template_window_size: i32, search_window_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fastNlMeansDenoising_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_fastNlMeansDenoising_const__InputArrayR_const__OutputArrayR_const_vectorLfloatGR(src: *const c_void, dst: *const c_void, h: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_fastNlMeansDenoising_const__InputArrayR_const__OutputArrayR_const_vectorLfloatGR_int_int_int(src: *const c_void, dst: *const c_void, h: *const c_void, template_window_size: i32, search_window_size: i32, norm_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_fastNlMeansDenoising_const__InputArrayR_const__OutputArrayR_float_int_int(src: *const c_void, dst: *const c_void, h: f32, template_window_size: i32, search_window_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_illuminationChange_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src: *const c_void, mask: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_illuminationChange_const__InputArrayR_const__InputArrayR_const__OutputArrayR_float_float(src: *const c_void, mask: *const c_void, dst: *const c_void, alpha: f32, beta: f32, ocvrs_return: *mut Result_void);
		pub fn cv_inpaint_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_int(src: *const c_void, inpaint_mask: *const c_void, dst: *const c_void, inpaint_radius: f64, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_pencilSketch_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, dst1: *const c_void, dst2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_pencilSketch_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_float_float_float(src: *const c_void, dst1: *const c_void, dst2: *const c_void, sigma_s: f32, sigma_r: f32, shade_factor: f32, ocvrs_return: *mut Result_void);
		pub fn cv_seamlessClone_const__InputArrayR_const__InputArrayR_const__InputArrayR_Point_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, mask: *const c_void, p: *const core::Point, blend: *const c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_stylization_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_stylization_const__InputArrayR_const__OutputArrayR_float_float(src: *const c_void, dst: *const c_void, sigma_s: f32, sigma_r: f32, ocvrs_return: *mut Result_void);
		pub fn cv_textureFlattening_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src: *const c_void, mask: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_textureFlattening_const__InputArrayR_const__InputArrayR_const__OutputArrayR_float_float_int(src: *const c_void, mask: *const c_void, dst: *const c_void, low_threshold: f32, high_threshold: f32, kernel_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_AlignExposures_process_const__InputArrayR_vectorLMatGR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *mut c_void, times: *const c_void, response: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_AlignExposures_to_AlignMTB(instance: *mut c_void) -> *mut c_void;
		pub fn cv_AlignExposures_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_AlignExposures_delete(instance: *mut c_void);
		pub fn cv_AlignMTB_process_const__InputArrayR_vectorLMatGR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *mut c_void, times: *const c_void, response: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_AlignMTB_process_const__InputArrayR_vectorLMatGR(instance: *mut c_void, src: *const c_void, dst: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_AlignMTB_calculateShift_const__InputArrayR_const__InputArrayR(instance: *mut c_void, img0: *const c_void, img1: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_AlignMTB_shiftMat_const__InputArrayR_const__OutputArrayR_const_Point(instance: *mut c_void, src: *const c_void, dst: *const c_void, shift: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_AlignMTB_computeBitmaps_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, img: *const c_void, tb: *const c_void, eb: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_AlignMTB_getMaxBits_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_AlignMTB_setMaxBits_int(instance: *mut c_void, max_bits: i32, ocvrs_return: *mut Result_void);
		pub fn cv_AlignMTB_getExcludeRange_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_AlignMTB_setExcludeRange_int(instance: *mut c_void, exclude_range: i32, ocvrs_return: *mut Result_void);
		pub fn cv_AlignMTB_getCut_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_AlignMTB_setCut_bool(instance: *mut c_void, value: bool, ocvrs_return: *mut Result_void);
		pub fn cv_AlignMTB_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_AlignMTB_to_AlignExposures(instance: *mut c_void) -> *mut c_void;
		pub fn cv_AlignMTB_delete(instance: *mut c_void);
		pub fn cv_CalibrateCRF_process_const__InputArrayR_const__OutputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, times: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_CalibrateCRF_to_CalibrateDebevec(instance: *mut c_void) -> *mut c_void;
		pub fn cv_CalibrateCRF_to_CalibrateRobertson(instance: *mut c_void) -> *mut c_void;
		pub fn cv_CalibrateCRF_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_CalibrateCRF_delete(instance: *mut c_void);
		pub fn cv_CalibrateDebevec_getLambda_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_CalibrateDebevec_setLambda_float(instance: *mut c_void, lambda: f32, ocvrs_return: *mut Result_void);
		pub fn cv_CalibrateDebevec_getSamples_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_CalibrateDebevec_setSamples_int(instance: *mut c_void, samples: i32, ocvrs_return: *mut Result_void);
		pub fn cv_CalibrateDebevec_getRandom_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_CalibrateDebevec_setRandom_bool(instance: *mut c_void, random: bool, ocvrs_return: *mut Result_void);
		pub fn cv_CalibrateDebevec_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_CalibrateDebevec_to_CalibrateCRF(instance: *mut c_void) -> *mut c_void;
		pub fn cv_CalibrateDebevec_delete(instance: *mut c_void);
		pub fn cv_CalibrateRobertson_getMaxIter_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_CalibrateRobertson_setMaxIter_int(instance: *mut c_void, max_iter: i32, ocvrs_return: *mut Result_void);
		pub fn cv_CalibrateRobertson_getThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_CalibrateRobertson_setThreshold_float(instance: *mut c_void, threshold: f32, ocvrs_return: *mut Result_void);
		pub fn cv_CalibrateRobertson_getRadiance_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CalibrateRobertson_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_CalibrateRobertson_to_CalibrateCRF(instance: *mut c_void) -> *mut c_void;
		pub fn cv_CalibrateRobertson_delete(instance: *mut c_void);
		pub fn cv_MergeDebevec_process_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, times: *const c_void, response: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MergeDebevec_process_const__InputArrayR_const__OutputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, times: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MergeDebevec_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MergeDebevec_to_MergeExposures(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MergeDebevec_delete(instance: *mut c_void);
		pub fn cv_MergeExposures_process_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, times: *const c_void, response: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MergeExposures_to_MergeDebevec(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MergeExposures_to_MergeMertens(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MergeExposures_to_MergeRobertson(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MergeExposures_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MergeExposures_delete(instance: *mut c_void);
		pub fn cv_MergeMertens_process_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, times: *const c_void, response: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MergeMertens_process_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MergeMertens_getContrastWeight_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_MergeMertens_setContrastWeight_float(instance: *mut c_void, contrast_weiht: f32, ocvrs_return: *mut Result_void);
		pub fn cv_MergeMertens_getSaturationWeight_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_MergeMertens_setSaturationWeight_float(instance: *mut c_void, saturation_weight: f32, ocvrs_return: *mut Result_void);
		pub fn cv_MergeMertens_getExposureWeight_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_MergeMertens_setExposureWeight_float(instance: *mut c_void, exposure_weight: f32, ocvrs_return: *mut Result_void);
		pub fn cv_MergeMertens_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MergeMertens_to_MergeExposures(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MergeMertens_delete(instance: *mut c_void);
		pub fn cv_MergeRobertson_process_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, times: *const c_void, response: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MergeRobertson_process_const__InputArrayR_const__OutputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, times: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_MergeRobertson_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MergeRobertson_to_MergeExposures(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MergeRobertson_delete(instance: *mut c_void);
		pub fn cv_Tonemap_process_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Tonemap_getGamma_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_Tonemap_setGamma_float(instance: *mut c_void, gamma: f32, ocvrs_return: *mut Result_void);
		pub fn cv_Tonemap_to_TonemapDrago(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Tonemap_to_TonemapMantiuk(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Tonemap_to_TonemapReinhard(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Tonemap_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Tonemap_delete(instance: *mut c_void);
		pub fn cv_TonemapDrago_getSaturation_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_TonemapDrago_setSaturation_float(instance: *mut c_void, saturation: f32, ocvrs_return: *mut Result_void);
		pub fn cv_TonemapDrago_getBias_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_TonemapDrago_setBias_float(instance: *mut c_void, bias: f32, ocvrs_return: *mut Result_void);
		pub fn cv_TonemapDrago_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_TonemapDrago_to_Tonemap(instance: *mut c_void) -> *mut c_void;
		pub fn cv_TonemapDrago_delete(instance: *mut c_void);
		pub fn cv_TonemapMantiuk_getScale_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_TonemapMantiuk_setScale_float(instance: *mut c_void, scale: f32, ocvrs_return: *mut Result_void);
		pub fn cv_TonemapMantiuk_getSaturation_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_TonemapMantiuk_setSaturation_float(instance: *mut c_void, saturation: f32, ocvrs_return: *mut Result_void);
		pub fn cv_TonemapMantiuk_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_TonemapMantiuk_to_Tonemap(instance: *mut c_void) -> *mut c_void;
		pub fn cv_TonemapMantiuk_delete(instance: *mut c_void);
		pub fn cv_TonemapReinhard_getIntensity_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_TonemapReinhard_setIntensity_float(instance: *mut c_void, intensity: f32, ocvrs_return: *mut Result_void);
		pub fn cv_TonemapReinhard_getLightAdaptation_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_TonemapReinhard_setLightAdaptation_float(instance: *mut c_void, light_adapt: f32, ocvrs_return: *mut Result_void);
		pub fn cv_TonemapReinhard_getColorAdaptation_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_TonemapReinhard_setColorAdaptation_float(instance: *mut c_void, color_adapt: f32, ocvrs_return: *mut Result_void);
		pub fn cv_TonemapReinhard_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_TonemapReinhard_to_Tonemap(instance: *mut c_void) -> *mut c_void;
		pub fn cv_TonemapReinhard_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_AlignExposuresG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AlignExposuresG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AlignExposuresG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_AlignExposuresG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AlignMTBG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AlignMTBG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AlignMTBG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_AlignMTBG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AlignMTBG_to_PtrOfAlignExposures(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CalibrateCRFG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CalibrateCRFG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CalibrateCRFG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_CalibrateCRFG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CalibrateDebevecG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CalibrateDebevecG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CalibrateDebevecG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_CalibrateDebevecG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CalibrateDebevecG_to_PtrOfCalibrateCRF(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CalibrateRobertsonG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CalibrateRobertsonG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CalibrateRobertsonG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_CalibrateRobertsonG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CalibrateRobertsonG_to_PtrOfCalibrateCRF(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MergeDebevecG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MergeDebevecG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MergeDebevecG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_MergeDebevecG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MergeDebevecG_to_PtrOfMergeExposures(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MergeExposuresG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MergeExposuresG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MergeExposuresG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_MergeExposuresG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MergeMertensG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MergeMertensG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MergeMertensG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_MergeMertensG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MergeMertensG_to_PtrOfMergeExposures(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MergeRobertsonG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MergeRobertsonG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MergeRobertsonG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_MergeRobertsonG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MergeRobertsonG_to_PtrOfMergeExposures(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TonemapG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TonemapG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TonemapG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_TonemapG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TonemapDragoG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TonemapDragoG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TonemapDragoG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_TonemapDragoG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TonemapDragoG_to_PtrOfTonemap(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TonemapMantiukG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TonemapMantiukG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TonemapMantiukG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_TonemapMantiukG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TonemapMantiukG_to_PtrOfTonemap(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TonemapReinhardG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TonemapReinhardG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TonemapReinhardG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_TonemapReinhardG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TonemapReinhardG_to_PtrOfTonemap(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_photo)]
pub use photo_sys::*;

#[cfg(ocvrs_has_module_plot)]
mod plot_sys {
	use super::*;

	extern "C" {
		pub fn cv_plot_Plot2d_setMinX_double(instance: *mut c_void, _plot_min_x: f64, ocvrs_return: *mut Result_void);
		pub fn cv_plot_Plot2d_setMinY_double(instance: *mut c_void, _plot_min_y: f64, ocvrs_return: *mut Result_void);
		pub fn cv_plot_Plot2d_setMaxX_double(instance: *mut c_void, _plot_max_x: f64, ocvrs_return: *mut Result_void);
		pub fn cv_plot_Plot2d_setMaxY_double(instance: *mut c_void, _plot_max_y: f64, ocvrs_return: *mut Result_void);
		pub fn cv_plot_Plot2d_setPlotLineWidth_int(instance: *mut c_void, _plot_line_width: i32, ocvrs_return: *mut Result_void);
		pub fn cv_plot_Plot2d_setNeedPlotLine_bool(instance: *mut c_void, _need_plot_line: bool, ocvrs_return: *mut Result_void);
		pub fn cv_plot_Plot2d_setPlotLineColor_Scalar(instance: *mut c_void, _plot_line_color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_plot_Plot2d_setPlotBackgroundColor_Scalar(instance: *mut c_void, _plot_background_color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_plot_Plot2d_setPlotAxisColor_Scalar(instance: *mut c_void, _plot_axis_color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_plot_Plot2d_setPlotGridColor_Scalar(instance: *mut c_void, _plot_grid_color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_plot_Plot2d_setPlotTextColor_Scalar(instance: *mut c_void, _plot_text_color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_plot_Plot2d_setPlotSize_int_int(instance: *mut c_void, _plot_size_width: i32, _plot_size_height: i32, ocvrs_return: *mut Result_void);
		pub fn cv_plot_Plot2d_setShowGrid_bool(instance: *mut c_void, need_show_grid: bool, ocvrs_return: *mut Result_void);
		pub fn cv_plot_Plot2d_setShowText_bool(instance: *mut c_void, need_show_text: bool, ocvrs_return: *mut Result_void);
		pub fn cv_plot_Plot2d_setGridLinesNumber_int(instance: *mut c_void, grid_lines_number: i32, ocvrs_return: *mut Result_void);
		pub fn cv_plot_Plot2d_setInvertOrientation_bool(instance: *mut c_void, _invert_orientation: bool, ocvrs_return: *mut Result_void);
		pub fn cv_plot_Plot2d_setPointIdxToPrint_int(instance: *mut c_void, point_idx: i32, ocvrs_return: *mut Result_void);
		pub fn cv_plot_Plot2d_render_const__OutputArrayR(instance: *mut c_void, _plot_result: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_plot_Plot2d_create_const__InputArrayR(data: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_plot_Plot2d_create_const__InputArrayR_const__InputArrayR(data_x: *const c_void, data_y: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_plot_Plot2d_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_plot_Plot2d_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_plot_Plot2dG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_plot_Plot2dG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_plot_Plot2dG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_plot_Plot2dG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_plot)]
pub use plot_sys::*;

#[cfg(ocvrs_has_module_quality)]
mod quality_sys {
	use super::*;

	extern "C" {
		pub fn cv_quality_QualityBRISQUE_compute_const__InputArrayR(instance: *mut c_void, img: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_quality_QualityBRISQUE_create_const_StringR_const_StringR(model_file_path: *const c_char, range_file_path: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_quality_QualityBRISQUE_create_const_PtrLSVMGR_const_MatR(model: *const c_void, range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_quality_QualityBRISQUE_compute_const__InputArrayR_const_StringR_const_StringR(img: *const c_void, model_file_path: *const c_char, range_file_path: *const c_char, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_quality_QualityBRISQUE_computeFeatures_const__InputArrayR_const__OutputArrayR(img: *const c_void, features: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_quality_QualityBRISQUE_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_quality_QualityBRISQUE_to_QualityBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_quality_QualityBRISQUE_delete(instance: *mut c_void);
		pub fn cv_quality_QualityBase_compute_const__InputArrayR(instance: *mut c_void, img: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_quality_QualityBase_getQualityMap_const_const__OutputArrayR(instance: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_quality_QualityBase_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_quality_QualityBase_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_quality_QualityBase_to_QualityBRISQUE(instance: *mut c_void) -> *mut c_void;
		pub fn cv_quality_QualityBase_to_QualityGMSD(instance: *mut c_void) -> *mut c_void;
		pub fn cv_quality_QualityBase_to_QualityMSE(instance: *mut c_void) -> *mut c_void;
		pub fn cv_quality_QualityBase_to_QualityPSNR(instance: *mut c_void) -> *mut c_void;
		pub fn cv_quality_QualityBase_to_QualitySSIM(instance: *mut c_void) -> *mut c_void;
		pub fn cv_quality_QualityBase_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_quality_QualityBase_delete(instance: *mut c_void);
		pub fn cv_quality_QualityGMSD_compute_const__InputArrayR(instance: *mut c_void, cmp: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_quality_QualityGMSD_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_quality_QualityGMSD_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_quality_QualityGMSD_create_const__InputArrayR(ref_: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_quality_QualityGMSD_compute_const__InputArrayR_const__InputArrayR_const__OutputArrayR(ref_: *const c_void, cmp: *const c_void, quality_map: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_quality_QualityGMSD_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_quality_QualityGMSD_to_QualityBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_quality_QualityGMSD_delete(instance: *mut c_void);
		pub fn cv_quality_QualityMSE_compute_const__InputArrayR(instance: *mut c_void, cmp_imgs: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_quality_QualityMSE_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_quality_QualityMSE_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_quality_QualityMSE_create_const__InputArrayR(ref_: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_quality_QualityMSE_compute_const__InputArrayR_const__InputArrayR_const__OutputArrayR(ref_: *const c_void, cmp: *const c_void, quality_map: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_quality_QualityMSE_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_quality_QualityMSE_to_QualityBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_quality_QualityMSE_delete(instance: *mut c_void);
		pub fn cv_quality_QualityPSNR_create_const__InputArrayR_double(ref_: *const c_void, max_pixel_value: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_quality_QualityPSNR_create_const__InputArrayR(ref_: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_quality_QualityPSNR_compute_const__InputArrayR(instance: *mut c_void, cmp: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_quality_QualityPSNR_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_quality_QualityPSNR_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_quality_QualityPSNR_compute_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double(ref_: *const c_void, cmp: *const c_void, quality_map: *const c_void, max_pixel_value: f64, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_quality_QualityPSNR_compute_const__InputArrayR_const__InputArrayR_const__OutputArrayR(ref_: *const c_void, cmp: *const c_void, quality_map: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_quality_QualityPSNR_getMaxPixelValue_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_quality_QualityPSNR_setMaxPixelValue_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_quality_QualityPSNR_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_quality_QualityPSNR_to_QualityBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_quality_QualityPSNR_delete(instance: *mut c_void);
		pub fn cv_quality_QualitySSIM_compute_const__InputArrayR(instance: *mut c_void, cmp: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_quality_QualitySSIM_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_quality_QualitySSIM_clear(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_quality_QualitySSIM_create_const__InputArrayR(ref_: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_quality_QualitySSIM_compute_const__InputArrayR_const__InputArrayR_const__OutputArrayR(ref_: *const c_void, cmp: *const c_void, quality_map: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_quality_QualitySSIM_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_quality_QualitySSIM_to_QualityBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_quality_QualitySSIM_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_quality_QualityBRISQUEG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityBRISQUEG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityBRISQUEG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_quality_QualityBRISQUEG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityBRISQUEG_to_PtrOfQualityBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityBRISQUEG_new_const_QualityBRISQUE(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityBaseG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityBaseG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityBaseG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_quality_QualityBaseG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityGMSDG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityGMSDG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityGMSDG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_quality_QualityGMSDG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityGMSDG_to_PtrOfQualityBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityGMSDG_new_const_QualityGMSD(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityMSEG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityMSEG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityMSEG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_quality_QualityMSEG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityMSEG_to_PtrOfQualityBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityMSEG_new_const_QualityMSE(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityPSNRG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityPSNRG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityPSNRG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_quality_QualityPSNRG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityPSNRG_to_PtrOfQualityBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualityPSNRG_new_const_QualityPSNR(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualitySSIMG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualitySSIMG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualitySSIMG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_quality_QualitySSIMG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualitySSIMG_to_PtrOfQualityBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_quality_QualitySSIMG_new_const_QualitySSIM(val: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_quality)]
pub use quality_sys::*;

#[cfg(ocvrs_has_module_rapid)]
mod rapid_sys {
	use super::*;

	extern "C" {
		pub fn cv_rapid_convertCorrespondencies_const__InputArrayR_const__InputArrayR_const__OutputArrayR(cols: *const c_void, src_locations: *const c_void, pts2d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rapid_convertCorrespondencies_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputOutputArrayR_const__InputArrayR(cols: *const c_void, src_locations: *const c_void, pts2d: *const c_void, pts3d: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rapid_drawCorrespondencies_const__InputOutputArrayR_const__InputArrayR(bundle: *const c_void, cols: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rapid_drawCorrespondencies_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR(bundle: *const c_void, cols: *const c_void, colors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rapid_drawSearchLines_const__InputOutputArrayR_const__InputArrayR_const_ScalarR(img: *const c_void, locations: *const c_void, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_rapid_drawWireframe_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR_const_ScalarR(img: *const c_void, pts2d: *const c_void, tris: *const c_void, color: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_rapid_drawWireframe_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR_const_ScalarR_int_bool(img: *const c_void, pts2d: *const c_void, tris: *const c_void, color: *const core::Scalar, typ: i32, cull_backface: bool, ocvrs_return: *mut Result_void);
		pub fn cv_rapid_extractControlPoints_int_int_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_SizeR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(num: i32, len: i32, pts3d: *const c_void, rvec: *const c_void, tvec: *const c_void, k: *const c_void, imsize: *const core::Size, tris: *const c_void, ctl2d: *const c_void, ctl3d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rapid_extractLineBundle_int_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(len: i32, ctl2d: *const c_void, img: *const c_void, bundle: *const c_void, src_locations: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rapid_findCorrespondencies_const__InputArrayR_const__OutputArrayR(bundle: *const c_void, cols: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rapid_findCorrespondencies_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(bundle: *const c_void, cols: *const c_void, response: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rapid_rapid_const__InputArrayR_int_int_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(img: *const c_void, num: i32, len: i32, pts3d: *const c_void, tris: *const c_void, k: *const c_void, rvec: *const c_void, tvec: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_rapid_rapid_const__InputArrayR_int_int_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_doubleX(img: *const c_void, num: i32, len: i32, pts3d: *const c_void, tris: *const c_void, k: *const c_void, rvec: *const c_void, tvec: *const c_void, rmsd: *mut f64, ocvrs_return: *mut Result<f32>);
		pub fn cv_rapid_GOSTracker_create_const__InputArrayR_const__InputArrayR_int_unsigned_char(pts3d: *const c_void, tris: *const c_void, hist_bins: i32, sobel_thesh: u8, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rapid_GOSTracker_create_const__InputArrayR_const__InputArrayR(pts3d: *const c_void, tris: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rapid_GOSTracker_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rapid_GOSTracker_to_Rapid_Tracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rapid_GOSTracker_delete(instance: *mut c_void);
		pub fn cv_rapid_OLSTracker_create_const__InputArrayR_const__InputArrayR_int_unsigned_char(pts3d: *const c_void, tris: *const c_void, hist_bins: i32, sobel_thesh: u8, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rapid_OLSTracker_create_const__InputArrayR_const__InputArrayR(pts3d: *const c_void, tris: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rapid_OLSTracker_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rapid_OLSTracker_to_Rapid_Tracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rapid_OLSTracker_delete(instance: *mut c_void);
		pub fn cv_rapid_Rapid_create_const__InputArrayR_const__InputArrayR(pts3d: *const c_void, tris: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rapid_Rapid_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rapid_Rapid_to_Rapid_Tracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rapid_Rapid_delete(instance: *mut c_void);
		pub fn cv_rapid_Tracker_compute_const__InputArrayR_int_int_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const_TermCriteriaR(instance: *mut c_void, img: *const c_void, num: i32, len: i32, k: *const c_void, rvec: *const c_void, tvec: *const c_void, termcrit: *const core::TermCriteria, ocvrs_return: *mut Result<f32>);
		pub fn cv_rapid_Tracker_compute_const__InputArrayR_int_int_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(instance: *mut c_void, img: *const c_void, num: i32, len: i32, k: *const c_void, rvec: *const c_void, tvec: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_rapid_Tracker_clearState(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rapid_Tracker_to_Rapid_GOSTracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rapid_Tracker_to_Rapid_OLSTracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rapid_Tracker_to_Rapid_Rapid(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rapid_Tracker_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rapid_Tracker_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_rapid_GOSTrackerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rapid_GOSTrackerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rapid_GOSTrackerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_rapid_GOSTrackerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rapid_GOSTrackerG_to_PtrOfRapid_Tracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rapid_OLSTrackerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rapid_OLSTrackerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rapid_OLSTrackerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_rapid_OLSTrackerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rapid_OLSTrackerG_to_PtrOfRapid_Tracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rapid_RapidG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rapid_RapidG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rapid_RapidG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_rapid_RapidG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rapid_RapidG_to_PtrOfRapid_Tracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rapid_TrackerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rapid_TrackerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rapid_TrackerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_rapid_TrackerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_rapid)]
pub use rapid_sys::*;

#[cfg(ocvrs_has_module_rgbd)]
mod rgbd_sys {
	use super::*;

	extern "C" {
		pub fn cv_kinfu_makeVolume_VolumeType_float_Matx44f_float_float_int_float_Vec3i(_volume_type: crate::rgbd::Kinfu_VolumeType, _voxel_size: f32, _pose: *const core::Matx44f, _raycast_step_factor: f32, _trunc_dist: f32, _max_weight: i32, _truncate_threshold: f32, _resolution: *const core::Vec3i, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_colormap_const_MatR_MatR(quantized: *const c_void, dst: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_drawFeatures_const__InputOutputArrayR_const_vectorLTemplateGR_const_Point2iR(img: *const c_void, templates: *const c_void, tl: *const core::Point2i, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_drawFeatures_const__InputOutputArrayR_const_vectorLTemplateGR_const_Point2iR_int(img: *const c_void, templates: *const c_void, tl: *const core::Point2i, size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_getDefaultLINE(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_getDefaultLINEMOD(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_depthTo3dSparse_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(depth: *const c_void, in_k: *const c_void, in_points: *const c_void, points3d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_depthTo3d_const__InputArrayR_const__InputArrayR_const__OutputArrayR(depth: *const c_void, k: *const c_void, points3d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_depthTo3d_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR(depth: *const c_void, k: *const c_void, points3d: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_isValidDepth_const_doubleR(depth: *const f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_rgbd_isValidDepth_const_floatR(depth: *const f32, ocvrs_return: *mut Result<bool>);
		pub fn cv_rgbd_isValidDepth_const_intR(depth: *const i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_rgbd_isValidDepth_const_shortR(depth: *const i16, ocvrs_return: *mut Result<bool>);
		pub fn cv_rgbd_isValidDepth_const_unsigned_intR(depth: *const u32, ocvrs_return: *mut Result<bool>);
		pub fn cv_rgbd_isValidDepth_const_unsigned_shortR(depth: *const u16, ocvrs_return: *mut Result<bool>);
		pub fn cv_rgbd_registerDepth_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_SizeR_const__OutputArrayR(unregistered_camera_matrix: *const c_void, registered_camera_matrix: *const c_void, registered_dist_coeffs: *const c_void, rt: *const c_void, unregistered_depth: *const c_void, output_image_plane_size: *const core::Size, registered_depth: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_registerDepth_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const_SizeR_const__OutputArrayR_bool(unregistered_camera_matrix: *const c_void, registered_camera_matrix: *const c_void, registered_dist_coeffs: *const c_void, rt: *const c_void, unregistered_depth: *const c_void, output_image_plane_size: *const core::Size, registered_depth: *const c_void, depth_dilation: bool, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_rescaleDepth_const__InputArrayR_int_const__OutputArrayR(in_: *const c_void, depth: i32, out: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_rescaleDepth_const__InputArrayR_int_const__OutputArrayR_double(in_: *const c_void, depth: i32, out: *const c_void, depth_factor: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_warpFrame_const_MatR_const_MatR_const_MatR_const_MatR_const_MatR_const_MatR_const__OutputArrayR(image: *const c_void, depth: *const c_void, mask: *const c_void, rt: *const c_void, camera_matrix: *const c_void, dist_coeff: *const c_void, warped_image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_warpFrame_const_MatR_const_MatR_const_MatR_const_MatR_const_MatR_const_MatR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(image: *const c_void, depth: *const c_void, mask: *const c_void, rt: *const c_void, camera_matrix: *const c_void, dist_coeff: *const c_void, warped_image: *const c_void, warped_depth: *const c_void, warped_mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_colored_kinfu_ColoredKinFu_create_const_PtrLParamsGR(_params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_colored_kinfu_ColoredKinFu_getParams_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_colored_kinfu_ColoredKinFu_render_const_const__OutputArrayR(instance: *const c_void, image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_colored_kinfu_ColoredKinFu_render_const_const__OutputArrayR_const_Matx44fR(instance: *const c_void, image: *const c_void, camera_pose: *const core::Matx44f, ocvrs_return: *mut Result_void);
		pub fn cv_colored_kinfu_ColoredKinFu_getCloud_const_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, points: *const c_void, normals: *const c_void, colors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_colored_kinfu_ColoredKinFu_getCloud_const_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, points: *const c_void, normals: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_colored_kinfu_ColoredKinFu_getPoints_const_const__OutputArrayR(instance: *const c_void, points: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_colored_kinfu_ColoredKinFu_getNormals_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, points: *const c_void, normals: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_colored_kinfu_ColoredKinFu_reset(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_colored_kinfu_ColoredKinFu_getPose_const(instance: *const c_void, ocvrs_return: *mut Result<core::Affine3f>);
		pub fn cv_colored_kinfu_ColoredKinFu_update_const__InputArrayR_const__InputArrayR(instance: *mut c_void, depth: *const c_void, rgb: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_colored_kinfu_ColoredKinFu_delete(instance: *mut c_void);
		pub fn cv_colored_kinfu_Params_Params(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_colored_kinfu_Params_Params_Matx33f_Vec3f(volume_initial_pose_rot: *const core::Matx33f, volume_initial_pose_transl: *const core::Vec3f, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_colored_kinfu_Params_Params_Matx44f(volume_initial_pose: *const core::Matx44f, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_colored_kinfu_Params_setInitialVolumePose_Matx33f_Vec3f(instance: *mut c_void, r: *const core::Matx33f, t: *const core::Vec3f, ocvrs_return: *mut Result_void);
		pub fn cv_colored_kinfu_Params_setInitialVolumePose_Matx44f(instance: *mut c_void, homogen_tf: *const core::Matx44f, ocvrs_return: *mut Result_void);
		pub fn cv_colored_kinfu_Params_defaultParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_colored_kinfu_Params_coarseParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_colored_kinfu_Params_hashTSDFParams_bool(is_coarse: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_colored_kinfu_Params_coloredTSDFParams_bool(is_coarse: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_colored_kinfu_Params_propFrameSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_colored_kinfu_Params_propFrameSize_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_colored_kinfu_Params_propRgb_frameSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_colored_kinfu_Params_propRgb_frameSize_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_colored_kinfu_Params_propVolumeType_const(instance: *const c_void, ocvrs_return: *mut crate::rgbd::Kinfu_VolumeType);
		pub fn cv_colored_kinfu_Params_propVolumeType_VolumeType(instance: *mut c_void, val: crate::rgbd::Kinfu_VolumeType);
		pub fn cv_colored_kinfu_Params_propIntr_const(instance: *const c_void, ocvrs_return: *mut core::Matx33f);
		pub fn cv_colored_kinfu_Params_propIntr_Matx33f(instance: *mut c_void, val: *const core::Matx33f);
		pub fn cv_colored_kinfu_Params_propRgb_intr_const(instance: *const c_void, ocvrs_return: *mut core::Matx33f);
		pub fn cv_colored_kinfu_Params_propRgb_intr_Matx33f(instance: *mut c_void, val: *const core::Matx33f);
		pub fn cv_colored_kinfu_Params_propDepthFactor_const(instance: *const c_void) -> f32;
		pub fn cv_colored_kinfu_Params_propDepthFactor_float(instance: *mut c_void, val: f32);
		pub fn cv_colored_kinfu_Params_propBilateral_sigma_depth_const(instance: *const c_void) -> f32;
		pub fn cv_colored_kinfu_Params_propBilateral_sigma_depth_float(instance: *mut c_void, val: f32);
		pub fn cv_colored_kinfu_Params_propBilateral_sigma_spatial_const(instance: *const c_void) -> f32;
		pub fn cv_colored_kinfu_Params_propBilateral_sigma_spatial_float(instance: *mut c_void, val: f32);
		pub fn cv_colored_kinfu_Params_propBilateral_kernel_size_const(instance: *const c_void) -> i32;
		pub fn cv_colored_kinfu_Params_propBilateral_kernel_size_int(instance: *mut c_void, val: i32);
		pub fn cv_colored_kinfu_Params_propPyramidLevels_const(instance: *const c_void) -> i32;
		pub fn cv_colored_kinfu_Params_propPyramidLevels_int(instance: *mut c_void, val: i32);
		pub fn cv_colored_kinfu_Params_propVolumeDims_const(instance: *const c_void, ocvrs_return: *mut core::Vec3i);
		pub fn cv_colored_kinfu_Params_propVolumeDims_Vec3i(instance: *mut c_void, val: *const core::Vec3i);
		pub fn cv_colored_kinfu_Params_propVoxelSize_const(instance: *const c_void) -> f32;
		pub fn cv_colored_kinfu_Params_propVoxelSize_float(instance: *mut c_void, val: f32);
		pub fn cv_colored_kinfu_Params_propTsdf_min_camera_movement_const(instance: *const c_void) -> f32;
		pub fn cv_colored_kinfu_Params_propTsdf_min_camera_movement_float(instance: *mut c_void, val: f32);
		pub fn cv_colored_kinfu_Params_propVolumePose_const(instance: *const c_void, ocvrs_return: *mut core::Affine3f);
		pub fn cv_colored_kinfu_Params_propVolumePose_Affine3f(instance: *mut c_void, val: *const core::Affine3f);
		pub fn cv_colored_kinfu_Params_propTsdf_trunc_dist_const(instance: *const c_void) -> f32;
		pub fn cv_colored_kinfu_Params_propTsdf_trunc_dist_float(instance: *mut c_void, val: f32);
		pub fn cv_colored_kinfu_Params_propTsdf_max_weight_const(instance: *const c_void) -> i32;
		pub fn cv_colored_kinfu_Params_propTsdf_max_weight_int(instance: *mut c_void, val: i32);
		pub fn cv_colored_kinfu_Params_propRaycast_step_factor_const(instance: *const c_void) -> f32;
		pub fn cv_colored_kinfu_Params_propRaycast_step_factor_float(instance: *mut c_void, val: f32);
		pub fn cv_colored_kinfu_Params_propLightPose_const(instance: *const c_void, ocvrs_return: *mut core::Vec3f);
		pub fn cv_colored_kinfu_Params_propLightPose_Vec3f(instance: *mut c_void, val: *const core::Vec3f);
		pub fn cv_colored_kinfu_Params_propIcpDistThresh_const(instance: *const c_void) -> f32;
		pub fn cv_colored_kinfu_Params_propIcpDistThresh_float(instance: *mut c_void, val: f32);
		pub fn cv_colored_kinfu_Params_propIcpAngleThresh_const(instance: *const c_void) -> f32;
		pub fn cv_colored_kinfu_Params_propIcpAngleThresh_float(instance: *mut c_void, val: f32);
		pub fn cv_colored_kinfu_Params_propIcpIterations_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_colored_kinfu_Params_propIcpIterations_vectorLintG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_colored_kinfu_Params_propTruncateThreshold_const(instance: *const c_void) -> f32;
		pub fn cv_colored_kinfu_Params_propTruncateThreshold_float(instance: *mut c_void, val: f32);
		pub fn cv_colored_kinfu_Params_delete(instance: *mut c_void);
		pub fn cv_dynafu_DynaFu_create_const_PtrLParamsGR(_params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dynafu_DynaFu_getParams_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dynafu_DynaFu_render_const_const__OutputArrayR_const_Matx44fR(instance: *const c_void, image: *const c_void, camera_pose: *const core::Matx44f, ocvrs_return: *mut Result_void);
		pub fn cv_dynafu_DynaFu_render_const_const__OutputArrayR(instance: *const c_void, image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dynafu_DynaFu_getCloud_const_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, points: *const c_void, normals: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dynafu_DynaFu_getPoints_const_const__OutputArrayR(instance: *const c_void, points: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dynafu_DynaFu_getNormals_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, points: *const c_void, normals: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dynafu_DynaFu_reset(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dynafu_DynaFu_getPose_const(instance: *const c_void, ocvrs_return: *mut Result<core::Affine3f>);
		pub fn cv_dynafu_DynaFu_update_const__InputArrayR(instance: *mut c_void, depth: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_dynafu_DynaFu_getNodesPos_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_dynafu_DynaFu_marchCubes_const_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, vertices: *const c_void, edges: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dynafu_DynaFu_renderSurface_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_bool(instance: *mut c_void, depth_image: *const c_void, vert_image: *const c_void, norm_image: *const c_void, warp: bool, ocvrs_return: *mut Result_void);
		pub fn cv_dynafu_DynaFu_renderSurface_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, depth_image: *const c_void, vert_image: *const c_void, norm_image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_dynafu_DynaFu_delete(instance: *mut c_void);
		pub fn cv_kinfu_Intr_Intr(ocvrs_return: *mut Result<crate::rgbd::Kinfu_Intr>);
		pub fn cv_kinfu_Intr_Intr_float_float_float_float(_fx: f32, _fy: f32, _cx: f32, _cy: f32, ocvrs_return: *mut Result<crate::rgbd::Kinfu_Intr>);
		pub fn cv_kinfu_Intr_Intr_Matx33f(m: *const core::Matx33f, ocvrs_return: *mut Result<crate::rgbd::Kinfu_Intr>);
		pub fn cv_kinfu_Intr_scale_const_int(instance: *const crate::rgbd::Kinfu_Intr, pyr: i32, ocvrs_return: *mut Result<crate::rgbd::Kinfu_Intr>);
		pub fn cv_kinfu_Intr_makeReprojector_const(instance: *const crate::rgbd::Kinfu_Intr, ocvrs_return: *mut Result<crate::rgbd::Kinfu_Intr_Reprojector>);
		pub fn cv_kinfu_Intr_makeProjector_const(instance: *const crate::rgbd::Kinfu_Intr, ocvrs_return: *mut Result<crate::rgbd::Kinfu_Intr_Projector>);
		pub fn cv_kinfu_Intr_getMat_const(instance: *const crate::rgbd::Kinfu_Intr, ocvrs_return: *mut Result<core::Matx33f>);
		pub fn cv_kinfu_Intr_Projector_Projector_Intr(intr: *const crate::rgbd::Kinfu_Intr, ocvrs_return: *mut Result<crate::rgbd::Kinfu_Intr_Projector>);
		pub fn cv_kinfu_Intr_Reprojector_Reprojector(ocvrs_return: *mut Result<crate::rgbd::Kinfu_Intr_Reprojector>);
		pub fn cv_kinfu_Intr_Reprojector_Reprojector_Intr(intr: *const crate::rgbd::Kinfu_Intr, ocvrs_return: *mut Result<crate::rgbd::Kinfu_Intr_Reprojector>);
		pub fn cv_kinfu_KinFu_create_const_PtrLParamsGR(_params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_kinfu_KinFu_getParams_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_kinfu_KinFu_render_const_const__OutputArrayR(instance: *const c_void, image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_KinFu_render_const_const__OutputArrayR_const_Matx44fR(instance: *const c_void, image: *const c_void, camera_pose: *const core::Matx44f, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_KinFu_getCloud_const_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, points: *const c_void, normals: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_KinFu_getPoints_const_const__OutputArrayR(instance: *const c_void, points: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_KinFu_getNormals_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, points: *const c_void, normals: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_KinFu_reset(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_KinFu_getPose_const(instance: *const c_void, ocvrs_return: *mut Result<core::Affine3f>);
		pub fn cv_kinfu_KinFu_update_const__InputArrayR(instance: *mut c_void, depth: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_kinfu_KinFu_delete(instance: *mut c_void);
		pub fn cv_kinfu_Params_Params(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_kinfu_Params_Params_Matx33f_Vec3f(volume_initial_pose_rot: *const core::Matx33f, volume_initial_pose_transl: *const core::Vec3f, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_kinfu_Params_Params_Matx44f(volume_initial_pose: *const core::Matx44f, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_kinfu_Params_setInitialVolumePose_Matx33f_Vec3f(instance: *mut c_void, r: *const core::Matx33f, t: *const core::Vec3f, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_Params_setInitialVolumePose_Matx44f(instance: *mut c_void, homogen_tf: *const core::Matx44f, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_Params_defaultParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_kinfu_Params_coarseParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_kinfu_Params_hashTSDFParams_bool(is_coarse: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_kinfu_Params_coloredTSDFParams_bool(is_coarse: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_kinfu_Params_propFrameSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_kinfu_Params_propFrameSize_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_kinfu_Params_propVolumeType_const(instance: *const c_void, ocvrs_return: *mut crate::rgbd::Kinfu_VolumeType);
		pub fn cv_kinfu_Params_propVolumeType_VolumeType(instance: *mut c_void, val: crate::rgbd::Kinfu_VolumeType);
		pub fn cv_kinfu_Params_propIntr_const(instance: *const c_void, ocvrs_return: *mut core::Matx33f);
		pub fn cv_kinfu_Params_propIntr_Matx33f(instance: *mut c_void, val: *const core::Matx33f);
		pub fn cv_kinfu_Params_propRgb_intr_const(instance: *const c_void, ocvrs_return: *mut core::Matx33f);
		pub fn cv_kinfu_Params_propRgb_intr_Matx33f(instance: *mut c_void, val: *const core::Matx33f);
		pub fn cv_kinfu_Params_propDepthFactor_const(instance: *const c_void) -> f32;
		pub fn cv_kinfu_Params_propDepthFactor_float(instance: *mut c_void, val: f32);
		pub fn cv_kinfu_Params_propBilateral_sigma_depth_const(instance: *const c_void) -> f32;
		pub fn cv_kinfu_Params_propBilateral_sigma_depth_float(instance: *mut c_void, val: f32);
		pub fn cv_kinfu_Params_propBilateral_sigma_spatial_const(instance: *const c_void) -> f32;
		pub fn cv_kinfu_Params_propBilateral_sigma_spatial_float(instance: *mut c_void, val: f32);
		pub fn cv_kinfu_Params_propBilateral_kernel_size_const(instance: *const c_void) -> i32;
		pub fn cv_kinfu_Params_propBilateral_kernel_size_int(instance: *mut c_void, val: i32);
		pub fn cv_kinfu_Params_propPyramidLevels_const(instance: *const c_void) -> i32;
		pub fn cv_kinfu_Params_propPyramidLevels_int(instance: *mut c_void, val: i32);
		pub fn cv_kinfu_Params_propVolumeDims_const(instance: *const c_void, ocvrs_return: *mut core::Vec3i);
		pub fn cv_kinfu_Params_propVolumeDims_Vec3i(instance: *mut c_void, val: *const core::Vec3i);
		pub fn cv_kinfu_Params_propVoxelSize_const(instance: *const c_void) -> f32;
		pub fn cv_kinfu_Params_propVoxelSize_float(instance: *mut c_void, val: f32);
		pub fn cv_kinfu_Params_propTsdf_min_camera_movement_const(instance: *const c_void) -> f32;
		pub fn cv_kinfu_Params_propTsdf_min_camera_movement_float(instance: *mut c_void, val: f32);
		pub fn cv_kinfu_Params_propVolumePose_const(instance: *const c_void, ocvrs_return: *mut core::Affine3f);
		pub fn cv_kinfu_Params_propVolumePose_Affine3f(instance: *mut c_void, val: *const core::Affine3f);
		pub fn cv_kinfu_Params_propTsdf_trunc_dist_const(instance: *const c_void) -> f32;
		pub fn cv_kinfu_Params_propTsdf_trunc_dist_float(instance: *mut c_void, val: f32);
		pub fn cv_kinfu_Params_propTsdf_max_weight_const(instance: *const c_void) -> i32;
		pub fn cv_kinfu_Params_propTsdf_max_weight_int(instance: *mut c_void, val: i32);
		pub fn cv_kinfu_Params_propRaycast_step_factor_const(instance: *const c_void) -> f32;
		pub fn cv_kinfu_Params_propRaycast_step_factor_float(instance: *mut c_void, val: f32);
		pub fn cv_kinfu_Params_propLightPose_const(instance: *const c_void, ocvrs_return: *mut core::Vec3f);
		pub fn cv_kinfu_Params_propLightPose_Vec3f(instance: *mut c_void, val: *const core::Vec3f);
		pub fn cv_kinfu_Params_propIcpDistThresh_const(instance: *const c_void) -> f32;
		pub fn cv_kinfu_Params_propIcpDistThresh_float(instance: *mut c_void, val: f32);
		pub fn cv_kinfu_Params_propIcpAngleThresh_const(instance: *const c_void) -> f32;
		pub fn cv_kinfu_Params_propIcpAngleThresh_float(instance: *mut c_void, val: f32);
		pub fn cv_kinfu_Params_propIcpIterations_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_kinfu_Params_propIcpIterations_vectorLintG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_kinfu_Params_propTruncateThreshold_const(instance: *const c_void) -> f32;
		pub fn cv_kinfu_Params_propTruncateThreshold_float(instance: *mut c_void, val: f32);
		pub fn cv_kinfu_Params_delete(instance: *mut c_void);
		pub fn cv_kinfu_Volume_integrate_const__InputArrayR_float_const_Matx44fR_const_IntrR_const_int(instance: *mut c_void, _depth: *const c_void, depth_factor: f32, camera_pose: *const core::Matx44f, intrinsics: *const crate::rgbd::Kinfu_Intr, frame_id: i32, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_Volume_integrate_const__InputArrayR_float_const_Matx44fR_const_IntrR(instance: *mut c_void, _depth: *const c_void, depth_factor: f32, camera_pose: *const core::Matx44f, intrinsics: *const crate::rgbd::Kinfu_Intr, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_Volume_integrate_const__InputArrayR_const__InputArrayR_float_const_Matx44fR_const_IntrR_const_IntrR_const_int(instance: *mut c_void, _depth: *const c_void, _rgb: *const c_void, depth_factor: f32, camera_pose: *const core::Matx44f, intrinsics: *const crate::rgbd::Kinfu_Intr, rgb_intrinsics: *const crate::rgbd::Kinfu_Intr, frame_id: i32, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_Volume_integrate_const__InputArrayR_const__InputArrayR_float_const_Matx44fR_const_IntrR_const_IntrR(instance: *mut c_void, _depth: *const c_void, _rgb: *const c_void, depth_factor: f32, camera_pose: *const core::Matx44f, intrinsics: *const crate::rgbd::Kinfu_Intr, rgb_intrinsics: *const crate::rgbd::Kinfu_Intr, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_Volume_raycast_const_const_Matx44fR_const_IntrR_const_SizeR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, camera_pose: *const core::Matx44f, intrinsics: *const crate::rgbd::Kinfu_Intr, frame_size: *const core::Size, points: *const c_void, normals: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_Volume_raycast_const_const_Matx44fR_const_IntrR_const_SizeR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, camera_pose: *const core::Matx44f, intrinsics: *const crate::rgbd::Kinfu_Intr, frame_size: *const core::Size, points: *const c_void, normals: *const c_void, colors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_Volume_fetchNormals_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, points: *const c_void, _normals: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_Volume_fetchPointsNormals_const_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, points: *const c_void, normals: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_Volume_fetchPointsNormalsColors_const_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, unnamed: *const c_void, unnamed_1: *const c_void, unnamed_2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_Volume_reset(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_Volume_propVoxelSize_const(instance: *const c_void) -> f32;
		pub fn cv_kinfu_Volume_propVoxelSizeInv_const(instance: *const c_void) -> f32;
		pub fn cv_kinfu_Volume_propPose_const(instance: *const c_void, ocvrs_return: *mut core::Affine3f);
		pub fn cv_kinfu_Volume_propRaycastStepFactor_const(instance: *const c_void) -> f32;
		pub fn cv_kinfu_Volume_delete(instance: *mut c_void);
		pub fn cv_kinfu_VolumeParams_defaultParams_VolumeType(_volume_type: crate::rgbd::Kinfu_VolumeType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_kinfu_VolumeParams_coarseParams_VolumeType(_volume_type: crate::rgbd::Kinfu_VolumeType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_kinfu_VolumeParams_propType_const(instance: *const c_void, ocvrs_return: *mut crate::rgbd::Kinfu_VolumeType);
		pub fn cv_kinfu_VolumeParams_propType_VolumeType(instance: *mut c_void, val: crate::rgbd::Kinfu_VolumeType);
		pub fn cv_kinfu_VolumeParams_propResolution_const(instance: *const c_void, ocvrs_return: *mut core::Vec3i);
		pub fn cv_kinfu_VolumeParams_propResolution_Vec3i(instance: *mut c_void, val: *const core::Vec3i);
		pub fn cv_kinfu_VolumeParams_propUnitResolution_const(instance: *const c_void) -> i32;
		pub fn cv_kinfu_VolumeParams_propUnitResolution_int(instance: *mut c_void, val: i32);
		pub fn cv_kinfu_VolumeParams_propPose_const(instance: *const c_void, ocvrs_return: *mut core::Affine3f);
		pub fn cv_kinfu_VolumeParams_propPose_Affine3f(instance: *mut c_void, val: *const core::Affine3f);
		pub fn cv_kinfu_VolumeParams_propVoxelSize_const(instance: *const c_void) -> f32;
		pub fn cv_kinfu_VolumeParams_propVoxelSize_float(instance: *mut c_void, val: f32);
		pub fn cv_kinfu_VolumeParams_propTsdfTruncDist_const(instance: *const c_void) -> f32;
		pub fn cv_kinfu_VolumeParams_propTsdfTruncDist_float(instance: *mut c_void, val: f32);
		pub fn cv_kinfu_VolumeParams_propMaxWeight_const(instance: *const c_void) -> i32;
		pub fn cv_kinfu_VolumeParams_propMaxWeight_int(instance: *mut c_void, val: i32);
		pub fn cv_kinfu_VolumeParams_propDepthTruncThreshold_const(instance: *const c_void) -> f32;
		pub fn cv_kinfu_VolumeParams_propDepthTruncThreshold_float(instance: *mut c_void, val: f32);
		pub fn cv_kinfu_VolumeParams_propRaycastStepFactor_const(instance: *const c_void) -> f32;
		pub fn cv_kinfu_VolumeParams_propRaycastStepFactor_float(instance: *mut c_void, val: f32);
		pub fn cv_kinfu_VolumeParams_delete(instance: *mut c_void);
		pub fn cv_kinfu_detail_PoseGraph_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_kinfu_detail_PoseGraph_addNode_size_t_const_Affine3dR_bool(instance: *mut c_void, _node_id: size_t, _pose: *const core::Affine3d, fixed: bool, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_detail_PoseGraph_isNodeExist_const_size_t(instance: *const c_void, node_id: size_t, ocvrs_return: *mut Result<bool>);
		pub fn cv_kinfu_detail_PoseGraph_setNodeFixed_size_t_bool(instance: *mut c_void, node_id: size_t, fixed: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_kinfu_detail_PoseGraph_isNodeFixed_const_size_t(instance: *const c_void, node_id: size_t, ocvrs_return: *mut Result<bool>);
		pub fn cv_kinfu_detail_PoseGraph_getNodePose_const_size_t(instance: *const c_void, node_id: size_t, ocvrs_return: *mut Result<core::Affine3d>);
		pub fn cv_kinfu_detail_PoseGraph_getNodesIds_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_kinfu_detail_PoseGraph_getNumNodes_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_kinfu_detail_PoseGraph_addEdge_size_t_size_t_const_Affine3fR_const_Matx66fR(instance: *mut c_void, _source_node_id: size_t, _target_node_id: size_t, _transformation: *const core::Affine3f, _information: *const core::Matx66f, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_detail_PoseGraph_addEdge_size_t_size_t_const_Affine3fR(instance: *mut c_void, _source_node_id: size_t, _target_node_id: size_t, _transformation: *const core::Affine3f, ocvrs_return: *mut Result_void);
		pub fn cv_kinfu_detail_PoseGraph_getEdgeStart_const_size_t(instance: *const c_void, i: size_t, ocvrs_return: *mut Result<size_t>);
		pub fn cv_kinfu_detail_PoseGraph_getEdgeEnd_const_size_t(instance: *const c_void, i: size_t, ocvrs_return: *mut Result<size_t>);
		pub fn cv_kinfu_detail_PoseGraph_getNumEdges_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_kinfu_detail_PoseGraph_isValid_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_kinfu_detail_PoseGraph_optimize_const_TermCriteriaR(instance: *mut c_void, tc: *const core::TermCriteria, ocvrs_return: *mut Result<i32>);
		pub fn cv_kinfu_detail_PoseGraph_optimize(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_kinfu_detail_PoseGraph_calcEnergy_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_kinfu_detail_PoseGraph_delete(instance: *mut c_void);
		pub fn cv_large_kinfu_LargeKinfu_create_const_PtrLParamsGR(_params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_large_kinfu_LargeKinfu_getParams_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_large_kinfu_LargeKinfu_render_const_const__OutputArrayR(instance: *const c_void, image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_large_kinfu_LargeKinfu_render_const_const__OutputArrayR_const_Matx44fR(instance: *const c_void, image: *const c_void, camera_pose: *const core::Matx44f, ocvrs_return: *mut Result_void);
		pub fn cv_large_kinfu_LargeKinfu_getCloud_const_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, points: *const c_void, normals: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_large_kinfu_LargeKinfu_getPoints_const_const__OutputArrayR(instance: *const c_void, points: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_large_kinfu_LargeKinfu_getNormals_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, points: *const c_void, normals: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_large_kinfu_LargeKinfu_reset(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_large_kinfu_LargeKinfu_getPose_const(instance: *const c_void, ocvrs_return: *mut Result<core::Affine3f>);
		pub fn cv_large_kinfu_LargeKinfu_update_const__InputArrayR(instance: *mut c_void, depth: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_large_kinfu_LargeKinfu_delete(instance: *mut c_void);
		pub fn cv_large_kinfu_Params_defaultParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_large_kinfu_Params_coarseParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_large_kinfu_Params_hashTSDFParams_bool(is_coarse: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_large_kinfu_Params_propFrameSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_large_kinfu_Params_propFrameSize_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_large_kinfu_Params_propIntr_const(instance: *const c_void, ocvrs_return: *mut core::Matx33f);
		pub fn cv_large_kinfu_Params_propIntr_Matx33f(instance: *mut c_void, val: *const core::Matx33f);
		pub fn cv_large_kinfu_Params_propRgb_intr_const(instance: *const c_void, ocvrs_return: *mut core::Matx33f);
		pub fn cv_large_kinfu_Params_propRgb_intr_Matx33f(instance: *mut c_void, val: *const core::Matx33f);
		pub fn cv_large_kinfu_Params_propDepthFactor_const(instance: *const c_void) -> f32;
		pub fn cv_large_kinfu_Params_propDepthFactor_float(instance: *mut c_void, val: f32);
		pub fn cv_large_kinfu_Params_propBilateral_sigma_depth_const(instance: *const c_void) -> f32;
		pub fn cv_large_kinfu_Params_propBilateral_sigma_depth_float(instance: *mut c_void, val: f32);
		pub fn cv_large_kinfu_Params_propBilateral_sigma_spatial_const(instance: *const c_void) -> f32;
		pub fn cv_large_kinfu_Params_propBilateral_sigma_spatial_float(instance: *mut c_void, val: f32);
		pub fn cv_large_kinfu_Params_propBilateral_kernel_size_const(instance: *const c_void) -> i32;
		pub fn cv_large_kinfu_Params_propBilateral_kernel_size_int(instance: *mut c_void, val: i32);
		pub fn cv_large_kinfu_Params_propPyramidLevels_const(instance: *const c_void) -> i32;
		pub fn cv_large_kinfu_Params_propPyramidLevels_int(instance: *mut c_void, val: i32);
		pub fn cv_large_kinfu_Params_propTsdf_min_camera_movement_const(instance: *const c_void) -> f32;
		pub fn cv_large_kinfu_Params_propTsdf_min_camera_movement_float(instance: *mut c_void, val: f32);
		pub fn cv_large_kinfu_Params_propLightPose_const(instance: *const c_void, ocvrs_return: *mut core::Vec3f);
		pub fn cv_large_kinfu_Params_propLightPose_Vec3f(instance: *mut c_void, val: *const core::Vec3f);
		pub fn cv_large_kinfu_Params_propIcpDistThresh_const(instance: *const c_void) -> f32;
		pub fn cv_large_kinfu_Params_propIcpDistThresh_float(instance: *mut c_void, val: f32);
		pub fn cv_large_kinfu_Params_propIcpAngleThresh_const(instance: *const c_void) -> f32;
		pub fn cv_large_kinfu_Params_propIcpAngleThresh_float(instance: *mut c_void, val: f32);
		pub fn cv_large_kinfu_Params_propIcpIterations_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_large_kinfu_Params_propIcpIterations_vectorLintG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_large_kinfu_Params_propTruncateThreshold_const(instance: *const c_void) -> f32;
		pub fn cv_large_kinfu_Params_propTruncateThreshold_float(instance: *mut c_void, val: f32);
		pub fn cv_large_kinfu_Params_propVolumeParams_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_large_kinfu_Params_propVolumeParams_VolumeParams(instance: *mut c_void, val: *mut c_void);
		pub fn cv_large_kinfu_Params_delete(instance: *mut c_void);
		pub fn cv_linemod_ColorGradient_ColorGradient(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_ColorGradient_ColorGradient_float_size_t_float(weak_threshold: f32, num_features: size_t, strong_threshold: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_ColorGradient_create_float_size_t_float(weak_threshold: f32, num_features: size_t, strong_threshold: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_ColorGradient_name_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_ColorGradient_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_ColorGradient_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_ColorGradient_propWeak_threshold_const(instance: *const c_void) -> f32;
		pub fn cv_linemod_ColorGradient_propWeak_threshold_float(instance: *mut c_void, val: f32);
		pub fn cv_linemod_ColorGradient_propNum_features_const(instance: *const c_void) -> size_t;
		pub fn cv_linemod_ColorGradient_propNum_features_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_linemod_ColorGradient_propStrong_threshold_const(instance: *const c_void) -> f32;
		pub fn cv_linemod_ColorGradient_propStrong_threshold_float(instance: *mut c_void, val: f32);
		pub fn cv_linemod_ColorGradient_to_LineMod_Modality(instance: *mut c_void) -> *mut c_void;
		pub fn cv_linemod_ColorGradient_delete(instance: *mut c_void);
		pub fn cv_linemod_DepthNormal_DepthNormal(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_DepthNormal_DepthNormal_int_int_size_t_int(distance_threshold: i32, difference_threshold: i32, num_features: size_t, extract_threshold: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_DepthNormal_create_int_int_size_t_int(distance_threshold: i32, difference_threshold: i32, num_features: size_t, extract_threshold: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_DepthNormal_name_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_DepthNormal_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_DepthNormal_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_DepthNormal_propDistance_threshold_const(instance: *const c_void) -> i32;
		pub fn cv_linemod_DepthNormal_propDistance_threshold_int(instance: *mut c_void, val: i32);
		pub fn cv_linemod_DepthNormal_propDifference_threshold_const(instance: *const c_void) -> i32;
		pub fn cv_linemod_DepthNormal_propDifference_threshold_int(instance: *mut c_void, val: i32);
		pub fn cv_linemod_DepthNormal_propNum_features_const(instance: *const c_void) -> size_t;
		pub fn cv_linemod_DepthNormal_propNum_features_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_linemod_DepthNormal_propExtract_threshold_const(instance: *const c_void) -> i32;
		pub fn cv_linemod_DepthNormal_propExtract_threshold_int(instance: *mut c_void, val: i32);
		pub fn cv_linemod_DepthNormal_to_LineMod_Modality(instance: *mut c_void) -> *mut c_void;
		pub fn cv_linemod_DepthNormal_delete(instance: *mut c_void);
		pub fn cv_linemod_Detector_Detector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_Detector_Detector_const_vectorLPtrLModalityGGR_const_vectorLintGR(modalities: *const c_void, t_pyramid: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_Detector_match_const_const_vectorLMatGR_float_vectorLMatchGR_const_vectorLStringGR_const__OutputArrayR_const_vectorLMatGR(instance: *const c_void, sources: *const c_void, threshold: f32, matches: *mut c_void, class_ids: *const c_void, quantized_images: *const c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_Detector_match_const_const_vectorLMatGR_float_vectorLMatchGR(instance: *const c_void, sources: *const c_void, threshold: f32, matches: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_Detector_addTemplate_const_vectorLMatGR_const_StringR_const_MatR_RectX(instance: *mut c_void, sources: *const c_void, class_id: *const c_char, object_mask: *const c_void, bounding_box: *mut core::Rect, ocvrs_return: *mut Result<i32>);
		pub fn cv_linemod_Detector_addTemplate_const_vectorLMatGR_const_StringR_const_MatR(instance: *mut c_void, sources: *const c_void, class_id: *const c_char, object_mask: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_linemod_Detector_addSyntheticTemplate_const_vectorLTemplateGR_const_StringR(instance: *mut c_void, templates: *const c_void, class_id: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_linemod_Detector_getModalities_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_Detector_getT_const_int(instance: *const c_void, pyramid_level: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_linemod_Detector_pyramidLevels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_linemod_Detector_getTemplates_const_const_StringR_int(instance: *const c_void, class_id: *const c_char, template_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_Detector_numTemplates_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_linemod_Detector_numTemplates_const_const_StringR(instance: *const c_void, class_id: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_linemod_Detector_numClasses_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_linemod_Detector_classIds_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_Detector_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_Detector_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_Detector_readClass_const_FileNodeR_const_StringR(instance: *mut c_void, fn_: *const c_void, class_id_override: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_Detector_readClass_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_Detector_writeClass_const_const_StringR_FileStorageR(instance: *const c_void, class_id: *const c_char, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_Detector_readClasses_const_vectorLStringGR_const_StringR(instance: *mut c_void, class_ids: *const c_void, format: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_Detector_readClasses_const_vectorLStringGR(instance: *mut c_void, class_ids: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_Detector_writeClasses_const_const_StringR(instance: *const c_void, format: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_Detector_writeClasses_const(instance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_Detector_delete(instance: *mut c_void);
		pub fn cv_linemod_Feature_Feature(ocvrs_return: *mut Result<crate::rgbd::LineMod_Feature>);
		pub fn cv_linemod_Feature_Feature_int_int_int(x: i32, y: i32, label: i32, ocvrs_return: *mut Result<crate::rgbd::LineMod_Feature>);
		pub fn cv_linemod_Feature_read_const_FileNodeR(instance: *const crate::rgbd::LineMod_Feature, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_Feature_write_const_FileStorageR(instance: *const crate::rgbd::LineMod_Feature, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_Match_Match(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_Match_Match_int_int_float_const_StringR_int(x: i32, y: i32, similarity: f32, class_id: *const c_char, template_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_Match_operatorL_const_const_MatchR(instance: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_linemod_Match_operatorEQ_const_const_MatchR(instance: *const c_void, rhs: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_linemod_Match_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_linemod_Match_propX_const(instance: *const c_void) -> i32;
		pub fn cv_linemod_Match_propX_int(instance: *mut c_void, val: i32);
		pub fn cv_linemod_Match_propY_const(instance: *const c_void) -> i32;
		pub fn cv_linemod_Match_propY_int(instance: *mut c_void, val: i32);
		pub fn cv_linemod_Match_propSimilarity_const(instance: *const c_void) -> f32;
		pub fn cv_linemod_Match_propSimilarity_float(instance: *mut c_void, val: f32);
		pub fn cv_linemod_Match_propClass_id_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_linemod_Match_propClass_id_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_linemod_Match_propTemplate_id_const(instance: *const c_void) -> i32;
		pub fn cv_linemod_Match_propTemplate_id_int(instance: *mut c_void, val: i32);
		pub fn cv_linemod_Match_delete(instance: *mut c_void);
		pub fn cv_linemod_Modality_process_const_const_MatR_const_MatR(instance: *const c_void, src: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_Modality_process_const_const_MatR(instance: *const c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_Modality_name_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_Modality_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_Modality_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_Modality_create_const_StringR(modality_type: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_Modality_create_const_FileNodeR(fn_: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_linemod_Modality_to_LineMod_ColorGradient(instance: *mut c_void) -> *mut c_void;
		pub fn cv_linemod_Modality_to_LineMod_DepthNormal(instance: *mut c_void) -> *mut c_void;
		pub fn cv_linemod_Modality_delete(instance: *mut c_void);
		pub fn cv_linemod_QuantizedPyramid_quantize_const_MatR(instance: *const c_void, dst: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_QuantizedPyramid_extractTemplate_const_TemplateR(instance: *const c_void, templ: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_linemod_QuantizedPyramid_pyrDown(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_QuantizedPyramid_delete(instance: *mut c_void);
		pub fn cv_linemod_Template_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_Template_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_linemod_Template_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_linemod_Template_defaultNew_const() -> *mut c_void;
		pub fn cv_linemod_Template_propWidth_const(instance: *const c_void) -> i32;
		pub fn cv_linemod_Template_propWidth_int(instance: *mut c_void, val: i32);
		pub fn cv_linemod_Template_propHeight_const(instance: *const c_void) -> i32;
		pub fn cv_linemod_Template_propHeight_int(instance: *mut c_void, val: i32);
		pub fn cv_linemod_Template_propPyramid_level_const(instance: *const c_void) -> i32;
		pub fn cv_linemod_Template_propPyramid_level_int(instance: *mut c_void, val: i32);
		pub fn cv_linemod_Template_propFeatures_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_linemod_Template_propFeatures_vectorLFeatureG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_linemod_Template_delete(instance: *mut c_void);
		pub fn cv_rgbd_DepthCleaner_DepthCleaner(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_DepthCleaner_DepthCleaner_int_int_int(depth: i32, window_size: i32, method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_DepthCleaner_DepthCleaner_int(depth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_DepthCleaner_create_int_int_int(depth: i32, window_size: i32, method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_DepthCleaner_create_int(depth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_DepthCleaner_operator___const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, points: *const c_void, depth: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_DepthCleaner_initialize_const(instance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_DepthCleaner_getWindowSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rgbd_DepthCleaner_setWindowSize_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_DepthCleaner_getDepth_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rgbd_DepthCleaner_setDepth_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_DepthCleaner_getMethod_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rgbd_DepthCleaner_setMethod_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_DepthCleaner_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rgbd_DepthCleaner_delete(instance: *mut c_void);
		pub fn cv_rgbd_FastICPOdometry_FastICPOdometry(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_FastICPOdometry_FastICPOdometry_const_MatR_float_float_float_float_int_const_vectorLintGR(camera_matrix: *const c_void, max_dist_diff: f32, angle_threshold: f32, sigma_depth: f32, sigma_spatial: f32, kernel_size: i32, iter_counts: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_FastICPOdometry_FastICPOdometry_const_MatR(camera_matrix: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_FastICPOdometry_create_const_MatR_float_float_float_float_int_const_vectorLintGR(camera_matrix: *const c_void, max_dist_diff: f32, angle_threshold: f32, sigma_depth: f32, sigma_spatial: f32, kernel_size: i32, iter_counts: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_FastICPOdometry_create_const_MatR(camera_matrix: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_FastICPOdometry_prepareFrameCache_const_PtrLOdometryFrameGR_int(instance: *const c_void, frame: *mut c_void, cache_type: i32, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_rgbd_FastICPOdometry_getCameraMatrix_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_FastICPOdometry_setCameraMatrix_const_MatR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_FastICPOdometry_getMaxDistDiff_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_FastICPOdometry_setMaxDistDiff_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_FastICPOdometry_getAngleThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_rgbd_FastICPOdometry_setAngleThreshold_float(instance: *mut c_void, f: f32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_FastICPOdometry_getSigmaDepth_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_rgbd_FastICPOdometry_setSigmaDepth_float(instance: *mut c_void, f: f32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_FastICPOdometry_getSigmaSpatial_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_rgbd_FastICPOdometry_setSigmaSpatial_float(instance: *mut c_void, f: f32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_FastICPOdometry_getKernelSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rgbd_FastICPOdometry_setKernelSize_int(instance: *mut c_void, f: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_FastICPOdometry_getIterationCounts_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_FastICPOdometry_setIterationCounts_const_MatR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_FastICPOdometry_getTransformType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rgbd_FastICPOdometry_setTransformType_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_FastICPOdometry_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rgbd_FastICPOdometry_to_Odometry(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rgbd_FastICPOdometry_delete(instance: *mut c_void);
		pub fn cv_rgbd_ICPOdometry_ICPOdometry(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_ICPOdometry_ICPOdometry_const_MatR_float_float_float_float_const_vectorLintGR_int(camera_matrix: *const c_void, min_depth: f32, max_depth: f32, max_depth_diff: f32, max_points_part: f32, iter_counts: *const c_void, transform_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_ICPOdometry_ICPOdometry_const_MatR(camera_matrix: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_ICPOdometry_create_const_MatR_float_float_float_float_const_vectorLintGR_int(camera_matrix: *const c_void, min_depth: f32, max_depth: f32, max_depth_diff: f32, max_points_part: f32, iter_counts: *const c_void, transform_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_ICPOdometry_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_ICPOdometry_prepareFrameCache_const_PtrLOdometryFrameGR_int(instance: *const c_void, frame: *mut c_void, cache_type: i32, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_rgbd_ICPOdometry_getCameraMatrix_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_ICPOdometry_setCameraMatrix_const_MatR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_ICPOdometry_getMinDepth_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_ICPOdometry_setMinDepth_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_ICPOdometry_getMaxDepth_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_ICPOdometry_setMaxDepth_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_ICPOdometry_getMaxDepthDiff_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_ICPOdometry_setMaxDepthDiff_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_ICPOdometry_getIterationCounts_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_ICPOdometry_setIterationCounts_const_MatR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_ICPOdometry_getMaxPointsPart_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_ICPOdometry_setMaxPointsPart_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_ICPOdometry_getTransformType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rgbd_ICPOdometry_setTransformType_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_ICPOdometry_getMaxTranslation_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_ICPOdometry_setMaxTranslation_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_ICPOdometry_getMaxRotation_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_ICPOdometry_setMaxRotation_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_ICPOdometry_getNormalsComputer_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_ICPOdometry_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rgbd_ICPOdometry_to_Odometry(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rgbd_ICPOdometry_delete(instance: *mut c_void);
		pub fn cv_rgbd_Odometry_DEFAULT_MIN_DEPTH(ocvrs_return: *mut Result<f32>);
		pub fn cv_rgbd_Odometry_DEFAULT_MAX_DEPTH(ocvrs_return: *mut Result<f32>);
		pub fn cv_rgbd_Odometry_DEFAULT_MAX_DEPTH_DIFF(ocvrs_return: *mut Result<f32>);
		pub fn cv_rgbd_Odometry_DEFAULT_MAX_POINTS_PART(ocvrs_return: *mut Result<f32>);
		pub fn cv_rgbd_Odometry_DEFAULT_MAX_TRANSLATION(ocvrs_return: *mut Result<f32>);
		pub fn cv_rgbd_Odometry_DEFAULT_MAX_ROTATION(ocvrs_return: *mut Result<f32>);
		pub fn cv_rgbd_Odometry_compute_const_const_MatR_const_MatR_const_MatR_const_MatR_const_MatR_const_MatR_const__OutputArrayR_const_MatR(instance: *const c_void, src_image: *const c_void, src_depth: *const c_void, src_mask: *const c_void, dst_image: *const c_void, dst_depth: *const c_void, dst_mask: *const c_void, rt: *const c_void, init_rt: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_rgbd_Odometry_compute_const_const_MatR_const_MatR_const_MatR_const_MatR_const_MatR_const_MatR_const__OutputArrayR(instance: *const c_void, src_image: *const c_void, src_depth: *const c_void, src_mask: *const c_void, dst_image: *const c_void, dst_depth: *const c_void, dst_mask: *const c_void, rt: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_rgbd_Odometry_compute_const_PtrLOdometryFrameGR_PtrLOdometryFrameGR_const__OutputArrayR_const_MatR(instance: *const c_void, src_frame: *mut c_void, dst_frame: *mut c_void, rt: *const c_void, init_rt: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_rgbd_Odometry_compute_const_PtrLOdometryFrameGR_PtrLOdometryFrameGR_const__OutputArrayR(instance: *const c_void, src_frame: *mut c_void, dst_frame: *mut c_void, rt: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_rgbd_Odometry_prepareFrameCache_const_PtrLOdometryFrameGR_int(instance: *const c_void, frame: *mut c_void, cache_type: i32, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_rgbd_Odometry_create_const_StringR(odometry_type: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_Odometry_getCameraMatrix_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_Odometry_setCameraMatrix_const_MatR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_Odometry_getTransformType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rgbd_Odometry_setTransformType_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_Odometry_to_FastICPOdometry(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rgbd_Odometry_to_ICPOdometry(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rgbd_Odometry_to_RgbdICPOdometry(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rgbd_Odometry_to_RgbdOdometry(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rgbd_Odometry_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rgbd_Odometry_delete(instance: *mut c_void);
		pub fn cv_rgbd_OdometryFrame_OdometryFrame(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_OdometryFrame_OdometryFrame_const_MatR_const_MatR_const_MatR_const_MatR_int(image: *const c_void, depth: *const c_void, mask: *const c_void, normals: *const c_void, id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_OdometryFrame_OdometryFrame_const_MatR_const_MatR(image: *const c_void, depth: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_OdometryFrame_create_const_MatR_const_MatR_const_MatR_const_MatR_int(image: *const c_void, depth: *const c_void, mask: *const c_void, normals: *const c_void, id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_OdometryFrame_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_OdometryFrame_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_OdometryFrame_releasePyramids(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_OdometryFrame_propPyramidImage_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_rgbd_OdometryFrame_propPyramidImage_vectorLMatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_rgbd_OdometryFrame_propPyramidDepth_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_rgbd_OdometryFrame_propPyramidDepth_vectorLMatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_rgbd_OdometryFrame_propPyramidMask_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_rgbd_OdometryFrame_propPyramidMask_vectorLMatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_rgbd_OdometryFrame_propPyramidCloud_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_rgbd_OdometryFrame_propPyramidCloud_vectorLMatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_rgbd_OdometryFrame_propPyramid_dI_dx_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_rgbd_OdometryFrame_propPyramid_dI_dx_vectorLMatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_rgbd_OdometryFrame_propPyramid_dI_dy_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_rgbd_OdometryFrame_propPyramid_dI_dy_vectorLMatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_rgbd_OdometryFrame_propPyramidTexturedMask_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_rgbd_OdometryFrame_propPyramidTexturedMask_vectorLMatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_rgbd_OdometryFrame_propPyramidNormals_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_rgbd_OdometryFrame_propPyramidNormals_vectorLMatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_rgbd_OdometryFrame_propPyramidNormalsMask_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_rgbd_OdometryFrame_propPyramidNormalsMask_vectorLMatG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_rgbd_OdometryFrame_to_RgbdFrame(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rgbd_OdometryFrame_delete(instance: *mut c_void);
		pub fn cv_rgbd_RgbdFrame_RgbdFrame(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdFrame_RgbdFrame_const_MatR_const_MatR_const_MatR_const_MatR_int(image: *const c_void, depth: *const c_void, mask: *const c_void, normals: *const c_void, id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdFrame_RgbdFrame_const_MatR_const_MatR(image: *const c_void, depth: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdFrame_create_const_MatR_const_MatR_const_MatR_const_MatR_int(image: *const c_void, depth: *const c_void, mask: *const c_void, normals: *const c_void, id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdFrame_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdFrame_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdFrame_propID_const(instance: *const c_void) -> i32;
		pub fn cv_rgbd_RgbdFrame_propID_int(instance: *mut c_void, val: i32);
		pub fn cv_rgbd_RgbdFrame_propImage_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_rgbd_RgbdFrame_propImage_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_rgbd_RgbdFrame_propDepth_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_rgbd_RgbdFrame_propDepth_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_rgbd_RgbdFrame_propMask_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_rgbd_RgbdFrame_propMask_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_rgbd_RgbdFrame_propNormals_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_rgbd_RgbdFrame_propNormals_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_rgbd_RgbdFrame_to_OdometryFrame(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rgbd_RgbdFrame_delete(instance: *mut c_void);
		pub fn cv_rgbd_RgbdICPOdometry_RgbdICPOdometry(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdICPOdometry_RgbdICPOdometry_const_MatR_float_float_float_float_const_vectorLintGR_const_vectorLfloatGR_int(camera_matrix: *const c_void, min_depth: f32, max_depth: f32, max_depth_diff: f32, max_points_part: f32, iter_counts: *const c_void, min_gradient_magnitudes: *const c_void, transform_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdICPOdometry_RgbdICPOdometry_const_MatR(camera_matrix: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdICPOdometry_create_const_MatR_float_float_float_float_const_vectorLintGR_const_vectorLfloatGR_int(camera_matrix: *const c_void, min_depth: f32, max_depth: f32, max_depth_diff: f32, max_points_part: f32, iter_counts: *const c_void, min_gradient_magnitudes: *const c_void, transform_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdICPOdometry_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdICPOdometry_prepareFrameCache_const_PtrLOdometryFrameGR_int(instance: *const c_void, frame: *mut c_void, cache_type: i32, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_rgbd_RgbdICPOdometry_getCameraMatrix_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdICPOdometry_setCameraMatrix_const_MatR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdICPOdometry_getMinDepth_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_RgbdICPOdometry_setMinDepth_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdICPOdometry_getMaxDepth_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_RgbdICPOdometry_setMaxDepth_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdICPOdometry_getMaxDepthDiff_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_RgbdICPOdometry_setMaxDepthDiff_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdICPOdometry_getMaxPointsPart_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_RgbdICPOdometry_setMaxPointsPart_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdICPOdometry_getIterationCounts_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdICPOdometry_setIterationCounts_const_MatR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdICPOdometry_getMinGradientMagnitudes_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdICPOdometry_setMinGradientMagnitudes_const_MatR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdICPOdometry_getTransformType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rgbd_RgbdICPOdometry_setTransformType_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdICPOdometry_getMaxTranslation_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_RgbdICPOdometry_setMaxTranslation_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdICPOdometry_getMaxRotation_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_RgbdICPOdometry_setMaxRotation_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdICPOdometry_getNormalsComputer_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdICPOdometry_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rgbd_RgbdICPOdometry_to_Odometry(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rgbd_RgbdICPOdometry_delete(instance: *mut c_void);
		pub fn cv_rgbd_RgbdNormals_RgbdNormals(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdNormals_RgbdNormals_int_int_int_const__InputArrayR_int_int(rows: i32, cols: i32, depth: i32, k: *const c_void, window_size: i32, method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdNormals_RgbdNormals_int_int_int_const__InputArrayR(rows: i32, cols: i32, depth: i32, k: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdNormals_create_int_int_int_const__InputArrayR_int_int(rows: i32, cols: i32, depth: i32, k: *const c_void, window_size: i32, method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdNormals_create_int_int_int_const__InputArrayR(rows: i32, cols: i32, depth: i32, k: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdNormals_operator___const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, points: *const c_void, normals: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdNormals_initialize_const(instance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdNormals_getRows_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rgbd_RgbdNormals_setRows_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdNormals_getCols_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rgbd_RgbdNormals_setCols_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdNormals_getWindowSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rgbd_RgbdNormals_setWindowSize_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdNormals_getDepth_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rgbd_RgbdNormals_setDepth_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdNormals_getK_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdNormals_setK_const_MatR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdNormals_getMethod_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rgbd_RgbdNormals_setMethod_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdNormals_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rgbd_RgbdNormals_delete(instance: *mut c_void);
		pub fn cv_rgbd_RgbdOdometry_RgbdOdometry(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdOdometry_RgbdOdometry_const_MatR_float_float_float_const_vectorLintGR_const_vectorLfloatGR_float_int(camera_matrix: *const c_void, min_depth: f32, max_depth: f32, max_depth_diff: f32, iter_counts: *const c_void, min_gradient_magnitudes: *const c_void, max_points_part: f32, transform_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdOdometry_RgbdOdometry_const_MatR(camera_matrix: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdOdometry_create_const_MatR_float_float_float_const_vectorLintGR_const_vectorLfloatGR_float_int(camera_matrix: *const c_void, min_depth: f32, max_depth: f32, max_depth_diff: f32, iter_counts: *const c_void, min_gradient_magnitudes: *const c_void, max_points_part: f32, transform_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdOdometry_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdOdometry_prepareFrameCache_const_PtrLOdometryFrameGR_int(instance: *const c_void, frame: *mut c_void, cache_type: i32, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_rgbd_RgbdOdometry_getCameraMatrix_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdOdometry_setCameraMatrix_const_MatR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdOdometry_getMinDepth_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_RgbdOdometry_setMinDepth_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdOdometry_getMaxDepth_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_RgbdOdometry_setMaxDepth_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdOdometry_getMaxDepthDiff_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_RgbdOdometry_setMaxDepthDiff_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdOdometry_getIterationCounts_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdOdometry_setIterationCounts_const_MatR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdOdometry_getMinGradientMagnitudes_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdOdometry_setMinGradientMagnitudes_const_MatR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdOdometry_getMaxPointsPart_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_RgbdOdometry_setMaxPointsPart_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdOdometry_getTransformType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rgbd_RgbdOdometry_setTransformType_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdOdometry_getMaxTranslation_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_RgbdOdometry_setMaxTranslation_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdOdometry_getMaxRotation_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_RgbdOdometry_setMaxRotation_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdOdometry_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rgbd_RgbdOdometry_to_Odometry(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rgbd_RgbdOdometry_delete(instance: *mut c_void);
		pub fn cv_rgbd_RgbdPlane_RgbdPlane_int(method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdPlane_RgbdPlane(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdPlane_RgbdPlane_int_int_int_double_double_double_double(method: i32, block_size: i32, min_size: i32, threshold: f64, sensor_error_a: f64, sensor_error_b: f64, sensor_error_c: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdPlane_RgbdPlane_int_int_int_double(method: i32, block_size: i32, min_size: i32, threshold: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdPlane_create_int_int_int_double_double_double_double(method: i32, block_size: i32, min_size: i32, threshold: f64, sensor_error_a: f64, sensor_error_b: f64, sensor_error_c: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdPlane_create_int_int_int_double(method: i32, block_size: i32, min_size: i32, threshold: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_rgbd_RgbdPlane_operator___const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, points3d: *const c_void, normals: *const c_void, mask: *const c_void, plane_coefficients: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdPlane_operator___const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, points3d: *const c_void, mask: *const c_void, plane_coefficients: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdPlane_getBlockSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rgbd_RgbdPlane_setBlockSize_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdPlane_getMinSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rgbd_RgbdPlane_setMinSize_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdPlane_getMethod_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_rgbd_RgbdPlane_setMethod_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdPlane_getThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_RgbdPlane_setThreshold_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdPlane_getSensorErrorA_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_RgbdPlane_setSensorErrorA_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdPlane_getSensorErrorB_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_RgbdPlane_setSensorErrorB_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdPlane_getSensorErrorC_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_rgbd_RgbdPlane_setSensorErrorC_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_rgbd_RgbdPlane_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_rgbd_RgbdPlane_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_colored_kinfu_ColoredKinFuG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_colored_kinfu_ColoredKinFuG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_colored_kinfu_ColoredKinFuG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_colored_kinfu_ParamsG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_colored_kinfu_ParamsG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_colored_kinfu_ParamsG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_colored_kinfu_ParamsG_new_const_Params(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_DepthCleanerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_DepthCleanerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_DepthCleanerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_rgbd_DepthCleanerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_DepthCleanerG_new_const_DepthCleaner(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dynafu_DynaFuG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dynafu_DynaFuG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_dynafu_DynaFuG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_rgbd_FastICPOdometryG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_FastICPOdometryG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_FastICPOdometryG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_rgbd_FastICPOdometryG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_FastICPOdometryG_to_PtrOfOdometry(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_FastICPOdometryG_new_const_FastICPOdometry(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_ICPOdometryG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_ICPOdometryG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_ICPOdometryG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_rgbd_ICPOdometryG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_ICPOdometryG_to_PtrOfOdometry(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_ICPOdometryG_new_const_ICPOdometry(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_kinfu_detail_PoseGraphG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_kinfu_detail_PoseGraphG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_kinfu_detail_PoseGraphG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_kinfu_KinFuG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_kinfu_KinFuG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_kinfu_KinFuG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_kinfu_ParamsG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_kinfu_ParamsG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_kinfu_ParamsG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_kinfu_ParamsG_new_const_Params(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_kinfu_VolumeG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_kinfu_VolumeG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_kinfu_VolumeG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_kinfu_VolumeParamsG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_kinfu_VolumeParamsG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_kinfu_VolumeParamsG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_kinfu_VolumeParamsG_new_const_VolumeParams(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_large_kinfu_LargeKinfuG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_large_kinfu_LargeKinfuG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_large_kinfu_LargeKinfuG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_linemod_ColorGradientG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_linemod_ColorGradientG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_linemod_ColorGradientG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_linemod_ColorGradientG_to_PtrOfLineMod_Modality(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_linemod_ColorGradientG_new_const_ColorGradient(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_linemod_DepthNormalG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_linemod_DepthNormalG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_linemod_DepthNormalG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_linemod_DepthNormalG_to_PtrOfLineMod_Modality(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_linemod_DepthNormalG_new_const_DepthNormal(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_linemod_DetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_linemod_DetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_linemod_DetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_linemod_DetectorG_new_const_Detector(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_linemod_ModalityG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_linemod_ModalityG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_linemod_ModalityG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_linemod_QuantizedPyramidG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_linemod_QuantizedPyramidG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_linemod_QuantizedPyramidG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_rgbd_OdometryG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_OdometryG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_OdometryG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_rgbd_OdometryG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_OdometryFrameG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_OdometryFrameG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_OdometryFrameG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_rgbd_OdometryFrameG_to_PtrOfRgbdFrame(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_OdometryFrameG_new_const_OdometryFrame(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_large_kinfu_ParamsG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_large_kinfu_ParamsG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_large_kinfu_ParamsG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_large_kinfu_ParamsG_new_const_Params(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdFrameG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdFrameG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdFrameG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_rgbd_RgbdFrameG_new_const_RgbdFrame(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdICPOdometryG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdICPOdometryG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdICPOdometryG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_rgbd_RgbdICPOdometryG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdICPOdometryG_to_PtrOfOdometry(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdICPOdometryG_new_const_RgbdICPOdometry(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdNormalsG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdNormalsG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdNormalsG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_rgbd_RgbdNormalsG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdNormalsG_new_const_RgbdNormals(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdOdometryG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdOdometryG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdOdometryG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_rgbd_RgbdOdometryG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdOdometryG_to_PtrOfOdometry(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdOdometryG_new_const_RgbdOdometry(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdPlaneG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdPlaneG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdPlaneG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_rgbd_RgbdPlaneG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_rgbd_RgbdPlaneG_new_const_RgbdPlane(val: *mut c_void) -> *mut c_void;
		pub fn std_vectorLcv_linemod_FeatureG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_linemod_FeatureG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_linemod_FeatureG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_linemod_FeatureG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_linemod_FeatureG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_linemod_FeatureG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_linemod_FeatureG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_linemod_FeatureG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_linemod_FeatureG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_linemod_FeatureG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_linemod_FeatureG_push_const_Feature(instance: *mut c_void, val: *const crate::rgbd::LineMod_Feature);
		pub fn std_vectorLcv_linemod_FeatureG_insert_size_t_const_Feature(instance: *mut c_void, index: size_t, val: *const crate::rgbd::LineMod_Feature);
		pub fn std_vectorLcv_linemod_FeatureG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut crate::rgbd::LineMod_Feature);
		pub fn std_vectorLcv_linemod_FeatureG_set_size_t_const_Feature(instance: *mut c_void, index: size_t, val: *const crate::rgbd::LineMod_Feature);
		pub fn std_vectorLcv_linemod_FeatureG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_linemod_FeatureG_data_const(instance: *const c_void) -> *const crate::rgbd::LineMod_Feature;
		pub fn std_vectorLcv_linemod_FeatureG_dataMut(instance: *mut c_void) -> *mut crate::rgbd::LineMod_Feature;
		pub fn cv_fromSlice_const_const_FeatureX_size_t(data: *const crate::rgbd::LineMod_Feature, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_linemod_MatchG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_linemod_MatchG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_linemod_MatchG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_linemod_MatchG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_linemod_MatchG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_linemod_MatchG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_linemod_MatchG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_linemod_MatchG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_linemod_MatchG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_linemod_MatchG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_linemod_MatchG_push_const_Match(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_linemod_MatchG_insert_size_t_const_Match(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_linemod_MatchG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_linemod_MatchG_set_size_t_const_Match(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_linemod_TemplateG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_linemod_TemplateG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_linemod_TemplateG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_linemod_TemplateG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_linemod_TemplateG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_linemod_TemplateG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_linemod_TemplateG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_linemod_TemplateG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_linemod_TemplateG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_linemod_TemplateG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_linemod_TemplateG_push_const_Template(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_linemod_TemplateG_insert_size_t_const_Template(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_linemod_TemplateG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_linemod_TemplateG_set_size_t_const_Template(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_PtrLcv_linemod_ModalityGG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_PtrLcv_linemod_ModalityGG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_PtrLcv_linemod_ModalityGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_PtrLcv_linemod_ModalityGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_PtrLcv_linemod_ModalityGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_PtrLcv_linemod_ModalityGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_PtrLcv_linemod_ModalityGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_PtrLcv_linemod_ModalityGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_PtrLcv_linemod_ModalityGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_PtrLcv_linemod_ModalityGG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_PtrLcv_linemod_ModalityGG_push_const_PtrLModalityG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_PtrLcv_linemod_ModalityGG_insert_size_t_const_PtrLModalityG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_PtrLcv_linemod_ModalityGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_PtrLcv_linemod_ModalityGG_set_size_t_const_PtrLModalityG(instance: *mut c_void, index: size_t, val: *const c_void);
	}
}
#[cfg(ocvrs_has_module_rgbd)]
pub use rgbd_sys::*;

#[cfg(ocvrs_has_module_saliency)]
mod saliency_sys {
	use super::*;

	extern "C" {
		pub fn cv_saliency_MotionSaliency_to_MotionSaliencyBinWangApr2014(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_MotionSaliency_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_MotionSaliency_to_Saliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_MotionSaliency_delete(instance: *mut c_void);
		pub fn cv_saliency_MotionSaliencyBinWangApr2014_MotionSaliencyBinWangApr2014(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_saliency_MotionSaliencyBinWangApr2014_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_saliency_MotionSaliencyBinWangApr2014_computeSaliency_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, saliency_map: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_saliency_MotionSaliencyBinWangApr2014_setImagesize_int_int(instance: *mut c_void, w: i32, h: i32, ocvrs_return: *mut Result_void);
		pub fn cv_saliency_MotionSaliencyBinWangApr2014_init(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_saliency_MotionSaliencyBinWangApr2014_getImageWidth_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_saliency_MotionSaliencyBinWangApr2014_setImageWidth_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_saliency_MotionSaliencyBinWangApr2014_getImageHeight_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_saliency_MotionSaliencyBinWangApr2014_setImageHeight_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_saliency_MotionSaliencyBinWangApr2014_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_MotionSaliencyBinWangApr2014_to_MotionSaliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_MotionSaliencyBinWangApr2014_to_Saliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_MotionSaliencyBinWangApr2014_delete(instance: *mut c_void);
		pub fn cv_saliency_Objectness_to_ObjectnessBING(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_Objectness_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_Objectness_to_Saliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_Objectness_delete(instance: *mut c_void);
		pub fn cv_saliency_ObjectnessBING_ObjectnessBING(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_saliency_ObjectnessBING_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_saliency_ObjectnessBING_computeSaliency_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, saliency_map: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_saliency_ObjectnessBING_read(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_saliency_ObjectnessBING_write_const(instance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_saliency_ObjectnessBING_getobjectnessValues(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_saliency_ObjectnessBING_setTrainingPath_const_StringR(instance: *mut c_void, training_path: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_saliency_ObjectnessBING_setBBResDir_const_StringR(instance: *mut c_void, results_dir: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_saliency_ObjectnessBING_getBase_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_saliency_ObjectnessBING_setBase_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_saliency_ObjectnessBING_getNSS_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_saliency_ObjectnessBING_setNSS_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_saliency_ObjectnessBING_getW_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_saliency_ObjectnessBING_setW_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_saliency_ObjectnessBING_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_ObjectnessBING_to_Objectness(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_ObjectnessBING_to_Saliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_ObjectnessBING_delete(instance: *mut c_void);
		pub fn cv_saliency_Saliency_computeSaliency_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, saliency_map: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_saliency_Saliency_to_MotionSaliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_Saliency_to_MotionSaliencyBinWangApr2014(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_Saliency_to_Objectness(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_Saliency_to_ObjectnessBING(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_Saliency_to_StaticSaliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_Saliency_to_StaticSaliencyFineGrained(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_Saliency_to_StaticSaliencySpectralResidual(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_Saliency_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_Saliency_delete(instance: *mut c_void);
		pub fn cv_saliency_StaticSaliency_computeBinaryMap_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, _saliency_map: *const c_void, _binary_map: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_saliency_StaticSaliency_to_StaticSaliencyFineGrained(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_StaticSaliency_to_StaticSaliencySpectralResidual(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_StaticSaliency_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_StaticSaliency_to_Saliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_StaticSaliency_delete(instance: *mut c_void);
		pub fn cv_saliency_StaticSaliencyFineGrained_StaticSaliencyFineGrained(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_saliency_StaticSaliencyFineGrained_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_saliency_StaticSaliencyFineGrained_computeSaliency_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, saliency_map: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_saliency_StaticSaliencyFineGrained_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_StaticSaliencyFineGrained_to_Saliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_StaticSaliencyFineGrained_to_StaticSaliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_StaticSaliencyFineGrained_delete(instance: *mut c_void);
		pub fn cv_saliency_StaticSaliencySpectralResidual_StaticSaliencySpectralResidual(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_saliency_StaticSaliencySpectralResidual_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_saliency_StaticSaliencySpectralResidual_computeSaliency_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, saliency_map: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_saliency_StaticSaliencySpectralResidual_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_saliency_StaticSaliencySpectralResidual_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_saliency_StaticSaliencySpectralResidual_getImageWidth_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_saliency_StaticSaliencySpectralResidual_setImageWidth_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_saliency_StaticSaliencySpectralResidual_getImageHeight_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_saliency_StaticSaliencySpectralResidual_setImageHeight_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_saliency_StaticSaliencySpectralResidual_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_StaticSaliencySpectralResidual_to_Saliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_StaticSaliencySpectralResidual_to_StaticSaliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_saliency_StaticSaliencySpectralResidual_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_saliency_MotionSaliencyG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_MotionSaliencyG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_MotionSaliencyG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_saliency_MotionSaliencyG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_MotionSaliencyG_to_PtrOfSaliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_MotionSaliencyBinWangApr2014G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_MotionSaliencyBinWangApr2014G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_MotionSaliencyBinWangApr2014G_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_saliency_MotionSaliencyBinWangApr2014G_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_MotionSaliencyBinWangApr2014G_to_PtrOfMotionSaliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_MotionSaliencyBinWangApr2014G_to_PtrOfSaliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_MotionSaliencyBinWangApr2014G_new_const_MotionSaliencyBinWangApr2014(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_ObjectnessG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_ObjectnessG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_ObjectnessG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_saliency_ObjectnessG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_ObjectnessG_to_PtrOfSaliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_ObjectnessBINGG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_ObjectnessBINGG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_ObjectnessBINGG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_saliency_ObjectnessBINGG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_ObjectnessBINGG_to_PtrOfObjectness(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_ObjectnessBINGG_to_PtrOfSaliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_ObjectnessBINGG_new_const_ObjectnessBING(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_SaliencyG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_SaliencyG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_SaliencyG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_saliency_SaliencyG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_StaticSaliencyG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_StaticSaliencyG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_StaticSaliencyG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_saliency_StaticSaliencyG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_StaticSaliencyG_to_PtrOfSaliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_StaticSaliencyFineGrainedG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_StaticSaliencyFineGrainedG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_StaticSaliencyFineGrainedG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_saliency_StaticSaliencyFineGrainedG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_StaticSaliencyFineGrainedG_to_PtrOfSaliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_StaticSaliencyFineGrainedG_to_PtrOfStaticSaliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_StaticSaliencyFineGrainedG_new_const_StaticSaliencyFineGrained(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_StaticSaliencySpectralResidualG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_StaticSaliencySpectralResidualG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_StaticSaliencySpectralResidualG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_saliency_StaticSaliencySpectralResidualG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_StaticSaliencySpectralResidualG_to_PtrOfSaliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_StaticSaliencySpectralResidualG_to_PtrOfStaticSaliency(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_saliency_StaticSaliencySpectralResidualG_new_const_StaticSaliencySpectralResidual(val: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_saliency)]
pub use saliency_sys::*;

#[cfg(ocvrs_has_module_sfm)]
mod sfm_sys {
	use super::*;

	extern "C" {
		pub fn cv_sfm_KRtFromProjection_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(p: *const c_void, k: *const c_void, r: *const c_void, t: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_applyTransformationToPoints_const__InputArrayR_const__InputArrayR_const__OutputArrayR(points: *const c_void, t: *const c_void, transformed_points: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_computeOrientation_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_double(x1: *const c_void, x2: *const c_void, r: *const c_void, t: *const c_void, s: f64, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_depth_const__InputArrayR_const__InputArrayR_const__InputArrayR(r: *const c_void, t: *const c_void, x: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_sfm_essentialFromFundamental_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(f: *const c_void, k1: *const c_void, k2: *const c_void, e: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_essentialFromRt_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(r1: *const c_void, t1: *const c_void, r2: *const c_void, t2: *const c_void, e: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_euclideanToHomogeneous_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_fundamentalFromCorrespondences7PointRobust_const__InputArrayR_const__InputArrayR_double_const__OutputArrayR_const__OutputArrayR(x1: *const c_void, x2: *const c_void, max_error: f64, f: *const c_void, inliers: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_sfm_fundamentalFromCorrespondences7PointRobust_const__InputArrayR_const__InputArrayR_double_const__OutputArrayR_const__OutputArrayR_double(x1: *const c_void, x2: *const c_void, max_error: f64, f: *const c_void, inliers: *const c_void, outliers_probability: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_sfm_fundamentalFromCorrespondences8PointRobust_const__InputArrayR_const__InputArrayR_double_const__OutputArrayR_const__OutputArrayR(x1: *const c_void, x2: *const c_void, max_error: f64, f: *const c_void, inliers: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_sfm_fundamentalFromCorrespondences8PointRobust_const__InputArrayR_const__InputArrayR_double_const__OutputArrayR_const__OutputArrayR_double(x1: *const c_void, x2: *const c_void, max_error: f64, f: *const c_void, inliers: *const c_void, outliers_probability: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_sfm_fundamentalFromEssential_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(e: *const c_void, k1: *const c_void, k2: *const c_void, f: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_fundamentalFromProjections_const__InputArrayR_const__InputArrayR_const__OutputArrayR(p1: *const c_void, p2: *const c_void, f: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_homogeneousToEuclidean_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_importReconstruction_const_StringR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(file: *const c_char, rs: *const c_void, ts: *const c_void, ks: *const c_void, points3d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_importReconstruction_const_StringR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int(file: *const c_char, rs: *const c_void, ts: *const c_void, ks: *const c_void, points3d: *const c_void, file_format: i32, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_isotropicPreconditionerFromPoints_const__InputArrayR_const__OutputArrayR(points: *const c_void, t: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_meanAndVarianceAlongRows_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(a: *const c_void, mean: *const c_void, variance: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_motionFromEssentialChooseSolution_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(rs: *const c_void, ts: *const c_void, k1: *const c_void, x1: *const c_void, k2: *const c_void, x2: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_sfm_motionFromEssential_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(e: *const c_void, rs: *const c_void, ts: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_normalizeFundamental_const__InputArrayR_const__OutputArrayR(f: *const c_void, f_normalized: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_normalizeIsotropicPoints_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(points: *const c_void, normalized_points: *const c_void, t: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_normalizePoints_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(points: *const c_void, normalized_points: *const c_void, t: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_normalizedEightPointSolver_const__InputArrayR_const__InputArrayR_const__OutputArrayR(x1: *const c_void, x2: *const c_void, f: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_preconditionerFromPoints_const__InputArrayR_const__OutputArrayR(points: *const c_void, t: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_projectionFromKRt_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(k: *const c_void, r: *const c_void, t: *const c_void, p: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_projectionsFromFundamental_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(f: *const c_void, p1: *const c_void, p2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_reconstruct_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__InputOutputArrayR(points2d: *const c_void, ps: *const c_void, points3d: *const c_void, k: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_reconstruct_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__InputOutputArrayR_bool(points2d: *const c_void, ps: *const c_void, points3d: *const c_void, k: *const c_void, is_projective: bool, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_reconstruct_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__InputOutputArrayR_const__OutputArrayR(points2d: *const c_void, rs: *const c_void, ts: *const c_void, k: *const c_void, points3d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_reconstruct_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__InputOutputArrayR_const__OutputArrayR_bool(points2d: *const c_void, rs: *const c_void, ts: *const c_void, k: *const c_void, points3d: *const c_void, is_projective: bool, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_reconstruct_const_vectorLStringG_const__OutputArrayR_const__OutputArrayR_const__InputOutputArrayR(images: *const c_void, ps: *const c_void, points3d: *const c_void, k: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_reconstruct_const_vectorLStringG_const__OutputArrayR_const__OutputArrayR_const__InputOutputArrayR_bool(images: *const c_void, ps: *const c_void, points3d: *const c_void, k: *const c_void, is_projective: bool, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_reconstruct_const_vectorLStringG_const__OutputArrayR_const__OutputArrayR_const__InputOutputArrayR_const__OutputArrayR(images: *const c_void, rs: *const c_void, ts: *const c_void, k: *const c_void, points3d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_reconstruct_const_vectorLStringG_const__OutputArrayR_const__OutputArrayR_const__InputOutputArrayR_const__OutputArrayR_bool(images: *const c_void, rs: *const c_void, ts: *const c_void, k: *const c_void, points3d: *const c_void, is_projective: bool, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_relativeCameraMotion_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(r1: *const c_void, t1: *const c_void, r2: *const c_void, t2: *const c_void, r: *const c_void, t: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_skew_const__InputArrayR(x: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_sfm_triangulatePoints_const__InputArrayR_const__InputArrayR_const__OutputArrayR(points2d: *const c_void, projection_matrices: *const c_void, points3d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_BaseSFM_run_const__InputArrayR(instance: *mut c_void, points2d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_BaseSFM_run_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, points2d: *const c_void, k: *const c_void, rs: *const c_void, ts: *const c_void, points3d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_BaseSFM_run_const_vectorLStringGR(instance: *mut c_void, images: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_BaseSFM_run_const_vectorLStringGR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, images: *const c_void, k: *const c_void, rs: *const c_void, ts: *const c_void, points3d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_BaseSFM_getError_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_sfm_BaseSFM_getPoints_const__OutputArrayR(instance: *mut c_void, points3d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_BaseSFM_getIntrinsics_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_sfm_BaseSFM_getCameras_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, rs: *const c_void, ts: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_BaseSFM_setReconstructionOptions_const_libmv_ReconstructionOptionsR(instance: *mut c_void, libmv_reconstruction_options: *const crate::sfm::libmv_ReconstructionOptions, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_BaseSFM_setCameraIntrinsicOptions_const_libmv_CameraIntrinsicsOptionsR(instance: *mut c_void, libmv_camera_intrinsics_options: *const crate::sfm::libmv_CameraIntrinsicsOptions, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_BaseSFM_to_SFMLibmvEuclideanReconstruction(instance: *mut c_void) -> *mut c_void;
		pub fn cv_sfm_BaseSFM_delete(instance: *mut c_void);
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_run_const__InputArrayR(instance: *mut c_void, points2d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_run_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, points2d: *const c_void, k: *const c_void, rs: *const c_void, ts: *const c_void, points3d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_run_const_vectorLStringGR(instance: *mut c_void, images: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_run_const_vectorLStringGR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, images: *const c_void, k: *const c_void, rs: *const c_void, ts: *const c_void, points3d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_getError_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_getPoints_const__OutputArrayR(instance: *mut c_void, points3d: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_getIntrinsics_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_getCameras_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, rs: *const c_void, ts: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_setReconstructionOptions_const_libmv_ReconstructionOptionsR(instance: *mut c_void, libmv_reconstruction_options: *const crate::sfm::libmv_ReconstructionOptions, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_setCameraIntrinsicOptions_const_libmv_CameraIntrinsicsOptionsR(instance: *mut c_void, libmv_camera_intrinsics_options: *const crate::sfm::libmv_CameraIntrinsicsOptions, ocvrs_return: *mut Result_void);
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_create_const_libmv_CameraIntrinsicsOptionsR_const_libmv_ReconstructionOptionsR(camera_instrinsic_options: *const crate::sfm::libmv_CameraIntrinsicsOptions, reconstruction_options: *const crate::sfm::libmv_ReconstructionOptions, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_to_BaseSFM(instance: *mut c_void) -> *mut c_void;
		pub fn cv_sfm_SFMLibmvEuclideanReconstruction_delete(instance: *mut c_void);
		pub fn cv_sfm_libmv_CameraIntrinsicsOptions_libmv_CameraIntrinsicsOptions_const_int_const_double_const_double_const_double_const_double_const_double_const_double_const_double_const_double_const_double(_distortion_model: i32, _focal_length_x: f64, _focal_length_y: f64, _principal_point_x: f64, _principal_point_y: f64, _polynomial_k1: f64, _polynomial_k2: f64, _polynomial_k3: f64, _polynomial_p1: f64, _polynomial_p2: f64, ocvrs_return: *mut Result<crate::sfm::libmv_CameraIntrinsicsOptions>);
		pub fn cv_sfm_libmv_CameraIntrinsicsOptions_libmv_CameraIntrinsicsOptions(ocvrs_return: *mut Result<crate::sfm::libmv_CameraIntrinsicsOptions>);
		pub fn cv_sfm_libmv_ReconstructionOptions_libmv_ReconstructionOptions_const_int_const_int_const_int_const_int_const_int(_keyframe1: i32, _keyframe2: i32, _refine_intrinsics: i32, _select_keyframes: i32, _verbosity_level: i32, ocvrs_return: *mut Result<crate::sfm::libmv_ReconstructionOptions>);
		pub fn cv_sfm_libmv_ReconstructionOptions_libmv_ReconstructionOptions(ocvrs_return: *mut Result<crate::sfm::libmv_ReconstructionOptions>);
		pub fn cv_PtrLcv_sfm_BaseSFMG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_sfm_BaseSFMG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_sfm_BaseSFMG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_sfm_SFMLibmvEuclideanReconstructionG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_sfm_SFMLibmvEuclideanReconstructionG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_sfm_SFMLibmvEuclideanReconstructionG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_sfm_SFMLibmvEuclideanReconstructionG_to_PtrOfBaseSFM(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_sfm)]
pub use sfm_sys::*;

#[cfg(ocvrs_has_module_shape)]
mod shape_sys {
	use super::*;

	extern "C" {
		pub fn cv_EMDL1_const__InputArrayR_const__InputArrayR(signature1: *const c_void, signature2: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_createAffineTransformer_bool(full_affine: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createChiHistogramCostExtractor(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createChiHistogramCostExtractor_int_float(n_dummies: i32, default_cost: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createEMDHistogramCostExtractor(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createEMDHistogramCostExtractor_int_int_float(flag: i32, n_dummies: i32, default_cost: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createEMDL1HistogramCostExtractor(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createEMDL1HistogramCostExtractor_int_float(n_dummies: i32, default_cost: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createHausdorffDistanceExtractor(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createHausdorffDistanceExtractor_int_float(distance_flag: i32, rank_prop: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createNormHistogramCostExtractor(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createNormHistogramCostExtractor_int_int_float(flag: i32, n_dummies: i32, default_cost: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createShapeContextDistanceExtractor(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createShapeContextDistanceExtractor_int_int_float_float_int_const_PtrLHistogramCostExtractorGR_const_PtrLShapeTransformerGR(n_angular_bins: i32, n_radial_bins: i32, inner_radius: f32, outer_radius: f32, iterations: i32, comparer: *const c_void, transformer: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createThinPlateSplineShapeTransformer(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createThinPlateSplineShapeTransformer_double(regularization_parameter: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AffineTransformer_setFullAffine_bool(instance: *mut c_void, full_affine: bool, ocvrs_return: *mut Result_void);
		pub fn cv_AffineTransformer_getFullAffine_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_AffineTransformer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_AffineTransformer_to_ShapeTransformer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_AffineTransformer_delete(instance: *mut c_void);
		pub fn cv_ChiHistogramCostExtractor_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ChiHistogramCostExtractor_to_HistogramCostExtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ChiHistogramCostExtractor_delete(instance: *mut c_void);
		pub fn cv_EMDHistogramCostExtractor_setNormFlag_int(instance: *mut c_void, flag: i32, ocvrs_return: *mut Result_void);
		pub fn cv_EMDHistogramCostExtractor_getNormFlag_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_EMDHistogramCostExtractor_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_EMDHistogramCostExtractor_to_HistogramCostExtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_EMDHistogramCostExtractor_delete(instance: *mut c_void);
		pub fn cv_EMDL1HistogramCostExtractor_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_EMDL1HistogramCostExtractor_to_HistogramCostExtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_EMDL1HistogramCostExtractor_delete(instance: *mut c_void);
		pub fn cv_HausdorffDistanceExtractor_setDistanceFlag_int(instance: *mut c_void, distance_flag: i32, ocvrs_return: *mut Result_void);
		pub fn cv_HausdorffDistanceExtractor_getDistanceFlag_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_HausdorffDistanceExtractor_setRankProportion_float(instance: *mut c_void, rank_proportion: f32, ocvrs_return: *mut Result_void);
		pub fn cv_HausdorffDistanceExtractor_getRankProportion_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_HausdorffDistanceExtractor_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_HausdorffDistanceExtractor_to_ShapeDistanceExtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_HausdorffDistanceExtractor_delete(instance: *mut c_void);
		pub fn cv_HistogramCostExtractor_buildCostMatrix_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, descriptors1: *const c_void, descriptors2: *const c_void, cost_matrix: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_HistogramCostExtractor_setNDummies_int(instance: *mut c_void, n_dummies: i32, ocvrs_return: *mut Result_void);
		pub fn cv_HistogramCostExtractor_getNDummies_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_HistogramCostExtractor_setDefaultCost_float(instance: *mut c_void, default_cost: f32, ocvrs_return: *mut Result_void);
		pub fn cv_HistogramCostExtractor_getDefaultCost_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_HistogramCostExtractor_to_ChiHistogramCostExtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_HistogramCostExtractor_to_EMDHistogramCostExtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_HistogramCostExtractor_to_EMDL1HistogramCostExtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_HistogramCostExtractor_to_NormHistogramCostExtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_HistogramCostExtractor_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_HistogramCostExtractor_delete(instance: *mut c_void);
		pub fn cv_NormHistogramCostExtractor_setNormFlag_int(instance: *mut c_void, flag: i32, ocvrs_return: *mut Result_void);
		pub fn cv_NormHistogramCostExtractor_getNormFlag_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_NormHistogramCostExtractor_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_NormHistogramCostExtractor_to_HistogramCostExtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_NormHistogramCostExtractor_delete(instance: *mut c_void);
		pub fn cv_ShapeContextDistanceExtractor_setAngularBins_int(instance: *mut c_void, n_angular_bins: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ShapeContextDistanceExtractor_getAngularBins_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ShapeContextDistanceExtractor_setRadialBins_int(instance: *mut c_void, n_radial_bins: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ShapeContextDistanceExtractor_getRadialBins_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ShapeContextDistanceExtractor_setInnerRadius_float(instance: *mut c_void, inner_radius: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ShapeContextDistanceExtractor_getInnerRadius_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ShapeContextDistanceExtractor_setOuterRadius_float(instance: *mut c_void, outer_radius: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ShapeContextDistanceExtractor_getOuterRadius_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ShapeContextDistanceExtractor_setRotationInvariant_bool(instance: *mut c_void, rotation_invariant: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ShapeContextDistanceExtractor_getRotationInvariant_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ShapeContextDistanceExtractor_setShapeContextWeight_float(instance: *mut c_void, shape_context_weight: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ShapeContextDistanceExtractor_getShapeContextWeight_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ShapeContextDistanceExtractor_setImageAppearanceWeight_float(instance: *mut c_void, image_appearance_weight: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ShapeContextDistanceExtractor_getImageAppearanceWeight_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ShapeContextDistanceExtractor_setBendingEnergyWeight_float(instance: *mut c_void, bending_energy_weight: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ShapeContextDistanceExtractor_getBendingEnergyWeight_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ShapeContextDistanceExtractor_setImages_const__InputArrayR_const__InputArrayR(instance: *mut c_void, image1: *const c_void, image2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ShapeContextDistanceExtractor_getImages_const_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, image1: *const c_void, image2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ShapeContextDistanceExtractor_setIterations_int(instance: *mut c_void, iterations: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ShapeContextDistanceExtractor_getIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ShapeContextDistanceExtractor_setCostExtractor_PtrLHistogramCostExtractorG(instance: *mut c_void, comparer: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ShapeContextDistanceExtractor_getCostExtractor_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ShapeContextDistanceExtractor_setStdDev_float(instance: *mut c_void, sigma: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ShapeContextDistanceExtractor_getStdDev_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ShapeContextDistanceExtractor_setTransformAlgorithm_PtrLShapeTransformerG(instance: *mut c_void, transformer: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ShapeContextDistanceExtractor_getTransformAlgorithm_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ShapeContextDistanceExtractor_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ShapeContextDistanceExtractor_to_ShapeDistanceExtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ShapeContextDistanceExtractor_delete(instance: *mut c_void);
		pub fn cv_ShapeDistanceExtractor_computeDistance_const__InputArrayR_const__InputArrayR(instance: *mut c_void, contour1: *const c_void, contour2: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ShapeDistanceExtractor_to_HausdorffDistanceExtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ShapeDistanceExtractor_to_ShapeContextDistanceExtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ShapeDistanceExtractor_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ShapeDistanceExtractor_delete(instance: *mut c_void);
		pub fn cv_ShapeTransformer_estimateTransformation_const__InputArrayR_const__InputArrayR_vectorLDMatchGR(instance: *mut c_void, transforming_shape: *const c_void, target_shape: *const c_void, matches: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ShapeTransformer_applyTransformation_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, input: *const c_void, output: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ShapeTransformer_applyTransformation_const__InputArrayR(instance: *mut c_void, input: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ShapeTransformer_warpImage_const_const__InputArrayR_const__OutputArrayR_int_int_const_ScalarR(instance: *const c_void, transforming_image: *const c_void, output: *const c_void, flags: i32, border_mode: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_ShapeTransformer_warpImage_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, transforming_image: *const c_void, output: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ShapeTransformer_to_AffineTransformer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ShapeTransformer_to_ThinPlateSplineShapeTransformer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ShapeTransformer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ShapeTransformer_delete(instance: *mut c_void);
		pub fn cv_ThinPlateSplineShapeTransformer_setRegularizationParameter_double(instance: *mut c_void, beta: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ThinPlateSplineShapeTransformer_getRegularizationParameter_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ThinPlateSplineShapeTransformer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ThinPlateSplineShapeTransformer_to_ShapeTransformer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ThinPlateSplineShapeTransformer_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_AffineTransformerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AffineTransformerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AffineTransformerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_AffineTransformerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AffineTransformerG_to_PtrOfShapeTransformer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ChiHistogramCostExtractorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ChiHistogramCostExtractorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ChiHistogramCostExtractorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ChiHistogramCostExtractorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ChiHistogramCostExtractorG_to_PtrOfHistogramCostExtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_EMDHistogramCostExtractorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_EMDHistogramCostExtractorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_EMDHistogramCostExtractorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_EMDHistogramCostExtractorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_EMDHistogramCostExtractorG_to_PtrOfHistogramCostExtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_EMDL1HistogramCostExtractorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_EMDL1HistogramCostExtractorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_EMDL1HistogramCostExtractorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_EMDL1HistogramCostExtractorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_EMDL1HistogramCostExtractorG_to_PtrOfHistogramCostExtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_HausdorffDistanceExtractorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_HausdorffDistanceExtractorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_HausdorffDistanceExtractorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_HausdorffDistanceExtractorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_HausdorffDistanceExtractorG_to_PtrOfShapeDistanceExtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_HistogramCostExtractorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_HistogramCostExtractorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_HistogramCostExtractorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_HistogramCostExtractorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_NormHistogramCostExtractorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_NormHistogramCostExtractorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_NormHistogramCostExtractorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_NormHistogramCostExtractorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_NormHistogramCostExtractorG_to_PtrOfHistogramCostExtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ShapeContextDistanceExtractorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ShapeContextDistanceExtractorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ShapeContextDistanceExtractorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ShapeContextDistanceExtractorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ShapeContextDistanceExtractorG_to_PtrOfShapeDistanceExtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ShapeDistanceExtractorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ShapeDistanceExtractorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ShapeDistanceExtractorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ShapeDistanceExtractorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ShapeTransformerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ShapeTransformerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ShapeTransformerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ShapeTransformerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ThinPlateSplineShapeTransformerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ThinPlateSplineShapeTransformerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ThinPlateSplineShapeTransformerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ThinPlateSplineShapeTransformerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ThinPlateSplineShapeTransformerG_to_PtrOfShapeTransformer(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_shape)]
pub use shape_sys::*;

#[cfg(ocvrs_has_module_stereo)]
mod stereo_sys {
	use super::*;

	extern "C" {
		pub fn cv_stereo_censusTransform_const_MatR_const_MatR_int_MatR_MatR_const_int(image1: *const c_void, image2: *const c_void, kernel_size: i32, dist1: *mut c_void, dist2: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_stereo_censusTransform_const_MatR_int_MatR_const_int(image1: *const c_void, kernel_size: i32, dist1: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_stereo_modifiedCensusTransform_const_MatR_const_MatR_int_MatR_MatR_const_int(img1: *const c_void, img2: *const c_void, kernel_size: i32, dist1: *mut c_void, dist2: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_stereo_modifiedCensusTransform_const_MatR_const_MatR_int_MatR_MatR_const_int_int_const_MatR_const_MatR(img1: *const c_void, img2: *const c_void, kernel_size: i32, dist1: *mut c_void, dist2: *mut c_void, typ: i32, t: i32, integral_image1: *const c_void, integral_image2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_stereo_modifiedCensusTransform_const_MatR_int_MatR_const_int(img1: *const c_void, kernel_size: i32, dist: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_stereo_modifiedCensusTransform_const_MatR_int_MatR_const_int_int_const_MatR(img1: *const c_void, kernel_size: i32, dist: *mut c_void, typ: i32, t: i32, integral_image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_stereo_starCensusTransform_const_MatR_const_MatR_int_MatR_MatR(img1: *const c_void, img2: *const c_void, kernel_size: i32, dist1: *mut c_void, dist2: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_stereo_starCensusTransform_const_MatR_int_MatR(img1: *const c_void, kernel_size: i32, dist: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_stereo_symetricCensusTransform_const_MatR_const_MatR_int_MatR_MatR_const_int(img1: *const c_void, img2: *const c_void, kernel_size: i32, dist1: *mut c_void, dist2: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_stereo_symetricCensusTransform_const_MatR_int_MatR_const_int(img1: *const c_void, kernel_size: i32, dist1: *mut c_void, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_stereo_MatchQuasiDense_MatchQuasiDense(ocvrs_return: *mut Result<crate::stereo::MatchQuasiDense>);
		pub fn cv_stereo_MatchQuasiDense_operatorL_const_const_MatchQuasiDenseR(instance: *const crate::stereo::MatchQuasiDense, rhs: *const crate::stereo::MatchQuasiDense, ocvrs_return: *mut Result<bool>);
		pub fn cv_stereo_QuasiDenseStereo_loadParameters_String(instance: *mut c_void, filepath: *mut c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_stereo_QuasiDenseStereo_saveParameters_String(instance: *mut c_void, filepath: *mut c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_stereo_QuasiDenseStereo_getSparseMatches_vectorLMatchQuasiDenseGR(instance: *mut c_void, s_matches: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_stereo_QuasiDenseStereo_getDenseMatches_vectorLMatchQuasiDenseGR(instance: *mut c_void, dense_matches: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_stereo_QuasiDenseStereo_process_const_MatR_const_MatR(instance: *mut c_void, img_left: *const c_void, img_right: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_stereo_QuasiDenseStereo_getMatch_const_int_const_int(instance: *mut c_void, x: i32, y: i32, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_stereo_QuasiDenseStereo_getDisparity(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_stereo_QuasiDenseStereo_create_Size_String(mono_img_size: *const core::Size, param_filepath: *mut c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_stereo_QuasiDenseStereo_create_Size(mono_img_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_stereo_QuasiDenseStereo_propParam_const(instance: *const c_void, ocvrs_return: *mut crate::stereo::PropagationParameters);
		pub fn cv_stereo_QuasiDenseStereo_propParam_PropagationParameters(instance: *mut c_void, val: *const crate::stereo::PropagationParameters);
		pub fn cv_stereo_QuasiDenseStereo_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_stereo_QuasiDenseStereoG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_stereo_QuasiDenseStereoG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_stereo_QuasiDenseStereoG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_stereo_MatchQuasiDenseG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_stereo_MatchQuasiDenseG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_stereo_MatchQuasiDenseG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_stereo_MatchQuasiDenseG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_stereo_MatchQuasiDenseG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_stereo_MatchQuasiDenseG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_stereo_MatchQuasiDenseG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_stereo_MatchQuasiDenseG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_stereo_MatchQuasiDenseG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_stereo_MatchQuasiDenseG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_stereo_MatchQuasiDenseG_push_const_MatchQuasiDense(instance: *mut c_void, val: *const crate::stereo::MatchQuasiDense);
		pub fn std_vectorLcv_stereo_MatchQuasiDenseG_insert_size_t_const_MatchQuasiDense(instance: *mut c_void, index: size_t, val: *const crate::stereo::MatchQuasiDense);
		pub fn std_vectorLcv_stereo_MatchQuasiDenseG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut crate::stereo::MatchQuasiDense);
		pub fn std_vectorLcv_stereo_MatchQuasiDenseG_set_size_t_const_MatchQuasiDense(instance: *mut c_void, index: size_t, val: *const crate::stereo::MatchQuasiDense);
		pub fn std_vectorLcv_stereo_MatchQuasiDenseG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_stereo_MatchQuasiDenseG_data_const(instance: *const c_void) -> *const crate::stereo::MatchQuasiDense;
		pub fn std_vectorLcv_stereo_MatchQuasiDenseG_dataMut(instance: *mut c_void) -> *mut crate::stereo::MatchQuasiDense;
		pub fn cv_fromSlice_const_const_MatchQuasiDenseX_size_t(data: *const crate::stereo::MatchQuasiDense, len: size_t) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_stereo)]
pub use stereo_sys::*;

#[cfg(ocvrs_has_module_stitching)]
mod stitching_sys {
	use super::*;

	extern "C" {
		pub fn cv_detail_autoDetectWaveCorrectKind_const_vectorLMatGR(rmats: *const c_void, ocvrs_return: *mut Result<crate::stitching::Detail_WaveCorrectKind>);
		pub fn cv_detail_computeImageFeatures_const_PtrLFeature2DGR_const__InputArrayR_ImageFeaturesR(features_finder: *const c_void, image: *const c_void, features: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_computeImageFeatures_const_PtrLFeature2DGR_const__InputArrayR_ImageFeaturesR_const__InputArrayR(features_finder: *const c_void, image: *const c_void, features: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_computeImageFeatures_const_PtrLFeature2DGR_const__InputArrayR_vectorLImageFeaturesGR(features_finder: *const c_void, images: *const c_void, features: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_computeImageFeatures_const_PtrLFeature2DGR_const__InputArrayR_vectorLImageFeaturesGR_const__InputArrayR(features_finder: *const c_void, images: *const c_void, features: *mut c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_createLaplacePyrGpu_const__InputArrayR_int_vectorLUMatGR(img: *const c_void, num_levels: i32, pyr: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_createLaplacePyr_const__InputArrayR_int_vectorLUMatGR(img: *const c_void, num_levels: i32, pyr: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_createWeightMap_const__InputArrayR_float_const__InputOutputArrayR(mask: *const c_void, sharpness: f32, weight: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_findMaxSpanningTree_int_const_vectorLMatchesInfoGR_GraphR_vectorLintGR(num_images: i32, pairwise_matches: *const c_void, span_tree: *mut c_void, centers: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_leaveBiggestComponent_vectorLImageFeaturesGR_vectorLMatchesInfoGR_float(features: *mut c_void, pairwise_matches: *mut c_void, conf_threshold: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_matchesGraphAsString_vectorLStringGR_vectorLMatchesInfoGR_float(paths: *mut c_void, pairwise_matches: *mut c_void, conf_threshold: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_normalizeUsingWeightMap_const__InputArrayR_const__InputOutputArrayR(weight: *const c_void, src: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_overlapRoi_Point_Point_Size_Size_RectR(tl1: *const core::Point, tl2: *const core::Point, sz1: *const core::Size, sz2: *const core::Size, roi: *mut core::Rect, ocvrs_return: *mut Result<bool>);
		pub fn cv_detail_restoreImageFromLaplacePyrGpu_vectorLUMatGR(pyr: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_restoreImageFromLaplacePyr_vectorLUMatGR(pyr: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_resultRoiIntersection_const_vectorLPointGR_const_vectorLSizeGR(corners: *const c_void, sizes: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_resultRoi_const_vectorLPointGR_const_vectorLSizeGR(corners: *const c_void, sizes: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_resultRoi_const_vectorLPointGR_const_vectorLUMatGR(corners: *const c_void, images: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_resultTl_const_vectorLPointGR(corners: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_selectRandomSubset_int_int_vectorLintGR(count: i32, size: i32, subset: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_stitchingLogLevel(ocvrs_return: *mut Result<i32>);
		pub fn cv_detail_waveCorrect_vectorLMatGR_WaveCorrectKind(rmats: *mut c_void, kind: crate::stitching::Detail_WaveCorrectKind, ocvrs_return: *mut Result_void);
		pub fn cv_AffineWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AffineWarper_to_WarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_AffineWarper_delete(instance: *mut c_void);
		pub fn cv_CompressedRectilinearPortraitWarper_CompressedRectilinearPortraitWarper_float_float(a: f32, b: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CompressedRectilinearPortraitWarper_CompressedRectilinearPortraitWarper(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CompressedRectilinearPortraitWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CompressedRectilinearPortraitWarper_to_WarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_CompressedRectilinearPortraitWarper_delete(instance: *mut c_void);
		pub fn cv_CompressedRectilinearWarper_CompressedRectilinearWarper_float_float(a: f32, b: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CompressedRectilinearWarper_CompressedRectilinearWarper(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CompressedRectilinearWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CompressedRectilinearWarper_to_WarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_CompressedRectilinearWarper_delete(instance: *mut c_void);
		pub fn cv_CylindricalWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CylindricalWarper_to_WarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_CylindricalWarper_delete(instance: *mut c_void);
		pub fn cv_CylindricalWarperGpu_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CylindricalWarperGpu_to_WarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_CylindricalWarperGpu_delete(instance: *mut c_void);
		pub fn cv_FisheyeWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FisheyeWarper_to_WarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_FisheyeWarper_delete(instance: *mut c_void);
		pub fn cv_MercatorWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MercatorWarper_to_WarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MercatorWarper_delete(instance: *mut c_void);
		pub fn cv_PaniniPortraitWarper_PaniniPortraitWarper_float_float(a: f32, b: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PaniniPortraitWarper_PaniniPortraitWarper(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PaniniPortraitWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PaniniPortraitWarper_to_WarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PaniniPortraitWarper_delete(instance: *mut c_void);
		pub fn cv_PaniniWarper_PaniniWarper_float_float(a: f32, b: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PaniniWarper_PaniniWarper(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PaniniWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PaniniWarper_to_WarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PaniniWarper_delete(instance: *mut c_void);
		pub fn cv_PlaneWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PlaneWarper_to_WarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PlaneWarper_delete(instance: *mut c_void);
		pub fn cv_PlaneWarperGpu_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PlaneWarperGpu_to_WarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PlaneWarperGpu_delete(instance: *mut c_void);
		pub fn cv_PyRotationWarper_PyRotationWarper_String_float(typ: *mut c_char, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PyRotationWarper_PyRotationWarper(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PyRotationWarper_warpPoint_const_Point2fR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, r: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_PyRotationWarper_warpPointBackward_const_Point2fR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, r: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_PyRotationWarper_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_PyRotationWarper_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_PyRotationWarper_warpBackward_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_Size_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst_size: *const core::Size, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_PyRotationWarper_warpRoi_Size_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_PyRotationWarper_getScale_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_PyRotationWarper_setScale_float(instance: *mut c_void, unnamed: f32, ocvrs_return: *mut Result_void);
		pub fn cv_PyRotationWarper_delete(instance: *mut c_void);
		pub fn cv_SphericalWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SphericalWarper_to_WarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_SphericalWarper_delete(instance: *mut c_void);
		pub fn cv_SphericalWarperGpu_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SphericalWarperGpu_to_WarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_SphericalWarperGpu_delete(instance: *mut c_void);
		pub fn cv_StereographicWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_StereographicWarper_to_WarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_StereographicWarper_delete(instance: *mut c_void);
		pub fn cv_Stitcher_create_Mode(mode: crate::stitching::Stitcher_Mode, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_registrationResol_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_Stitcher_setRegistrationResol_double(instance: *mut c_void, resol_mpx: f64, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_seamEstimationResol_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_Stitcher_setSeamEstimationResol_double(instance: *mut c_void, resol_mpx: f64, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_compositingResol_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_Stitcher_setCompositingResol_double(instance: *mut c_void, resol_mpx: f64, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_panoConfidenceThresh_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_Stitcher_setPanoConfidenceThresh_double(instance: *mut c_void, conf_thresh: f64, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_waveCorrection_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_Stitcher_setWaveCorrection_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_interpolationFlags_const(instance: *const c_void, ocvrs_return: *mut Result<crate::imgproc::InterpolationFlags>);
		pub fn cv_Stitcher_setInterpolationFlags_InterpolationFlags(instance: *mut c_void, interp_flags: crate::imgproc::InterpolationFlags, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_waveCorrectKind_const(instance: *const c_void, ocvrs_return: *mut Result<crate::stitching::Detail_WaveCorrectKind>);
		pub fn cv_Stitcher_setWaveCorrectKind_WaveCorrectKind(instance: *mut c_void, kind: crate::stitching::Detail_WaveCorrectKind, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_featuresFinder(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_featuresFinder_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_setFeaturesFinder_PtrLFeature2DG(instance: *mut c_void, features_finder: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_featuresMatcher(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_featuresMatcher_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_setFeaturesMatcher_PtrLFeaturesMatcherG(instance: *mut c_void, features_matcher: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_matchingMask_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_setMatchingMask_const_UMatR(instance: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_bundleAdjuster(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_bundleAdjuster_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_setBundleAdjuster_PtrLBundleAdjusterBaseG(instance: *mut c_void, bundle_adjuster: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_estimator(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_estimator_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_setEstimator_PtrLEstimatorG(instance: *mut c_void, estimator: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_warper(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_warper_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_setWarper_PtrLWarperCreatorG(instance: *mut c_void, creator: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_exposureCompensator(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_exposureCompensator_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_setExposureCompensator_PtrLExposureCompensatorG(instance: *mut c_void, exposure_comp: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_seamFinder(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_seamFinder_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_setSeamFinder_PtrLSeamFinderG(instance: *mut c_void, seam_finder: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_blender(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_blender_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_setBlender_PtrLBlenderG(instance: *mut c_void, b: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_Stitcher_estimateTransform_const__InputArrayR_const__InputArrayR(instance: *mut c_void, images: *const c_void, masks: *const c_void, ocvrs_return: *mut Result<crate::stitching::Stitcher_Status>);
		pub fn cv_Stitcher_estimateTransform_const__InputArrayR(instance: *mut c_void, images: *const c_void, ocvrs_return: *mut Result<crate::stitching::Stitcher_Status>);
		pub fn cv_Stitcher_setTransform_const__InputArrayR_const_vectorLCameraParamsGR_const_vectorLintGR(instance: *mut c_void, images: *const c_void, cameras: *const c_void, component: *const c_void, ocvrs_return: *mut Result<crate::stitching::Stitcher_Status>);
		pub fn cv_Stitcher_setTransform_const__InputArrayR_const_vectorLCameraParamsGR(instance: *mut c_void, images: *const c_void, cameras: *const c_void, ocvrs_return: *mut Result<crate::stitching::Stitcher_Status>);
		pub fn cv_Stitcher_composePanorama_const__OutputArrayR(instance: *mut c_void, pano: *const c_void, ocvrs_return: *mut Result<crate::stitching::Stitcher_Status>);
		pub fn cv_Stitcher_composePanorama_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, images: *const c_void, pano: *const c_void, ocvrs_return: *mut Result<crate::stitching::Stitcher_Status>);
		pub fn cv_Stitcher_stitch_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, images: *const c_void, pano: *const c_void, ocvrs_return: *mut Result<crate::stitching::Stitcher_Status>);
		pub fn cv_Stitcher_stitch_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, images: *const c_void, masks: *const c_void, pano: *const c_void, ocvrs_return: *mut Result<crate::stitching::Stitcher_Status>);
		pub fn cv_Stitcher_component_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_cameras_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_workScale_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_Stitcher_resultMask_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Stitcher_delete(instance: *mut c_void);
		pub fn cv_TransverseMercatorWarper_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TransverseMercatorWarper_to_WarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_TransverseMercatorWarper_delete(instance: *mut c_void);
		pub fn cv_WarperCreator_create_const_float(instance: *const c_void, scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_WarperCreator_to_AffineWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_WarperCreator_to_CompressedRectilinearPortraitWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_WarperCreator_to_CompressedRectilinearWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_WarperCreator_to_CylindricalWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_WarperCreator_to_CylindricalWarperGpu(instance: *mut c_void) -> *mut c_void;
		pub fn cv_WarperCreator_to_FisheyeWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_WarperCreator_to_MercatorWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_WarperCreator_to_PaniniPortraitWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_WarperCreator_to_PaniniWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_WarperCreator_to_PlaneWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_WarperCreator_to_PlaneWarperGpu(instance: *mut c_void) -> *mut c_void;
		pub fn cv_WarperCreator_to_SphericalWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_WarperCreator_to_SphericalWarperGpu(instance: *mut c_void) -> *mut c_void;
		pub fn cv_WarperCreator_to_StereographicWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_WarperCreator_to_TransverseMercatorWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_WarperCreator_delete(instance: *mut c_void);
		pub fn cv_detail_AffineBasedEstimator_AffineBasedEstimator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_AffineBasedEstimator_to_Detail_Estimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_AffineBasedEstimator_delete(instance: *mut c_void);
		pub fn cv_detail_AffineBestOf2NearestMatcher_AffineBestOf2NearestMatcher_bool_bool_float_int(full_affine: bool, try_use_gpu: bool, match_conf: f32, num_matches_thresh1: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_AffineBestOf2NearestMatcher_AffineBestOf2NearestMatcher(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_AffineBestOf2NearestMatcher_to_Detail_BestOf2NearestMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_AffineBestOf2NearestMatcher_to_Detail_FeaturesMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_AffineBestOf2NearestMatcher_delete(instance: *mut c_void);
		pub fn cv_detail_AffineWarper_AffineWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_AffineWarper_AffineWarper(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_AffineWarper_warpPoint_const_Point2fR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, h: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_detail_AffineWarper_warpPointBackward_const_Point2fR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, h: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_detail_AffineWarper_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, h: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_AffineWarper_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, h: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_AffineWarper_warpRoi_Size_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, h: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_AffineWarper_to_Detail_PlaneWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_AffineWarper_to_Detail_RotationWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_AffineWarper_delete(instance: *mut c_void);
		pub fn cv_detail_BestOf2NearestMatcher_BestOf2NearestMatcher_bool_float_int_int_double(try_use_gpu: bool, match_conf: f32, num_matches_thresh1: i32, num_matches_thresh2: i32, matches_confindece_thresh: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BestOf2NearestMatcher_BestOf2NearestMatcher(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BestOf2NearestMatcher_collectGarbage(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BestOf2NearestMatcher_create_bool_float_int_int_double(try_use_gpu: bool, match_conf: f32, num_matches_thresh1: i32, num_matches_thresh2: i32, matches_confindece_thresh: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BestOf2NearestMatcher_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BestOf2NearestMatcher_to_Detail_AffineBestOf2NearestMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BestOf2NearestMatcher_to_Detail_BestOf2NearestRangeMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BestOf2NearestMatcher_to_Detail_FeaturesMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BestOf2NearestMatcher_delete(instance: *mut c_void);
		pub fn cv_detail_BestOf2NearestRangeMatcher_BestOf2NearestRangeMatcher_int_bool_float_int_int(range_width: i32, try_use_gpu: bool, match_conf: f32, num_matches_thresh1: i32, num_matches_thresh2: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BestOf2NearestRangeMatcher_BestOf2NearestRangeMatcher(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BestOf2NearestRangeMatcher_to_Detail_BestOf2NearestMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BestOf2NearestRangeMatcher_to_Detail_FeaturesMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BestOf2NearestRangeMatcher_delete(instance: *mut c_void);
		pub fn cv_detail_Blender_createDefault_int_bool(typ: i32, try_gpu: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_Blender_createDefault_int(typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_Blender_prepare_const_vectorLPointGR_const_vectorLSizeGR(instance: *mut c_void, corners: *const c_void, sizes: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_Blender_prepare_Rect(instance: *mut c_void, dst_roi: *const core::Rect, ocvrs_return: *mut Result_void);
		pub fn cv_detail_Blender_feed_const__InputArrayR_const__InputArrayR_Point(instance: *mut c_void, img: *const c_void, mask: *const c_void, tl: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_detail_Blender_blend_const__InputOutputArrayR_const__InputOutputArrayR(instance: *mut c_void, dst: *const c_void, dst_mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_Blender_to_Detail_FeatherBlender(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_Blender_to_Detail_MultiBandBlender(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_Blender_delete(instance: *mut c_void);
		pub fn cv_detail_BlocksChannelsCompensator_BlocksChannelsCompensator_int_int_int(bl_width: i32, bl_height: i32, nr_feeds: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BlocksChannelsCompensator_BlocksChannelsCompensator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BlocksChannelsCompensator_feed_const_vectorLPointGR_const_vectorLUMatGR_const_vectorLpairLcv_UMat__unsigned_charGGR(instance: *mut c_void, corners: *const c_void, images: *const c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksChannelsCompensator_to_Detail_BlocksCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BlocksChannelsCompensator_to_Detail_ExposureCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BlocksChannelsCompensator_delete(instance: *mut c_void);
		pub fn cv_detail_BlocksCompensator_apply_int_Point_const__InputOutputArrayR_const__InputArrayR(instance: *mut c_void, index: i32, corner: *const core::Point, image: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksCompensator_getMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksCompensator_setMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksCompensator_setNrFeeds_int(instance: *mut c_void, nr_feeds: i32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksCompensator_getNrFeeds(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_detail_BlocksCompensator_setSimilarityThreshold_double(instance: *mut c_void, similarity_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksCompensator_getSimilarityThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_detail_BlocksCompensator_setBlockSize_int_int(instance: *mut c_void, width: i32, height: i32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksCompensator_setBlockSize_Size(instance: *mut c_void, size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksCompensator_getBlockSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_detail_BlocksCompensator_setNrGainsFilteringIterations_int(instance: *mut c_void, nr_iterations: i32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksCompensator_getNrGainsFilteringIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_detail_BlocksCompensator_to_Detail_BlocksChannelsCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BlocksCompensator_to_Detail_BlocksGainCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BlocksCompensator_to_Detail_ExposureCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BlocksCompensator_delete(instance: *mut c_void);
		pub fn cv_detail_BlocksGainCompensator_BlocksGainCompensator_int_int(bl_width: i32, bl_height: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BlocksGainCompensator_BlocksGainCompensator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BlocksGainCompensator_BlocksGainCompensator_int_int_int(bl_width: i32, bl_height: i32, nr_feeds: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BlocksGainCompensator_feed_const_vectorLPointGR_const_vectorLUMatGR_const_vectorLpairLcv_UMat__unsigned_charGGR(instance: *mut c_void, corners: *const c_void, images: *const c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksGainCompensator_apply_int_Point_const__InputOutputArrayR_const__InputArrayR(instance: *mut c_void, index: i32, corner: *const core::Point, image: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksGainCompensator_getMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksGainCompensator_setMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BlocksGainCompensator_to_Detail_BlocksCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BlocksGainCompensator_to_Detail_ExposureCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BlocksGainCompensator_delete(instance: *mut c_void);
		pub fn cv_detail_BundleAdjusterAffine_BundleAdjusterAffine(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BundleAdjusterAffine_to_Detail_BundleAdjusterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BundleAdjusterAffine_to_Detail_Estimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BundleAdjusterAffine_delete(instance: *mut c_void);
		pub fn cv_detail_BundleAdjusterAffinePartial_BundleAdjusterAffinePartial(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BundleAdjusterAffinePartial_to_Detail_BundleAdjusterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BundleAdjusterAffinePartial_to_Detail_Estimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BundleAdjusterAffinePartial_delete(instance: *mut c_void);
		pub fn cv_detail_BundleAdjusterBase_refinementMask_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BundleAdjusterBase_setRefinementMask_const_MatR(instance: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BundleAdjusterBase_confThresh_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_detail_BundleAdjusterBase_setConfThresh_double(instance: *mut c_void, conf_thresh: f64, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BundleAdjusterBase_termCriteria(instance: *mut c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_detail_BundleAdjusterBase_setTermCriteria_const_TermCriteriaR(instance: *mut c_void, term_criteria: *const core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_detail_BundleAdjusterBase_to_Detail_BundleAdjusterAffine(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BundleAdjusterBase_to_Detail_BundleAdjusterAffinePartial(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BundleAdjusterBase_to_Detail_BundleAdjusterRay(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BundleAdjusterBase_to_Detail_BundleAdjusterReproj(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BundleAdjusterBase_to_Detail_NoBundleAdjuster(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BundleAdjusterBase_to_Detail_Estimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BundleAdjusterBase_delete(instance: *mut c_void);
		pub fn cv_detail_BundleAdjusterRay_BundleAdjusterRay(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BundleAdjusterRay_to_Detail_BundleAdjusterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BundleAdjusterRay_to_Detail_Estimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BundleAdjusterRay_delete(instance: *mut c_void);
		pub fn cv_detail_BundleAdjusterReproj_BundleAdjusterReproj(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_BundleAdjusterReproj_to_Detail_BundleAdjusterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BundleAdjusterReproj_to_Detail_Estimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_BundleAdjusterReproj_delete(instance: *mut c_void);
		pub fn cv_detail_CameraParams_CameraParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CameraParams_CameraParams_const_CameraParamsR(other: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CameraParams_operatorST_const_CameraParamsR(instance: *mut c_void, other: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_CameraParams_K_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CameraParams_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CameraParams_propFocal_const(instance: *const c_void) -> f64;
		pub fn cv_detail_CameraParams_propFocal_double(instance: *mut c_void, val: f64);
		pub fn cv_detail_CameraParams_propAspect_const(instance: *const c_void) -> f64;
		pub fn cv_detail_CameraParams_propAspect_double(instance: *mut c_void, val: f64);
		pub fn cv_detail_CameraParams_propPpx_const(instance: *const c_void) -> f64;
		pub fn cv_detail_CameraParams_propPpx_double(instance: *mut c_void, val: f64);
		pub fn cv_detail_CameraParams_propPpy_const(instance: *const c_void) -> f64;
		pub fn cv_detail_CameraParams_propPpy_double(instance: *mut c_void, val: f64);
		pub fn cv_detail_CameraParams_propR_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CameraParams_propR_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_detail_CameraParams_propT_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CameraParams_propT_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_detail_CameraParams_delete(instance: *mut c_void);
		pub fn cv_detail_ChannelsCompensator_ChannelsCompensator_int(nr_feeds: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_ChannelsCompensator_ChannelsCompensator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_ChannelsCompensator_feed_const_vectorLPointGR_const_vectorLUMatGR_const_vectorLpairLcv_UMat__unsigned_charGGR(instance: *mut c_void, corners: *const c_void, images: *const c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ChannelsCompensator_apply_int_Point_const__InputOutputArrayR_const__InputArrayR(instance: *mut c_void, index: i32, corner: *const core::Point, image: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ChannelsCompensator_getMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ChannelsCompensator_setMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ChannelsCompensator_setNrFeeds_int(instance: *mut c_void, nr_feeds: i32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ChannelsCompensator_getNrFeeds(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_detail_ChannelsCompensator_setSimilarityThreshold_double(instance: *mut c_void, similarity_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ChannelsCompensator_getSimilarityThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_detail_ChannelsCompensator_gains_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_ChannelsCompensator_to_Detail_ExposureCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_ChannelsCompensator_delete(instance: *mut c_void);
		pub fn cv_detail_CompressedRectilinearPortraitProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_CompressedRectilinearPortraitProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_CompressedRectilinearPortraitProjector_propA_const(instance: *const c_void) -> f32;
		pub fn cv_detail_CompressedRectilinearPortraitProjector_propA_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_CompressedRectilinearPortraitProjector_propB_const(instance: *const c_void) -> f32;
		pub fn cv_detail_CompressedRectilinearPortraitProjector_propB_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_CompressedRectilinearPortraitProjector_to_Detail_ProjectorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_CompressedRectilinearPortraitProjector_delete(instance: *mut c_void);
		pub fn cv_detail_CompressedRectilinearPortraitWarper_CompressedRectilinearPortraitWarper_float_float_float(scale: f32, a: f32, b: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CompressedRectilinearPortraitWarper_CompressedRectilinearPortraitWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CompressedRectilinearPortraitWarper_to_Detail_RotationWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_CompressedRectilinearPortraitWarper_delete(instance: *mut c_void);
		pub fn cv_detail_CompressedRectilinearProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_CompressedRectilinearProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_CompressedRectilinearProjector_propA_const(instance: *const c_void) -> f32;
		pub fn cv_detail_CompressedRectilinearProjector_propA_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_CompressedRectilinearProjector_propB_const(instance: *const c_void) -> f32;
		pub fn cv_detail_CompressedRectilinearProjector_propB_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_CompressedRectilinearProjector_to_Detail_ProjectorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_CompressedRectilinearProjector_delete(instance: *mut c_void);
		pub fn cv_detail_CompressedRectilinearWarper_CompressedRectilinearWarper_float_float_float(scale: f32, a: f32, b: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CompressedRectilinearWarper_CompressedRectilinearWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CompressedRectilinearWarper_to_Detail_RotationWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_CompressedRectilinearWarper_delete(instance: *mut c_void);
		pub fn cv_detail_CylindricalPortraitProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_CylindricalPortraitProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_CylindricalPortraitProjector_to_Detail_ProjectorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_CylindricalPortraitProjector_delete(instance: *mut c_void);
		pub fn cv_detail_CylindricalPortraitWarper_CylindricalPortraitWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CylindricalPortraitWarper_to_Detail_RotationWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_CylindricalPortraitWarper_delete(instance: *mut c_void);
		pub fn cv_detail_CylindricalProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_CylindricalProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_CylindricalProjector_to_Detail_ProjectorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_CylindricalProjector_delete(instance: *mut c_void);
		pub fn cv_detail_CylindricalWarper_CylindricalWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CylindricalWarper_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_CylindricalWarper_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_CylindricalWarper_to_Detail_CylindricalWarperGpu(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_CylindricalWarper_to_Detail_RotationWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_CylindricalWarper_delete(instance: *mut c_void);
		pub fn cv_detail_CylindricalWarperGpu_CylindricalWarperGpu_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_CylindricalWarperGpu_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_CylindricalWarperGpu_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_CylindricalWarperGpu_buildMaps_Size_const__InputArrayR_const__InputArrayR_GpuMatR_GpuMatR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *mut c_void, ymap: *mut c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_CylindricalWarperGpu_warp_const_GpuMatR_const__InputArrayR_const__InputArrayR_int_int_GpuMatR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_CylindricalWarperGpu_to_Detail_CylindricalWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_CylindricalWarperGpu_to_Detail_RotationWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_CylindricalWarperGpu_delete(instance: *mut c_void);
		pub fn cv_detail_DisjointSets_DisjointSets_int(elem_count: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_DisjointSets_DisjointSets(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_DisjointSets_createOneElemSets_int(instance: *mut c_void, elem_count: i32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_DisjointSets_findSetByElem_int(instance: *mut c_void, elem: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_detail_DisjointSets_mergeSets_int_int(instance: *mut c_void, set1: i32, set2: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_detail_DisjointSets_propParent_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_DisjointSets_propParent_vectorLintG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_detail_DisjointSets_propSize_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_DisjointSets_propSize_vectorLintG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_detail_DisjointSets_delete(instance: *mut c_void);
		pub fn cv_detail_DpSeamFinder_DpSeamFinder_CostFunction(cost_func: crate::stitching::Detail_DpSeamFinder_CostFunction, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_DpSeamFinder_DpSeamFinder(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_DpSeamFinder_DpSeamFinder_String(cost_func: *mut c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_DpSeamFinder_costFunction_const(instance: *const c_void, ocvrs_return: *mut Result<crate::stitching::Detail_DpSeamFinder_CostFunction>);
		pub fn cv_detail_DpSeamFinder_setCostFunction_CostFunction(instance: *mut c_void, val: crate::stitching::Detail_DpSeamFinder_CostFunction, ocvrs_return: *mut Result_void);
		pub fn cv_detail_DpSeamFinder_setCostFunction_String(instance: *mut c_void, val: *mut c_char, ocvrs_return: *mut Result_void);
		pub fn cv_detail_DpSeamFinder_find_const_vectorLUMatGR_const_vectorLPointGR_vectorLUMatGR(instance: *mut c_void, src: *const c_void, corners: *const c_void, masks: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_DpSeamFinder_to_Detail_SeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_DpSeamFinder_delete(instance: *mut c_void);
		pub fn cv_detail_Estimator_operator___const_vectorLImageFeaturesGR_const_vectorLMatchesInfoGR_vectorLCameraParamsGR(instance: *mut c_void, features: *const c_void, pairwise_matches: *const c_void, cameras: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_detail_Estimator_to_Detail_AffineBasedEstimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_Estimator_to_Detail_BundleAdjusterAffine(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_Estimator_to_Detail_BundleAdjusterAffinePartial(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_Estimator_to_Detail_BundleAdjusterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_Estimator_to_Detail_BundleAdjusterRay(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_Estimator_to_Detail_BundleAdjusterReproj(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_Estimator_to_Detail_HomographyBasedEstimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_Estimator_to_Detail_NoBundleAdjuster(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_Estimator_delete(instance: *mut c_void);
		pub fn cv_detail_ExposureCompensator_createDefault_int(typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_ExposureCompensator_feed_const_vectorLPointGR_const_vectorLUMatGR_const_vectorLUMatGR(instance: *mut c_void, corners: *const c_void, images: *const c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ExposureCompensator_feed_const_vectorLPointGR_const_vectorLUMatGR_const_vectorLpairLcv_UMat__unsigned_charGGR(instance: *mut c_void, corners: *const c_void, images: *const c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ExposureCompensator_apply_int_Point_const__InputOutputArrayR_const__InputArrayR(instance: *mut c_void, index: i32, corner: *const core::Point, image: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ExposureCompensator_getMatGains_vectorLMatGR(instance: *mut c_void, unnamed: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ExposureCompensator_setMatGains_vectorLMatGR(instance: *mut c_void, unnamed: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ExposureCompensator_setUpdateGain_bool(instance: *mut c_void, b: bool, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ExposureCompensator_getUpdateGain(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_detail_ExposureCompensator_to_Detail_BlocksChannelsCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_ExposureCompensator_to_Detail_BlocksCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_ExposureCompensator_to_Detail_BlocksGainCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_ExposureCompensator_to_Detail_ChannelsCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_ExposureCompensator_to_Detail_GainCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_ExposureCompensator_to_Detail_NoExposureCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_ExposureCompensator_delete(instance: *mut c_void);
		pub fn cv_detail_FeatherBlender_FeatherBlender_float(sharpness: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_FeatherBlender_FeatherBlender(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_FeatherBlender_sharpness_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_detail_FeatherBlender_setSharpness_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FeatherBlender_prepare_Rect(instance: *mut c_void, dst_roi: *const core::Rect, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FeatherBlender_feed_const__InputArrayR_const__InputArrayR_Point(instance: *mut c_void, img: *const c_void, mask: *const c_void, tl: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FeatherBlender_blend_const__InputOutputArrayR_const__InputOutputArrayR(instance: *mut c_void, dst: *const c_void, dst_mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FeatherBlender_createWeightMaps_const_vectorLUMatGR_const_vectorLPointGR_vectorLUMatGR(instance: *mut c_void, masks: *const c_void, corners: *const c_void, weight_maps: *mut c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_FeatherBlender_to_Detail_Blender(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_FeatherBlender_delete(instance: *mut c_void);
		pub fn cv_detail_FeaturesMatcher_operator___const_ImageFeaturesR_const_ImageFeaturesR_MatchesInfoR(instance: *mut c_void, features1: *const c_void, features2: *const c_void, matches_info: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FeaturesMatcher_operator___const_vectorLImageFeaturesGR_vectorLMatchesInfoGR_const_UMatR(instance: *mut c_void, features: *const c_void, pairwise_matches: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FeaturesMatcher_operator___const_vectorLImageFeaturesGR_vectorLMatchesInfoGR(instance: *mut c_void, features: *const c_void, pairwise_matches: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FeaturesMatcher_isThreadSafe_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_detail_FeaturesMatcher_collectGarbage(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FeaturesMatcher_to_Detail_AffineBestOf2NearestMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_FeaturesMatcher_to_Detail_BestOf2NearestMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_FeaturesMatcher_to_Detail_BestOf2NearestRangeMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_FeaturesMatcher_delete(instance: *mut c_void);
		pub fn cv_detail_FisheyeProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FisheyeProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_FisheyeProjector_to_Detail_ProjectorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_FisheyeProjector_delete(instance: *mut c_void);
		pub fn cv_detail_FisheyeWarper_FisheyeWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_FisheyeWarper_to_Detail_RotationWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_FisheyeWarper_delete(instance: *mut c_void);
		pub fn cv_detail_GainCompensator_GainCompensator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_GainCompensator_GainCompensator_int(nr_feeds: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_GainCompensator_feed_const_vectorLPointGR_const_vectorLUMatGR_const_vectorLpairLcv_UMat__unsigned_charGGR(instance: *mut c_void, corners: *const c_void, images: *const c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GainCompensator_singleFeed_const_vectorLPointGR_const_vectorLUMatGR_const_vectorLpairLcv_UMat__unsigned_charGGR(instance: *mut c_void, corners: *const c_void, images: *const c_void, masks: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GainCompensator_apply_int_Point_const__InputOutputArrayR_const__InputArrayR(instance: *mut c_void, index: i32, corner: *const core::Point, image: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GainCompensator_getMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GainCompensator_setMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GainCompensator_setNrFeeds_int(instance: *mut c_void, nr_feeds: i32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GainCompensator_getNrFeeds(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_detail_GainCompensator_setSimilarityThreshold_double(instance: *mut c_void, similarity_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GainCompensator_getSimilarityThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_detail_GainCompensator_prepareSimilarityMask_const_vectorLPointGR_const_vectorLUMatGR(instance: *mut c_void, corners: *const c_void, images: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GainCompensator_gains_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_GainCompensator_to_Detail_ExposureCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_GainCompensator_delete(instance: *mut c_void);
		pub fn cv_detail_Graph_Graph_int(num_vertices: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_Graph_Graph(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_Graph_create_int(instance: *mut c_void, num_vertices: i32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_Graph_numVertices_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_detail_Graph_addEdge_int_int_float(instance: *mut c_void, from: i32, to: i32, weight: f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_Graph_delete(instance: *mut c_void);
		pub fn cv_detail_GraphCutSeamFinder_GraphCutSeamFinder_int_float_float(cost_type: i32, terminal_cost: f32, bad_region_penalty: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_GraphCutSeamFinder_GraphCutSeamFinder(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_GraphCutSeamFinder_GraphCutSeamFinder_String_float_float(cost_type: *mut c_char, terminal_cost: f32, bad_region_penalty: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_GraphCutSeamFinder_GraphCutSeamFinder_String(cost_type: *mut c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_GraphCutSeamFinder_find_const_vectorLUMatGR_const_vectorLPointGR_vectorLUMatGR(instance: *mut c_void, src: *const c_void, corners: *const c_void, masks: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GraphCutSeamFinder_to_Detail_GraphCutSeamFinderBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_GraphCutSeamFinder_to_Detail_SeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_GraphCutSeamFinder_delete(instance: *mut c_void);
		pub fn cv_detail_GraphCutSeamFinderBase_delete(instance: *mut c_void);
		pub fn cv_detail_GraphCutSeamFinderGpu_GraphCutSeamFinderGpu_int_float_float(cost_type: i32, terminal_cost: f32, bad_region_penalty: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_GraphCutSeamFinderGpu_GraphCutSeamFinderGpu(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_GraphCutSeamFinderGpu_find_const_vectorLUMatGR_const_vectorLPointGR_vectorLUMatGR(instance: *mut c_void, src: *const c_void, corners: *const c_void, masks: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GraphCutSeamFinderGpu_findInPair_size_t_size_t_Rect(instance: *mut c_void, first: size_t, second: size_t, roi: *const core::Rect, ocvrs_return: *mut Result_void);
		pub fn cv_detail_GraphCutSeamFinderGpu_to_Detail_GraphCutSeamFinderBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_GraphCutSeamFinderGpu_to_Detail_PairwiseSeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_GraphCutSeamFinderGpu_to_Detail_SeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_GraphCutSeamFinderGpu_delete(instance: *mut c_void);
		pub fn cv_detail_GraphEdge_GraphEdge_int_int_float(from: i32, to: i32, weight: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_GraphEdge_operatorL_const_const_GraphEdgeR(instance: *const c_void, other: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_detail_GraphEdge_operatorG_const_const_GraphEdgeR(instance: *const c_void, other: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_detail_GraphEdge_propFrom_const(instance: *const c_void) -> i32;
		pub fn cv_detail_GraphEdge_propFrom_int(instance: *mut c_void, val: i32);
		pub fn cv_detail_GraphEdge_propTo_const(instance: *const c_void) -> i32;
		pub fn cv_detail_GraphEdge_propTo_int(instance: *mut c_void, val: i32);
		pub fn cv_detail_GraphEdge_propWeight_const(instance: *const c_void) -> f32;
		pub fn cv_detail_GraphEdge_propWeight_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_GraphEdge_delete(instance: *mut c_void);
		pub fn cv_detail_HomographyBasedEstimator_HomographyBasedEstimator_bool(is_focals_estimated: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_HomographyBasedEstimator_HomographyBasedEstimator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_HomographyBasedEstimator_to_Detail_Estimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_HomographyBasedEstimator_delete(instance: *mut c_void);
		pub fn cv_detail_ImageFeatures_getKeypoints(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_ImageFeatures_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_ImageFeatures_defaultNew_const() -> *mut c_void;
		pub fn cv_detail_ImageFeatures_propImg_idx_const(instance: *const c_void) -> i32;
		pub fn cv_detail_ImageFeatures_propImg_idx_int(instance: *mut c_void, val: i32);
		pub fn cv_detail_ImageFeatures_propImg_size_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_detail_ImageFeatures_propImg_size_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_detail_ImageFeatures_propKeypoints_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_ImageFeatures_propKeypoints_vectorLKeyPointG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_detail_ImageFeatures_propDescriptors_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_ImageFeatures_propDescriptors_UMat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_detail_ImageFeatures_delete(instance: *mut c_void);
		pub fn cv_detail_MatchesInfo_MatchesInfo(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_MatchesInfo_MatchesInfo_const_MatchesInfoR(other: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_MatchesInfo_operatorST_const_MatchesInfoR(instance: *mut c_void, other: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_MatchesInfo_getMatches(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_MatchesInfo_getInliers(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_MatchesInfo_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_MatchesInfo_propSrc_img_idx_const(instance: *const c_void) -> i32;
		pub fn cv_detail_MatchesInfo_propSrc_img_idx_int(instance: *mut c_void, val: i32);
		pub fn cv_detail_MatchesInfo_propDst_img_idx_const(instance: *const c_void) -> i32;
		pub fn cv_detail_MatchesInfo_propDst_img_idx_int(instance: *mut c_void, val: i32);
		pub fn cv_detail_MatchesInfo_propMatches_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_MatchesInfo_propMatches_vectorLDMatchG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_detail_MatchesInfo_propInliers_mask_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_MatchesInfo_propInliers_mask_vectorLunsigned_charG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_detail_MatchesInfo_propNum_inliers_const(instance: *const c_void) -> i32;
		pub fn cv_detail_MatchesInfo_propNum_inliers_int(instance: *mut c_void, val: i32);
		pub fn cv_detail_MatchesInfo_propH_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_MatchesInfo_propH_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_detail_MatchesInfo_propConfidence_const(instance: *const c_void) -> f64;
		pub fn cv_detail_MatchesInfo_propConfidence_double(instance: *mut c_void, val: f64);
		pub fn cv_detail_MatchesInfo_delete(instance: *mut c_void);
		pub fn cv_detail_MercatorProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_MercatorProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_MercatorProjector_to_Detail_ProjectorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_MercatorProjector_delete(instance: *mut c_void);
		pub fn cv_detail_MercatorWarper_MercatorWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_MercatorWarper_to_Detail_RotationWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_MercatorWarper_delete(instance: *mut c_void);
		pub fn cv_detail_MultiBandBlender_MultiBandBlender_int_int_int(try_gpu: i32, num_bands: i32, weight_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_MultiBandBlender_MultiBandBlender(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_MultiBandBlender_numBands_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_detail_MultiBandBlender_setNumBands_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_MultiBandBlender_prepare_Rect(instance: *mut c_void, dst_roi: *const core::Rect, ocvrs_return: *mut Result_void);
		pub fn cv_detail_MultiBandBlender_feed_const__InputArrayR_const__InputArrayR_Point(instance: *mut c_void, img: *const c_void, mask: *const c_void, tl: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_detail_MultiBandBlender_blend_const__InputOutputArrayR_const__InputOutputArrayR(instance: *mut c_void, dst: *const c_void, dst_mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_MultiBandBlender_to_Detail_Blender(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_MultiBandBlender_delete(instance: *mut c_void);
		pub fn cv_detail_NoBundleAdjuster_NoBundleAdjuster(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_NoBundleAdjuster_to_Detail_BundleAdjusterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_NoBundleAdjuster_to_Detail_Estimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_NoBundleAdjuster_delete(instance: *mut c_void);
		pub fn cv_detail_NoExposureCompensator_feed_const_vectorLPointGR_const_vectorLUMatGR_const_vectorLpairLcv_UMat__unsigned_charGGR(instance: *mut c_void, unnamed: *const c_void, unnamed_1: *const c_void, unnamed_2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_NoExposureCompensator_apply_int_Point_const__InputOutputArrayR_const__InputArrayR(instance: *mut c_void, unnamed: i32, unnamed_1: *const core::Point, unnamed_2: *const c_void, unnamed_3: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_NoExposureCompensator_getMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_NoExposureCompensator_setMatGains_vectorLMatGR(instance: *mut c_void, umv: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_NoExposureCompensator_to_Detail_ExposureCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_NoExposureCompensator_delete(instance: *mut c_void);
		pub fn cv_detail_NoSeamFinder_find_const_vectorLUMatGR_const_vectorLPointGR_vectorLUMatGR(instance: *mut c_void, unnamed: *const c_void, unnamed_1: *const c_void, unnamed_2: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_NoSeamFinder_to_Detail_SeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_NoSeamFinder_delete(instance: *mut c_void);
		pub fn cv_detail_PairwiseSeamFinder_find_const_vectorLUMatGR_const_vectorLPointGR_vectorLUMatGR(instance: *mut c_void, src: *const c_void, corners: *const c_void, masks: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PairwiseSeamFinder_to_Detail_GraphCutSeamFinderGpu(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_PairwiseSeamFinder_to_Detail_VoronoiSeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_PairwiseSeamFinder_to_Detail_SeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_PairwiseSeamFinder_delete(instance: *mut c_void);
		pub fn cv_detail_PaniniPortraitProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PaniniPortraitProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PaniniPortraitProjector_propA_const(instance: *const c_void) -> f32;
		pub fn cv_detail_PaniniPortraitProjector_propA_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_PaniniPortraitProjector_propB_const(instance: *const c_void) -> f32;
		pub fn cv_detail_PaniniPortraitProjector_propB_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_PaniniPortraitProjector_to_Detail_ProjectorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_PaniniPortraitProjector_delete(instance: *mut c_void);
		pub fn cv_detail_PaniniPortraitWarper_PaniniPortraitWarper_float_float_float(scale: f32, a: f32, b: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_PaniniPortraitWarper_PaniniPortraitWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_PaniniPortraitWarper_to_Detail_RotationWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_PaniniPortraitWarper_delete(instance: *mut c_void);
		pub fn cv_detail_PaniniProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PaniniProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PaniniProjector_propA_const(instance: *const c_void) -> f32;
		pub fn cv_detail_PaniniProjector_propA_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_PaniniProjector_propB_const(instance: *const c_void) -> f32;
		pub fn cv_detail_PaniniProjector_propB_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_PaniniProjector_to_Detail_ProjectorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_PaniniProjector_delete(instance: *mut c_void);
		pub fn cv_detail_PaniniWarper_PaniniWarper_float_float_float(scale: f32, a: f32, b: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_PaniniWarper_PaniniWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_PaniniWarper_to_Detail_RotationWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_PaniniWarper_delete(instance: *mut c_void);
		pub fn cv_detail_PlanePortraitProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PlanePortraitProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PlanePortraitProjector_to_Detail_ProjectorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_PlanePortraitProjector_delete(instance: *mut c_void);
		pub fn cv_detail_PlanePortraitWarper_PlanePortraitWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_PlanePortraitWarper_to_Detail_RotationWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_PlanePortraitWarper_delete(instance: *mut c_void);
		pub fn cv_detail_PlaneProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PlaneProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_PlaneProjector_to_Detail_ProjectorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_PlaneProjector_delete(instance: *mut c_void);
		pub fn cv_detail_PlaneWarper_PlaneWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_PlaneWarper_PlaneWarper(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_PlaneWarper_warpPoint_const_Point2fR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, r: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_detail_PlaneWarper_warpPoint_const_Point2fR_const__InputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, r: *const c_void, t: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_detail_PlaneWarper_warpPointBackward_const_Point2fR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, r: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_detail_PlaneWarper_warpPointBackward_const_Point2fR_const__InputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, r: *const c_void, t: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_detail_PlaneWarper_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, t: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_PlaneWarper_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_PlaneWarper_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_PlaneWarper_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, t: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_PlaneWarper_warpRoi_Size_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_PlaneWarper_warpRoi_Size_const__InputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, t: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_PlaneWarper_to_Detail_AffineWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_PlaneWarper_to_Detail_PlaneWarperGpu(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_PlaneWarper_to_Detail_RotationWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_PlaneWarper_delete(instance: *mut c_void);
		pub fn cv_detail_PlaneWarperGpu_PlaneWarperGpu_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_PlaneWarperGpu_PlaneWarperGpu(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_PlaneWarperGpu_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_PlaneWarperGpu_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, t: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_PlaneWarperGpu_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_PlaneWarperGpu_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, t: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_PlaneWarperGpu_buildMaps_Size_const__InputArrayR_const__InputArrayR_GpuMatR_GpuMatR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *mut c_void, ymap: *mut c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_PlaneWarperGpu_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__InputArrayR_GpuMatR_GpuMatR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, t: *const c_void, xmap: *mut c_void, ymap: *mut c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_PlaneWarperGpu_warp_const_GpuMatR_const__InputArrayR_const__InputArrayR_int_int_GpuMatR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_PlaneWarperGpu_warp_const_GpuMatR_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_GpuMatR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, t: *const c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_PlaneWarperGpu_to_Detail_PlaneWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_PlaneWarperGpu_to_Detail_RotationWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_PlaneWarperGpu_delete(instance: *mut c_void);
		pub fn cv_detail_ProjectorBase_setCameraParams_const__InputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, k: *const c_void, r: *const c_void, t: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ProjectorBase_setCameraParams(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_ProjectorBase_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_ProjectorBase_defaultNew_const() -> *mut c_void;
		pub fn cv_detail_ProjectorBase_propScale_const(instance: *const c_void) -> f32;
		pub fn cv_detail_ProjectorBase_propScale_float(instance: *mut c_void, val: f32);
		pub fn cv_detail_ProjectorBase_propK(instance: *mut c_void) -> *mut [f32; 9];
		pub fn cv_detail_ProjectorBase_propRinv(instance: *mut c_void) -> *mut [f32; 9];
		pub fn cv_detail_ProjectorBase_propR_kinv(instance: *mut c_void) -> *mut [f32; 9];
		pub fn cv_detail_ProjectorBase_propK_rinv(instance: *mut c_void) -> *mut [f32; 9];
		pub fn cv_detail_ProjectorBase_propT(instance: *mut c_void) -> *mut [f32; 3];
		pub fn cv_detail_ProjectorBase_delete(instance: *mut c_void);
		pub fn cv_detail_RotationWarper_warpPoint_const_Point2fR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, r: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_detail_RotationWarper_warpPointBackward_const_Point2fR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, pt: *const core::Point2f, k: *const c_void, r: *const c_void, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_detail_RotationWarper_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_RotationWarper_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_RotationWarper_warpBackward_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_Size_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst_size: *const core::Size, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_RotationWarper_warpRoi_Size_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_RotationWarper_getScale_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_detail_RotationWarper_setScale_float(instance: *mut c_void, unnamed: f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_RotationWarper_delete(instance: *mut c_void);
		pub fn cv_detail_SeamFinder_find_const_vectorLUMatGR_const_vectorLPointGR_vectorLUMatGR(instance: *mut c_void, src: *const c_void, corners: *const c_void, masks: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_SeamFinder_createDefault_int(typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_SeamFinder_to_Detail_DpSeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_SeamFinder_to_Detail_GraphCutSeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_SeamFinder_to_Detail_GraphCutSeamFinderGpu(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_SeamFinder_to_Detail_NoSeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_SeamFinder_to_Detail_PairwiseSeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_SeamFinder_to_Detail_VoronoiSeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_SeamFinder_delete(instance: *mut c_void);
		pub fn cv_detail_SphericalPortraitProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_SphericalPortraitProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_SphericalPortraitProjector_to_Detail_ProjectorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_SphericalPortraitProjector_delete(instance: *mut c_void);
		pub fn cv_detail_SphericalPortraitWarper_SphericalPortraitWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_SphericalPortraitWarper_to_Detail_RotationWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_SphericalPortraitWarper_delete(instance: *mut c_void);
		pub fn cv_detail_SphericalProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_SphericalProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_SphericalProjector_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_SphericalProjector_defaultNew_const() -> *mut c_void;
		pub fn cv_detail_SphericalProjector_to_Detail_ProjectorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_SphericalProjector_delete(instance: *mut c_void);
		pub fn cv_detail_SphericalWarper_SphericalWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_SphericalWarper_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_SphericalWarper_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_SphericalWarper_to_Detail_SphericalWarperGpu(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_SphericalWarper_to_Detail_RotationWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_SphericalWarper_delete(instance: *mut c_void);
		pub fn cv_detail_SphericalWarperGpu_SphericalWarperGpu_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_SphericalWarperGpu_buildMaps_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *const c_void, ymap: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_SphericalWarperGpu_warp_const__InputArrayR_const__InputArrayR_const__InputArrayR_int_int_const__OutputArrayR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_SphericalWarperGpu_buildMaps_Size_const__InputArrayR_const__InputArrayR_GpuMatR_GpuMatR(instance: *mut c_void, src_size: *const core::Size, k: *const c_void, r: *const c_void, xmap: *mut c_void, ymap: *mut c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_detail_SphericalWarperGpu_warp_const_GpuMatR_const__InputArrayR_const__InputArrayR_int_int_GpuMatR(instance: *mut c_void, src: *const c_void, k: *const c_void, r: *const c_void, interp_mode: i32, border_mode: i32, dst: *mut c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_detail_SphericalWarperGpu_to_Detail_RotationWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_SphericalWarperGpu_to_Detail_SphericalWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_SphericalWarperGpu_delete(instance: *mut c_void);
		pub fn cv_detail_StereographicProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_StereographicProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_StereographicProjector_to_Detail_ProjectorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_StereographicProjector_delete(instance: *mut c_void);
		pub fn cv_detail_StereographicWarper_StereographicWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_StereographicWarper_to_Detail_RotationWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_StereographicWarper_delete(instance: *mut c_void);
		pub fn cv_detail_TransverseMercatorProjector_mapForward_float_float_floatR_floatR(instance: *mut c_void, x: f32, y: f32, u: *mut f32, v: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_TransverseMercatorProjector_mapBackward_float_float_floatR_floatR(instance: *mut c_void, u: f32, v: f32, x: *mut f32, y: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_detail_TransverseMercatorProjector_to_Detail_ProjectorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_TransverseMercatorProjector_delete(instance: *mut c_void);
		pub fn cv_detail_TransverseMercatorWarper_TransverseMercatorWarper_float(scale: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_TransverseMercatorWarper_to_Detail_RotationWarper(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_TransverseMercatorWarper_delete(instance: *mut c_void);
		pub fn cv_detail_VoronoiSeamFinder_find_const_vectorLUMatGR_const_vectorLPointGR_vectorLUMatGR(instance: *mut c_void, src: *const c_void, corners: *const c_void, masks: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_VoronoiSeamFinder_find_const_vectorLSizeGR_const_vectorLPointGR_vectorLUMatGR(instance: *mut c_void, size: *const c_void, corners: *const c_void, masks: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_detail_VoronoiSeamFinder_to_Detail_PairwiseSeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_VoronoiSeamFinder_to_Detail_SeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_detail_VoronoiSeamFinder_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_AffineWarperG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AffineWarperG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AffineWarperG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_AffineWarperG_to_PtrOfWarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AffineWarperG_new_const_AffineWarper(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CompressedRectilinearPortraitWarperG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CompressedRectilinearPortraitWarperG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CompressedRectilinearPortraitWarperG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_CompressedRectilinearPortraitWarperG_to_PtrOfWarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CompressedRectilinearPortraitWarperG_new_const_CompressedRectilinearPortraitWarper(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CompressedRectilinearWarperG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CompressedRectilinearWarperG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CompressedRectilinearWarperG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_CompressedRectilinearWarperG_to_PtrOfWarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CompressedRectilinearWarperG_new_const_CompressedRectilinearWarper(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CylindricalWarperG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CylindricalWarperG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CylindricalWarperG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_CylindricalWarperG_to_PtrOfWarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CylindricalWarperG_new_const_CylindricalWarper(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CylindricalWarperGpuG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CylindricalWarperGpuG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CylindricalWarperGpuG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_CylindricalWarperGpuG_to_PtrOfWarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CylindricalWarperGpuG_new_const_CylindricalWarperGpu(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_AffineBasedEstimatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_AffineBasedEstimatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_AffineBasedEstimatorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_AffineBasedEstimatorG_to_PtrOfDetail_Estimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_AffineBasedEstimatorG_new_const_AffineBasedEstimator(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_AffineBestOf2NearestMatcherG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_AffineBestOf2NearestMatcherG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_AffineBestOf2NearestMatcherG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_AffineBestOf2NearestMatcherG_to_PtrOfDetail_BestOf2NearestMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_AffineBestOf2NearestMatcherG_to_PtrOfDetail_FeaturesMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_AffineBestOf2NearestMatcherG_new_const_AffineBestOf2NearestMatcher(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BestOf2NearestMatcherG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BestOf2NearestMatcherG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BestOf2NearestMatcherG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_BestOf2NearestMatcherG_to_PtrOfDetail_FeaturesMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BestOf2NearestMatcherG_new_const_BestOf2NearestMatcher(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BestOf2NearestRangeMatcherG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BestOf2NearestRangeMatcherG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BestOf2NearestRangeMatcherG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_BestOf2NearestRangeMatcherG_to_PtrOfDetail_BestOf2NearestMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BestOf2NearestRangeMatcherG_to_PtrOfDetail_FeaturesMatcher(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BestOf2NearestRangeMatcherG_new_const_BestOf2NearestRangeMatcher(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BlenderG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BlenderG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BlenderG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_BlenderG_new_const_Blender(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BlocksChannelsCompensatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BlocksChannelsCompensatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BlocksChannelsCompensatorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_BlocksChannelsCompensatorG_to_PtrOfDetail_BlocksCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BlocksChannelsCompensatorG_to_PtrOfDetail_ExposureCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BlocksChannelsCompensatorG_new_const_BlocksChannelsCompensator(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BlocksCompensatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BlocksCompensatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BlocksCompensatorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_BlocksCompensatorG_to_PtrOfDetail_ExposureCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BlocksGainCompensatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BlocksGainCompensatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BlocksGainCompensatorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_BlocksGainCompensatorG_to_PtrOfDetail_BlocksCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BlocksGainCompensatorG_to_PtrOfDetail_ExposureCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BlocksGainCompensatorG_new_const_BlocksGainCompensator(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterAffineG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterAffineG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterAffineG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_BundleAdjusterAffineG_to_PtrOfDetail_BundleAdjusterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterAffineG_to_PtrOfDetail_Estimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterAffineG_new_const_BundleAdjusterAffine(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterAffinePartialG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterAffinePartialG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterAffinePartialG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_BundleAdjusterAffinePartialG_to_PtrOfDetail_BundleAdjusterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterAffinePartialG_to_PtrOfDetail_Estimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterAffinePartialG_new_const_BundleAdjusterAffinePartial(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterBaseG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterBaseG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterBaseG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_BundleAdjusterBaseG_to_PtrOfDetail_Estimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterRayG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterRayG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterRayG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_BundleAdjusterRayG_to_PtrOfDetail_BundleAdjusterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterRayG_to_PtrOfDetail_Estimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterRayG_new_const_BundleAdjusterRay(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterReprojG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterReprojG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterReprojG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_BundleAdjusterReprojG_to_PtrOfDetail_BundleAdjusterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterReprojG_to_PtrOfDetail_Estimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_BundleAdjusterReprojG_new_const_BundleAdjusterReproj(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_ChannelsCompensatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_ChannelsCompensatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_ChannelsCompensatorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_ChannelsCompensatorG_to_PtrOfDetail_ExposureCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_ChannelsCompensatorG_new_const_ChannelsCompensator(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_DpSeamFinderG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_DpSeamFinderG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_DpSeamFinderG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_DpSeamFinderG_to_PtrOfDetail_SeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_DpSeamFinderG_new_const_DpSeamFinder(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_EstimatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_EstimatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_EstimatorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_ExposureCompensatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_ExposureCompensatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_ExposureCompensatorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_FeatherBlenderG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_FeatherBlenderG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_FeatherBlenderG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_FeatherBlenderG_to_PtrOfDetail_Blender(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_FeatherBlenderG_new_const_FeatherBlender(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_FeaturesMatcherG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_FeaturesMatcherG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_FeaturesMatcherG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_GainCompensatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_GainCompensatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_GainCompensatorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_GainCompensatorG_to_PtrOfDetail_ExposureCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_GainCompensatorG_new_const_GainCompensator(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_GraphCutSeamFinderG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_GraphCutSeamFinderG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_GraphCutSeamFinderG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_GraphCutSeamFinderG_to_PtrOfDetail_GraphCutSeamFinderBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_GraphCutSeamFinderG_to_PtrOfDetail_SeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_GraphCutSeamFinderG_new_const_GraphCutSeamFinder(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_GraphCutSeamFinderBaseG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_GraphCutSeamFinderBaseG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_GraphCutSeamFinderBaseG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_GraphCutSeamFinderBaseG_new_const_GraphCutSeamFinderBase(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_GraphCutSeamFinderGpuG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_GraphCutSeamFinderGpuG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_GraphCutSeamFinderGpuG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_GraphCutSeamFinderGpuG_to_PtrOfDetail_GraphCutSeamFinderBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_GraphCutSeamFinderGpuG_to_PtrOfDetail_PairwiseSeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_GraphCutSeamFinderGpuG_to_PtrOfDetail_SeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_GraphCutSeamFinderGpuG_new_const_GraphCutSeamFinderGpu(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_HomographyBasedEstimatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_HomographyBasedEstimatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_HomographyBasedEstimatorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_HomographyBasedEstimatorG_to_PtrOfDetail_Estimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_HomographyBasedEstimatorG_new_const_HomographyBasedEstimator(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_MultiBandBlenderG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_MultiBandBlenderG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_MultiBandBlenderG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_MultiBandBlenderG_to_PtrOfDetail_Blender(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_MultiBandBlenderG_new_const_MultiBandBlender(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_NoBundleAdjusterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_NoBundleAdjusterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_NoBundleAdjusterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_NoBundleAdjusterG_to_PtrOfDetail_BundleAdjusterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_NoBundleAdjusterG_to_PtrOfDetail_Estimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_NoBundleAdjusterG_new_const_NoBundleAdjuster(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_NoExposureCompensatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_NoExposureCompensatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_NoExposureCompensatorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_NoExposureCompensatorG_to_PtrOfDetail_ExposureCompensator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_NoExposureCompensatorG_new_const_NoExposureCompensator(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_NoSeamFinderG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_NoSeamFinderG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_NoSeamFinderG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_NoSeamFinderG_to_PtrOfDetail_SeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_NoSeamFinderG_new_const_NoSeamFinder(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_PairwiseSeamFinderG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_PairwiseSeamFinderG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_PairwiseSeamFinderG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_PairwiseSeamFinderG_to_PtrOfDetail_SeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_RotationWarperG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_RotationWarperG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_RotationWarperG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_SeamFinderG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_SeamFinderG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_SeamFinderG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_VoronoiSeamFinderG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_VoronoiSeamFinderG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_VoronoiSeamFinderG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_detail_VoronoiSeamFinderG_to_PtrOfDetail_PairwiseSeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_VoronoiSeamFinderG_to_PtrOfDetail_SeamFinder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_detail_VoronoiSeamFinderG_new_const_VoronoiSeamFinder(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FisheyeWarperG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FisheyeWarperG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FisheyeWarperG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_FisheyeWarperG_to_PtrOfWarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FisheyeWarperG_new_const_FisheyeWarper(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MercatorWarperG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MercatorWarperG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MercatorWarperG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_MercatorWarperG_to_PtrOfWarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MercatorWarperG_new_const_MercatorWarper(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_PaniniPortraitWarperG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_PaniniPortraitWarperG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_PaniniPortraitWarperG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_PaniniPortraitWarperG_to_PtrOfWarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_PaniniPortraitWarperG_new_const_PaniniPortraitWarper(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_PaniniWarperG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_PaniniWarperG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_PaniniWarperG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_PaniniWarperG_to_PtrOfWarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_PaniniWarperG_new_const_PaniniWarper(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_PlaneWarperG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_PlaneWarperG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_PlaneWarperG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_PlaneWarperG_to_PtrOfWarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_PlaneWarperG_new_const_PlaneWarper(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_PlaneWarperGpuG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_PlaneWarperGpuG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_PlaneWarperGpuG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_PlaneWarperGpuG_to_PtrOfWarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_PlaneWarperGpuG_new_const_PlaneWarperGpu(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SphericalWarperG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SphericalWarperG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SphericalWarperG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_SphericalWarperG_to_PtrOfWarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SphericalWarperG_new_const_SphericalWarper(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SphericalWarperGpuG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SphericalWarperGpuG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SphericalWarperGpuG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_SphericalWarperGpuG_to_PtrOfWarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SphericalWarperGpuG_new_const_SphericalWarperGpu(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_StereographicWarperG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_StereographicWarperG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_StereographicWarperG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_StereographicWarperG_to_PtrOfWarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_StereographicWarperG_new_const_StereographicWarper(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_StitcherG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_StitcherG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_StitcherG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_StitcherG_new_const_Stitcher(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TransverseMercatorWarperG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TransverseMercatorWarperG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TransverseMercatorWarperG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_TransverseMercatorWarperG_to_PtrOfWarperCreator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TransverseMercatorWarperG_new_const_TransverseMercatorWarper(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_WarperCreatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_WarperCreatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_WarperCreatorG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_detail_CameraParamsG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_detail_CameraParamsG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_detail_CameraParamsG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_detail_CameraParamsG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_detail_CameraParamsG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_detail_CameraParamsG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_detail_CameraParamsG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_detail_CameraParamsG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_detail_CameraParamsG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_detail_CameraParamsG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_detail_CameraParamsG_push_const_CameraParams(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_detail_CameraParamsG_insert_size_t_const_CameraParams(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_detail_CameraParamsG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_detail_CameraParamsG_set_size_t_const_CameraParams(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_detail_ImageFeaturesG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_detail_ImageFeaturesG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_detail_ImageFeaturesG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_detail_ImageFeaturesG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_detail_ImageFeaturesG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_detail_ImageFeaturesG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_detail_ImageFeaturesG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_detail_ImageFeaturesG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_detail_ImageFeaturesG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_detail_ImageFeaturesG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_detail_ImageFeaturesG_push_const_ImageFeatures(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_detail_ImageFeaturesG_insert_size_t_const_ImageFeatures(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_detail_ImageFeaturesG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_detail_ImageFeaturesG_set_size_t_const_ImageFeatures(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_detail_MatchesInfoG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_detail_MatchesInfoG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_detail_MatchesInfoG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_detail_MatchesInfoG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_detail_MatchesInfoG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_detail_MatchesInfoG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_detail_MatchesInfoG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_detail_MatchesInfoG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_detail_MatchesInfoG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_detail_MatchesInfoG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_detail_MatchesInfoG_push_const_MatchesInfo(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_detail_MatchesInfoG_insert_size_t_const_MatchesInfo(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_detail_MatchesInfoG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_detail_MatchesInfoG_set_size_t_const_MatchesInfo(instance: *mut c_void, index: size_t, val: *const c_void);
	}
}
#[cfg(ocvrs_has_module_stitching)]
pub use stitching_sys::*;

#[cfg(ocvrs_has_module_structured_light)]
mod structured_light_sys {
	use super::*;

	extern "C" {
		pub fn cv_structured_light_GrayCodePattern_create_const_ParamsR(parameters: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_structured_light_GrayCodePattern_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_structured_light_GrayCodePattern_create_int_int(width: i32, height: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_structured_light_GrayCodePattern_getNumberOfPatternImages_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_structured_light_GrayCodePattern_setWhiteThreshold_size_t(instance: *mut c_void, value: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_structured_light_GrayCodePattern_setBlackThreshold_size_t(instance: *mut c_void, value: size_t, ocvrs_return: *mut Result_void);
		pub fn cv_structured_light_GrayCodePattern_getImagesForShadowMasks_const_const__InputOutputArrayR_const__InputOutputArrayR(instance: *const c_void, black_image: *const c_void, white_image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_structured_light_GrayCodePattern_getProjPixel_const_const__InputArrayR_int_int_PointR(instance: *const c_void, pattern_images: *const c_void, x: i32, y: i32, proj_pix: *mut core::Point, ocvrs_return: *mut Result<bool>);
		pub fn cv_structured_light_GrayCodePattern_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_structured_light_GrayCodePattern_to_StructuredLightPattern(instance: *mut c_void) -> *mut c_void;
		pub fn cv_structured_light_GrayCodePattern_delete(instance: *mut c_void);
		pub fn cv_structured_light_GrayCodePattern_Params_Params(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_structured_light_GrayCodePattern_Params_propWidth_const(instance: *const c_void) -> i32;
		pub fn cv_structured_light_GrayCodePattern_Params_propWidth_int(instance: *mut c_void, val: i32);
		pub fn cv_structured_light_GrayCodePattern_Params_propHeight_const(instance: *const c_void) -> i32;
		pub fn cv_structured_light_GrayCodePattern_Params_propHeight_int(instance: *mut c_void, val: i32);
		pub fn cv_structured_light_GrayCodePattern_Params_delete(instance: *mut c_void);
		pub fn cv_structured_light_SinusoidalPattern_create_PtrLParamsG(parameters: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_structured_light_SinusoidalPattern_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_structured_light_SinusoidalPattern_computePhaseMap_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__InputArrayR(instance: *mut c_void, pattern_images: *const c_void, wrapped_phase_map: *const c_void, shadow_mask: *const c_void, fundamental: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_structured_light_SinusoidalPattern_computePhaseMap_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, pattern_images: *const c_void, wrapped_phase_map: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_structured_light_SinusoidalPattern_unwrapPhaseMap_const__InputArrayR_const__OutputArrayR_Size_const__InputArrayR(instance: *mut c_void, wrapped_phase_map: *const c_void, unwrapped_phase_map: *const c_void, cam_size: *const core::Size, shadow_mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_structured_light_SinusoidalPattern_unwrapPhaseMap_const__InputArrayR_const__OutputArrayR_Size(instance: *mut c_void, wrapped_phase_map: *const c_void, unwrapped_phase_map: *const c_void, cam_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_structured_light_SinusoidalPattern_findProCamMatches_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, proj_unwrapped_phase_map: *const c_void, cam_unwrapped_phase_map: *const c_void, matches: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_structured_light_SinusoidalPattern_computeDataModulationTerm_const__InputArrayR_const__OutputArrayR_const__InputArrayR(instance: *mut c_void, pattern_images: *const c_void, data_modulation_term: *const c_void, shadow_mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_structured_light_SinusoidalPattern_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_structured_light_SinusoidalPattern_to_StructuredLightPattern(instance: *mut c_void) -> *mut c_void;
		pub fn cv_structured_light_SinusoidalPattern_delete(instance: *mut c_void);
		pub fn cv_structured_light_SinusoidalPattern_Params_Params(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_structured_light_SinusoidalPattern_Params_propWidth_const(instance: *const c_void) -> i32;
		pub fn cv_structured_light_SinusoidalPattern_Params_propWidth_int(instance: *mut c_void, val: i32);
		pub fn cv_structured_light_SinusoidalPattern_Params_propHeight_const(instance: *const c_void) -> i32;
		pub fn cv_structured_light_SinusoidalPattern_Params_propHeight_int(instance: *mut c_void, val: i32);
		pub fn cv_structured_light_SinusoidalPattern_Params_propNbrOfPeriods_const(instance: *const c_void) -> i32;
		pub fn cv_structured_light_SinusoidalPattern_Params_propNbrOfPeriods_int(instance: *mut c_void, val: i32);
		pub fn cv_structured_light_SinusoidalPattern_Params_propShiftValue_const(instance: *const c_void) -> f32;
		pub fn cv_structured_light_SinusoidalPattern_Params_propShiftValue_float(instance: *mut c_void, val: f32);
		pub fn cv_structured_light_SinusoidalPattern_Params_propMethodId_const(instance: *const c_void) -> i32;
		pub fn cv_structured_light_SinusoidalPattern_Params_propMethodId_int(instance: *mut c_void, val: i32);
		pub fn cv_structured_light_SinusoidalPattern_Params_propNbrOfPixelsBetweenMarkers_const(instance: *const c_void) -> i32;
		pub fn cv_structured_light_SinusoidalPattern_Params_propNbrOfPixelsBetweenMarkers_int(instance: *mut c_void, val: i32);
		pub fn cv_structured_light_SinusoidalPattern_Params_propHorizontal_const(instance: *const c_void) -> bool;
		pub fn cv_structured_light_SinusoidalPattern_Params_propHorizontal_bool(instance: *mut c_void, val: bool);
		pub fn cv_structured_light_SinusoidalPattern_Params_propSetMarkers_const(instance: *const c_void) -> bool;
		pub fn cv_structured_light_SinusoidalPattern_Params_propSetMarkers_bool(instance: *mut c_void, val: bool);
		pub fn cv_structured_light_SinusoidalPattern_Params_propMarkersLocation_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_structured_light_SinusoidalPattern_Params_propMarkersLocation_vectorLPoint2fG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_structured_light_SinusoidalPattern_Params_delete(instance: *mut c_void);
		pub fn cv_structured_light_StructuredLightPattern_generate_const__OutputArrayR(instance: *mut c_void, pattern_images: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_structured_light_StructuredLightPattern_decode_const_const_vectorLvectorLMatGGR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_int(instance: *const c_void, pattern_images: *const c_void, disparity_map: *const c_void, black_images: *const c_void, white_images: *const c_void, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_structured_light_StructuredLightPattern_decode_const_const_vectorLvectorLMatGGR_const__OutputArrayR(instance: *const c_void, pattern_images: *const c_void, disparity_map: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_structured_light_StructuredLightPattern_to_GrayCodePattern(instance: *mut c_void) -> *mut c_void;
		pub fn cv_structured_light_StructuredLightPattern_to_SinusoidalPattern(instance: *mut c_void) -> *mut c_void;
		pub fn cv_structured_light_StructuredLightPattern_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_structured_light_StructuredLightPattern_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_structured_light_GrayCodePatternG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_structured_light_GrayCodePatternG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_structured_light_GrayCodePatternG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_structured_light_GrayCodePatternG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_structured_light_GrayCodePatternG_to_PtrOfStructuredLightPattern(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_structured_light_SinusoidalPatternG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_structured_light_SinusoidalPatternG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_structured_light_SinusoidalPatternG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_structured_light_SinusoidalPatternG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_structured_light_SinusoidalPatternG_to_PtrOfStructuredLightPattern(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_structured_light_SinusoidalPattern_ParamsG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_structured_light_SinusoidalPattern_ParamsG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_structured_light_SinusoidalPattern_ParamsG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_structured_light_SinusoidalPattern_ParamsG_new_const_Params(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_structured_light_StructuredLightPatternG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_structured_light_StructuredLightPatternG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_structured_light_StructuredLightPatternG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_structured_light_StructuredLightPatternG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_structured_light)]
pub use structured_light_sys::*;

#[cfg(ocvrs_has_module_superres)]
mod superres_sys {
	use super::*;

	extern "C" {
		pub fn cv_superres_createFrameSource_Camera(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_superres_createFrameSource_Camera_int(device_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_superres_createFrameSource_Empty(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_superres_createFrameSource_Video_CUDA_const_StringR(file_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_superres_createFrameSource_Video_const_StringR(file_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_superres_createOptFlow_Brox_CUDA(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_superres_createOptFlow_DualTVL1(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_superres_createOptFlow_DualTVL1_CUDA(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_superres_createOptFlow_Farneback(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_superres_createOptFlow_Farneback_CUDA(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_superres_createOptFlow_PyrLK_CUDA(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_superres_createSuperResolution_BTVL1(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_superres_createSuperResolution_BTVL1_CUDA(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_superres_BroxOpticalFlow_getAlpha_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_superres_BroxOpticalFlow_setAlpha_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_superres_BroxOpticalFlow_getGamma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_superres_BroxOpticalFlow_setGamma_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_superres_BroxOpticalFlow_getScaleFactor_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_superres_BroxOpticalFlow_setScaleFactor_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_superres_BroxOpticalFlow_getInnerIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_BroxOpticalFlow_setInnerIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_BroxOpticalFlow_getOuterIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_BroxOpticalFlow_setOuterIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_BroxOpticalFlow_getSolverIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_BroxOpticalFlow_setSolverIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_BroxOpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_superres_BroxOpticalFlow_to_SuperRes_DenseOpticalFlowExt(instance: *mut c_void) -> *mut c_void;
		pub fn cv_superres_BroxOpticalFlow_delete(instance: *mut c_void);
		pub fn cv_superres_DenseOpticalFlowExt_calc_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, flow1: *const c_void, flow2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_superres_DenseOpticalFlowExt_calc_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, flow1: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_superres_DenseOpticalFlowExt_collectGarbage(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_superres_DenseOpticalFlowExt_to_SuperRes_BroxOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_superres_DenseOpticalFlowExt_to_SuperRes_DualTVL1OpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_superres_DenseOpticalFlowExt_to_SuperRes_FarnebackOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_superres_DenseOpticalFlowExt_to_SuperRes_PyrLKOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_superres_DenseOpticalFlowExt_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_superres_DenseOpticalFlowExt_delete(instance: *mut c_void);
		pub fn cv_superres_DualTVL1OpticalFlow_getTau_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_superres_DualTVL1OpticalFlow_setTau_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_superres_DualTVL1OpticalFlow_getLambda_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_superres_DualTVL1OpticalFlow_setLambda_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_superres_DualTVL1OpticalFlow_getTheta_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_superres_DualTVL1OpticalFlow_setTheta_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_superres_DualTVL1OpticalFlow_getScalesNumber_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_DualTVL1OpticalFlow_setScalesNumber_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_DualTVL1OpticalFlow_getWarpingsNumber_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_DualTVL1OpticalFlow_setWarpingsNumber_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_DualTVL1OpticalFlow_getEpsilon_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_superres_DualTVL1OpticalFlow_setEpsilon_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_superres_DualTVL1OpticalFlow_getIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_DualTVL1OpticalFlow_setIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_DualTVL1OpticalFlow_getUseInitialFlow_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_superres_DualTVL1OpticalFlow_setUseInitialFlow_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_superres_DualTVL1OpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_superres_DualTVL1OpticalFlow_to_SuperRes_DenseOpticalFlowExt(instance: *mut c_void) -> *mut c_void;
		pub fn cv_superres_DualTVL1OpticalFlow_delete(instance: *mut c_void);
		pub fn cv_superres_FarnebackOpticalFlow_getPyrScale_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_superres_FarnebackOpticalFlow_setPyrScale_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_superres_FarnebackOpticalFlow_getLevelsNumber_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_FarnebackOpticalFlow_setLevelsNumber_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_FarnebackOpticalFlow_getWindowSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_FarnebackOpticalFlow_setWindowSize_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_FarnebackOpticalFlow_getIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_FarnebackOpticalFlow_setIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_FarnebackOpticalFlow_getPolyN_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_FarnebackOpticalFlow_setPolyN_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_FarnebackOpticalFlow_getPolySigma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_superres_FarnebackOpticalFlow_setPolySigma_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_superres_FarnebackOpticalFlow_getFlags_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_FarnebackOpticalFlow_setFlags_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_FarnebackOpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_superres_FarnebackOpticalFlow_to_SuperRes_DenseOpticalFlowExt(instance: *mut c_void) -> *mut c_void;
		pub fn cv_superres_FarnebackOpticalFlow_delete(instance: *mut c_void);
		pub fn cv_superres_FrameSource_nextFrame_const__OutputArrayR(instance: *mut c_void, frame: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_superres_FrameSource_reset(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_superres_FrameSource_to_SuperRes_SuperResolution(instance: *mut c_void) -> *mut c_void;
		pub fn cv_superres_FrameSource_delete(instance: *mut c_void);
		pub fn cv_superres_PyrLKOpticalFlow_getWindowSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_PyrLKOpticalFlow_setWindowSize_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_PyrLKOpticalFlow_getMaxLevel_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_PyrLKOpticalFlow_setMaxLevel_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_PyrLKOpticalFlow_getIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_PyrLKOpticalFlow_setIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_PyrLKOpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_superres_PyrLKOpticalFlow_to_SuperRes_DenseOpticalFlowExt(instance: *mut c_void) -> *mut c_void;
		pub fn cv_superres_PyrLKOpticalFlow_delete(instance: *mut c_void);
		pub fn cv_superres_SuperResolution_setInput_const_PtrLFrameSourceGR(instance: *mut c_void, frame_source: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_superres_SuperResolution_nextFrame_const__OutputArrayR(instance: *mut c_void, frame: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_superres_SuperResolution_reset(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_superres_SuperResolution_collectGarbage(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_superres_SuperResolution_getScale_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_SuperResolution_setScale_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_SuperResolution_getIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_SuperResolution_setIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_SuperResolution_getTau_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_superres_SuperResolution_setTau_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_superres_SuperResolution_getLambda_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_superres_SuperResolution_setLambda_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_superres_SuperResolution_getAlpha_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_superres_SuperResolution_setAlpha_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_superres_SuperResolution_getKernelSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_SuperResolution_setKernelSize_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_SuperResolution_getBlurKernelSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_SuperResolution_setBlurKernelSize_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_SuperResolution_getBlurSigma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_superres_SuperResolution_setBlurSigma_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_superres_SuperResolution_getTemporalAreaRadius_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_superres_SuperResolution_setTemporalAreaRadius_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_superres_SuperResolution_getOpticalFlow_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_superres_SuperResolution_setOpticalFlow_const_PtrLDenseOpticalFlowExtGR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_superres_SuperResolution_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_superres_SuperResolution_to_SuperRes_FrameSource(instance: *mut c_void) -> *mut c_void;
		pub fn cv_superres_SuperResolution_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_superres_BroxOpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_BroxOpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_BroxOpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_superres_BroxOpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_BroxOpticalFlowG_to_PtrOfSuperRes_DenseOpticalFlowExt(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_DenseOpticalFlowExtG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_DenseOpticalFlowExtG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_DenseOpticalFlowExtG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_superres_DenseOpticalFlowExtG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_DualTVL1OpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_DualTVL1OpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_DualTVL1OpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_superres_DualTVL1OpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_DualTVL1OpticalFlowG_to_PtrOfSuperRes_DenseOpticalFlowExt(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_FarnebackOpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_FarnebackOpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_FarnebackOpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_superres_FarnebackOpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_FarnebackOpticalFlowG_to_PtrOfSuperRes_DenseOpticalFlowExt(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_FrameSourceG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_FrameSourceG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_FrameSourceG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_superres_PyrLKOpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_PyrLKOpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_PyrLKOpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_superres_PyrLKOpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_PyrLKOpticalFlowG_to_PtrOfSuperRes_DenseOpticalFlowExt(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_SuperResolutionG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_SuperResolutionG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_SuperResolutionG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_superres_SuperResolutionG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_superres_SuperResolutionG_to_PtrOfSuperRes_FrameSource(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_superres)]
pub use superres_sys::*;

#[cfg(ocvrs_has_module_surface_matching)]
mod surface_matching_sys {
	use super::*;

	extern "C" {
		pub fn cv_ppf_match_3d_ICP_ICP(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ppf_match_3d_ICP_ICP_const_int_const_float_const_float_const_int_const_int_const_int(iterations: i32, tolerence: f32, rejection_scale: f32, num_levels: i32, sample_type: i32, num_max_corr: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ppf_match_3d_ICP_ICP_const_int(iterations: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ppf_match_3d_ICP_registerModelToScene_const_MatR_const_MatR_doubleR_Matx44dR(instance: *mut c_void, src_pc: *const c_void, dst_pc: *const c_void, residual: *mut f64, pose: *mut core::Matx44d, ocvrs_return: *mut Result<i32>);
		pub fn cv_ppf_match_3d_ICP_registerModelToScene_const_MatR_const_MatR_vectorLPose3DPtrGR(instance: *mut c_void, src_pc: *const c_void, dst_pc: *const c_void, poses: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ppf_match_3d_ICP_delete(instance: *mut c_void);
		pub fn cv_ppf_match_3d_PPF3DDetector_PPF3DDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ppf_match_3d_PPF3DDetector_PPF3DDetector_const_double_const_double_const_double(relative_sampling_step: f64, relative_distance_step: f64, num_angles: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ppf_match_3d_PPF3DDetector_PPF3DDetector_const_double(relative_sampling_step: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ppf_match_3d_PPF3DDetector_setSearchParams_const_double_const_double_const_bool(instance: *mut c_void, position_threshold: f64, rotation_threshold: f64, use_weighted_clustering: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ppf_match_3d_PPF3DDetector_setSearchParams(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ppf_match_3d_PPF3DDetector_trainModel_const_MatR(instance: *mut c_void, model: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ppf_match_3d_PPF3DDetector_match_const_MatR_vectorLPose3DPtrGR_const_double_const_double(instance: *mut c_void, scene: *const c_void, results: *mut c_void, relative_scene_sample_step: f64, relative_scene_distance: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ppf_match_3d_PPF3DDetector_match_const_MatR_vectorLPose3DPtrGR(instance: *mut c_void, scene: *const c_void, results: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ppf_match_3d_PPF3DDetector_delete(instance: *mut c_void);
		pub fn cv_ppf_match_3d_Pose3D_Pose3D(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ppf_match_3d_Pose3D_Pose3D_double_size_t_size_t(alpha: f64, model_index: size_t, num_votes: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ppf_match_3d_Pose3D_Pose3D_double(alpha: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ppf_match_3d_Pose3D_updatePose_Matx44dR(instance: *mut c_void, new_pose: *mut core::Matx44d, ocvrs_return: *mut Result_void);
		pub fn cv_ppf_match_3d_Pose3D_updatePose_Matx33dR_Vec3dR(instance: *mut c_void, new_r: *mut core::Matx33d, new_t: *mut core::Vec3d, ocvrs_return: *mut Result_void);
		pub fn cv_ppf_match_3d_Pose3D_updatePoseQuat_Vec4dR_Vec3dR(instance: *mut c_void, q: *mut core::Vec4d, new_t: *mut core::Vec3d, ocvrs_return: *mut Result_void);
		pub fn cv_ppf_match_3d_Pose3D_appendPose_Matx44dR(instance: *mut c_void, incremental_pose: *mut core::Matx44d, ocvrs_return: *mut Result_void);
		pub fn cv_ppf_match_3d_Pose3D_printPose(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ppf_match_3d_Pose3D_clone(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ppf_match_3d_Pose3D_writePose_const_stringR(instance: *mut c_void, file_name: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_ppf_match_3d_Pose3D_readPose_const_stringR(instance: *mut c_void, file_name: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_ppf_match_3d_Pose3D_propAlpha_const(instance: *const c_void) -> f64;
		pub fn cv_ppf_match_3d_Pose3D_propAlpha_double(instance: *mut c_void, val: f64);
		pub fn cv_ppf_match_3d_Pose3D_propResidual_const(instance: *const c_void) -> f64;
		pub fn cv_ppf_match_3d_Pose3D_propResidual_double(instance: *mut c_void, val: f64);
		pub fn cv_ppf_match_3d_Pose3D_propModelIndex_const(instance: *const c_void) -> size_t;
		pub fn cv_ppf_match_3d_Pose3D_propModelIndex_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_ppf_match_3d_Pose3D_propNumVotes_const(instance: *const c_void) -> size_t;
		pub fn cv_ppf_match_3d_Pose3D_propNumVotes_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_ppf_match_3d_Pose3D_propPose_const(instance: *const c_void, ocvrs_return: *mut core::Matx44d);
		pub fn cv_ppf_match_3d_Pose3D_propPose_Matx44d(instance: *mut c_void, val: *const core::Matx44d);
		pub fn cv_ppf_match_3d_Pose3D_propAngle_const(instance: *const c_void) -> f64;
		pub fn cv_ppf_match_3d_Pose3D_propAngle_double(instance: *mut c_void, val: f64);
		pub fn cv_ppf_match_3d_Pose3D_propT_const(instance: *const c_void, ocvrs_return: *mut core::Vec3d);
		pub fn cv_ppf_match_3d_Pose3D_propT_Vec3d(instance: *mut c_void, val: *const core::Vec3d);
		pub fn cv_ppf_match_3d_Pose3D_propQ_const(instance: *const c_void, ocvrs_return: *mut core::Vec4d);
		pub fn cv_ppf_match_3d_Pose3D_propQ_Vec4d(instance: *mut c_void, val: *const core::Vec4d);
		pub fn cv_ppf_match_3d_Pose3D_delete(instance: *mut c_void);
		pub fn cv_ppf_match_3d_PoseCluster3D_PoseCluster3D(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ppf_match_3d_PoseCluster3D_PoseCluster3D_Pose3DPtr(new_pose: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ppf_match_3d_PoseCluster3D_PoseCluster3D_Pose3DPtr_int(new_pose: *mut c_void, new_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ppf_match_3d_PoseCluster3D_addPose_Pose3DPtr(instance: *mut c_void, new_pose: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ppf_match_3d_PoseCluster3D_writePoseCluster_const_stringR(instance: *mut c_void, file_name: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_ppf_match_3d_PoseCluster3D_readPoseCluster_const_stringR(instance: *mut c_void, file_name: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_ppf_match_3d_PoseCluster3D_propPoseList_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_ppf_match_3d_PoseCluster3D_propPoseList_vectorLPose3DPtrG(instance: *mut c_void, val: *mut c_void);
		pub fn cv_ppf_match_3d_PoseCluster3D_propNumVotes_const(instance: *const c_void) -> size_t;
		pub fn cv_ppf_match_3d_PoseCluster3D_propNumVotes_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_ppf_match_3d_PoseCluster3D_propId_const(instance: *const c_void) -> i32;
		pub fn cv_ppf_match_3d_PoseCluster3D_propId_int(instance: *mut c_void, val: i32);
		pub fn cv_ppf_match_3d_PoseCluster3D_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ppf_match_3d_Pose3DG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ppf_match_3d_Pose3DG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ppf_match_3d_Pose3DG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ppf_match_3d_Pose3DG_new_const_Pose3D(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ppf_match_3d_PoseCluster3DG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ppf_match_3d_PoseCluster3DG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ppf_match_3d_PoseCluster3DG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ppf_match_3d_PoseCluster3DG_new_const_PoseCluster3D(val: *mut c_void) -> *mut c_void;
		pub fn std_vectorLcv_ppf_match_3d_Pose3DPtrG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_ppf_match_3d_Pose3DPtrG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_ppf_match_3d_Pose3DPtrG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_ppf_match_3d_Pose3DPtrG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_ppf_match_3d_Pose3DPtrG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_ppf_match_3d_Pose3DPtrG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_ppf_match_3d_Pose3DPtrG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_ppf_match_3d_Pose3DPtrG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_ppf_match_3d_Pose3DPtrG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_ppf_match_3d_Pose3DPtrG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_ppf_match_3d_Pose3DPtrG_push_const_Pose3DPtr(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_ppf_match_3d_Pose3DPtrG_insert_size_t_const_Pose3DPtr(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_ppf_match_3d_Pose3DPtrG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_ppf_match_3d_Pose3DPtrG_set_size_t_const_Pose3DPtr(instance: *mut c_void, index: size_t, val: *const c_void);
	}
}
#[cfg(ocvrs_has_module_surface_matching)]
pub use surface_matching_sys::*;

#[cfg(ocvrs_has_module_text)]
mod text_sys {
	use super::*;

	extern "C" {
		pub fn cv_text_MSERsToERStats_const__InputArrayR_vectorLvectorLPointGGR_vectorLvectorLERStatGGR(image: *const c_void, contours: *mut c_void, regions: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_computeNMChannels_const__InputArrayR_const__OutputArrayR(_src: *const c_void, _channels: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_computeNMChannels_const__InputArrayR_const__OutputArrayR_int(_src: *const c_void, _channels: *const c_void, _mode: i32, ocvrs_return: *mut Result_void);
		pub fn cv_text_createERFilterNM1_const_PtrLCallbackGR(cb: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_createERFilterNM1_const_PtrLCallbackGR_int_float_float_float_bool_float(cb: *const c_void, threshold_delta: i32, min_area: f32, max_area: f32, min_probability: f32, non_max_suppression: bool, min_probability_diff: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_createERFilterNM1_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_createERFilterNM1_const_StringR_int_float_float_float_bool_float(filename: *const c_char, threshold_delta: i32, min_area: f32, max_area: f32, min_probability: f32, non_max_suppression: bool, min_probability_diff: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_createERFilterNM2_const_PtrLCallbackGR(cb: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_createERFilterNM2_const_PtrLCallbackGR_float(cb: *const c_void, min_probability: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_createERFilterNM2_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_createERFilterNM2_const_StringR_float(filename: *const c_char, min_probability: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_createOCRHMMTransitionsTable_const_StringR_vectorLStringGR(vocabulary: *const c_char, lexicon: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_createOCRHMMTransitionsTable_stringR_vectorLstringGR_const__OutputArrayR(vocabulary: *mut *mut c_void, lexicon: *mut c_void, transition_probabilities_table: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_detectRegions_const__InputArrayR_const_PtrLERFilterGR_const_PtrLERFilterGR_vectorLRectGR(image: *const c_void, er_filter1: *const c_void, er_filter2: *const c_void, groups_rects: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_detectRegions_const__InputArrayR_const_PtrLERFilterGR_const_PtrLERFilterGR_vectorLRectGR_int_const_StringR_float(image: *const c_void, er_filter1: *const c_void, er_filter2: *const c_void, groups_rects: *mut c_void, method: i32, filename: *const c_char, min_probability: f32, ocvrs_return: *mut Result_void);
		pub fn cv_text_detectRegions_const__InputArrayR_const_PtrLERFilterGR_const_PtrLERFilterGR_vectorLvectorLPointGGR(image: *const c_void, er_filter1: *const c_void, er_filter2: *const c_void, regions: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_detectTextSWT_const__InputArrayR_vectorLRectGR_bool(input: *const c_void, result: *mut c_void, dark_on_light: bool, ocvrs_return: *mut Result_void);
		pub fn cv_text_detectTextSWT_const__InputArrayR_vectorLRectGR_bool_const__OutputArrayR_const__OutputArrayR(input: *const c_void, result: *mut c_void, dark_on_light: bool, draw: *const c_void, chain_b_bs: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_erGrouping_const__InputArrayR_const__InputArrayR_vectorLvectorLERStatGGR_vectorLvectorLVec2iGGR_vectorLRectGR(img: *const c_void, channels: *const c_void, regions: *mut c_void, groups: *mut c_void, groups_rects: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_erGrouping_const__InputArrayR_const__InputArrayR_vectorLvectorLERStatGGR_vectorLvectorLVec2iGGR_vectorLRectGR_int_const_stringR_float(img: *const c_void, channels: *const c_void, regions: *mut c_void, groups: *mut c_void, groups_rects: *mut c_void, method: i32, filename: *const c_char, min_probablity: f32, ocvrs_return: *mut Result_void);
		pub fn cv_text_erGrouping_const__InputArrayR_const__InputArrayR_vectorLvectorLPointGG_vectorLRectGR(image: *const c_void, channel: *const c_void, regions: *mut c_void, groups_rects: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_erGrouping_const__InputArrayR_const__InputArrayR_vectorLvectorLPointGG_vectorLRectGR_int_const_StringR_float(image: *const c_void, channel: *const c_void, regions: *mut c_void, groups_rects: *mut c_void, method: i32, filename: *const c_char, min_probablity: f32, ocvrs_return: *mut Result_void);
		pub fn cv_text_loadClassifierNM1_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_loadClassifierNM2_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_loadOCRBeamSearchClassifierCNN_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_loadOCRHMMClassifierCNN_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_loadOCRHMMClassifierNM_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_loadOCRHMMClassifier_const_StringR_int(filename: *const c_char, classifier: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_BaseOCR_run_MatR_stringR_vectorLRectGX_vectorLstringGX_vectorLfloatGX_int(instance: *mut c_void, image: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_text_BaseOCR_run_MatR_stringR(instance: *mut c_void, image: *mut c_void, output_text: *mut *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_BaseOCR_run_MatR_MatR_stringR_vectorLRectGX_vectorLstringGX_vectorLfloatGX_int(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_text_BaseOCR_run_MatR_MatR_stringR(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, output_text: *mut *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_BaseOCR_to_OCRBeamSearchDecoder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_text_BaseOCR_to_OCRHMMDecoder(instance: *mut c_void) -> *mut c_void;
		pub fn cv_text_BaseOCR_to_OCRHolisticWordRecognizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_text_BaseOCR_to_OCRTesseract(instance: *mut c_void) -> *mut c_void;
		pub fn cv_text_BaseOCR_delete(instance: *mut c_void);
		pub fn cv_text_ERFilter_run_const__InputArrayR_vectorLERStatGR(instance: *mut c_void, image: *const c_void, regions: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_ERFilter_setCallback_const_PtrLCallbackGR(instance: *mut c_void, cb: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_ERFilter_setThresholdDelta_int(instance: *mut c_void, threshold_delta: i32, ocvrs_return: *mut Result_void);
		pub fn cv_text_ERFilter_setMinArea_float(instance: *mut c_void, min_area: f32, ocvrs_return: *mut Result_void);
		pub fn cv_text_ERFilter_setMaxArea_float(instance: *mut c_void, max_area: f32, ocvrs_return: *mut Result_void);
		pub fn cv_text_ERFilter_setMinProbability_float(instance: *mut c_void, min_probability: f32, ocvrs_return: *mut Result_void);
		pub fn cv_text_ERFilter_setMinProbabilityDiff_float(instance: *mut c_void, min_probability_diff: f32, ocvrs_return: *mut Result_void);
		pub fn cv_text_ERFilter_setNonMaxSuppression_bool(instance: *mut c_void, non_max_suppression: bool, ocvrs_return: *mut Result_void);
		pub fn cv_text_ERFilter_getNumRejected_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_text_ERFilter_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_text_ERFilter_delete(instance: *mut c_void);
		pub fn cv_text_ERFilter_Callback_eval_const_ERStatR(instance: *mut c_void, stat: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_text_ERFilter_Callback_delete(instance: *mut c_void);
		pub fn cv_text_ERStat_ERStat_int_int_int_int(level: i32, pixel: i32, x: i32, y: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_ERStat_ERStat(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_ERStat_propPixel_const(instance: *const c_void) -> i32;
		pub fn cv_text_ERStat_propPixel_int(instance: *mut c_void, val: i32);
		pub fn cv_text_ERStat_propLevel_const(instance: *const c_void) -> i32;
		pub fn cv_text_ERStat_propLevel_int(instance: *mut c_void, val: i32);
		pub fn cv_text_ERStat_propArea_const(instance: *const c_void) -> i32;
		pub fn cv_text_ERStat_propArea_int(instance: *mut c_void, val: i32);
		pub fn cv_text_ERStat_propPerimeter_const(instance: *const c_void) -> i32;
		pub fn cv_text_ERStat_propPerimeter_int(instance: *mut c_void, val: i32);
		pub fn cv_text_ERStat_propEuler_const(instance: *const c_void) -> i32;
		pub fn cv_text_ERStat_propEuler_int(instance: *mut c_void, val: i32);
		pub fn cv_text_ERStat_propRect_const(instance: *const c_void, ocvrs_return: *mut core::Rect);
		pub fn cv_text_ERStat_propRect_Rect(instance: *mut c_void, val: *const core::Rect);
		pub fn cv_text_ERStat_propRaw_moments(instance: *mut c_void) -> *mut [f64; 2];
		pub fn cv_text_ERStat_propCentral_moments(instance: *mut c_void) -> *mut [f64; 3];
		pub fn cv_text_ERStat_propMed_crossings_const(instance: *const c_void) -> f32;
		pub fn cv_text_ERStat_propMed_crossings_float(instance: *mut c_void, val: f32);
		pub fn cv_text_ERStat_propHole_area_ratio_const(instance: *const c_void) -> f32;
		pub fn cv_text_ERStat_propHole_area_ratio_float(instance: *mut c_void, val: f32);
		pub fn cv_text_ERStat_propConvex_hull_ratio_const(instance: *const c_void) -> f32;
		pub fn cv_text_ERStat_propConvex_hull_ratio_float(instance: *mut c_void, val: f32);
		pub fn cv_text_ERStat_propNum_inflexion_points_const(instance: *const c_void) -> f32;
		pub fn cv_text_ERStat_propNum_inflexion_points_float(instance: *mut c_void, val: f32);
		pub fn cv_text_ERStat_propProbability_const(instance: *const c_void) -> f64;
		pub fn cv_text_ERStat_propProbability_double(instance: *mut c_void, val: f64);
		pub fn cv_text_ERStat_propParent(instance: *mut c_void) -> *mut c_void;
		pub fn cv_text_ERStat_propParent_ERStatX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_text_ERStat_propChild(instance: *mut c_void) -> *mut c_void;
		pub fn cv_text_ERStat_propChild_ERStatX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_text_ERStat_propNext(instance: *mut c_void) -> *mut c_void;
		pub fn cv_text_ERStat_propNext_ERStatX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_text_ERStat_propPrev(instance: *mut c_void) -> *mut c_void;
		pub fn cv_text_ERStat_propPrev_ERStatX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_text_ERStat_propLocal_maxima_const(instance: *const c_void) -> bool;
		pub fn cv_text_ERStat_propLocal_maxima_bool(instance: *mut c_void, val: bool);
		pub fn cv_text_ERStat_propMax_probability_ancestor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_text_ERStat_propMax_probability_ancestor_ERStatX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_text_ERStat_propMin_probability_ancestor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_text_ERStat_propMin_probability_ancestor_ERStatX(instance: *mut c_void, val: *mut c_void);
		pub fn cv_text_ERStat_delete(instance: *mut c_void);
		pub fn cv_text_OCRBeamSearchDecoder_run_MatR_stringR_vectorLRectGX_vectorLstringGX_vectorLfloatGX_int(instance: *mut c_void, image: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRBeamSearchDecoder_run_MatR_stringR(instance: *mut c_void, image: *mut c_void, output_text: *mut *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRBeamSearchDecoder_run_MatR_MatR_stringR_vectorLRectGX_vectorLstringGX_vectorLfloatGX_int(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRBeamSearchDecoder_run_MatR_MatR_stringR(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, output_text: *mut *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRBeamSearchDecoder_run_const__InputArrayR_int_int(instance: *mut c_void, image: *const c_void, min_confidence: i32, component_level: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRBeamSearchDecoder_run_const__InputArrayR_int(instance: *mut c_void, image: *const c_void, min_confidence: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRBeamSearchDecoder_run_const__InputArrayR_const__InputArrayR_int_int(instance: *mut c_void, image: *const c_void, mask: *const c_void, min_confidence: i32, component_level: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRBeamSearchDecoder_run_const__InputArrayR_const__InputArrayR_int(instance: *mut c_void, image: *const c_void, mask: *const c_void, min_confidence: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRBeamSearchDecoder_create_const_PtrLClassifierCallbackG_const_stringR_const__InputArrayR_const__InputArrayR_decoder_mode_int(classifier: *const c_void, vocabulary: *const c_char, transition_probabilities_table: *const c_void, emission_probabilities_table: *const c_void, mode: crate::text::decoder_mode, beam_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRBeamSearchDecoder_create_const_StringR_const_StringR_const__InputArrayR_const__InputArrayR_decoder_mode_int(filename: *const c_char, vocabulary: *const c_char, transition_probabilities_table: *const c_void, emission_probabilities_table: *const c_void, mode: crate::text::decoder_mode, beam_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRBeamSearchDecoder_create_const_StringR_const_StringR_const__InputArrayR_const__InputArrayR(filename: *const c_char, vocabulary: *const c_char, transition_probabilities_table: *const c_void, emission_probabilities_table: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRBeamSearchDecoder_to_BaseOCR(instance: *mut c_void) -> *mut c_void;
		pub fn cv_text_OCRBeamSearchDecoder_delete(instance: *mut c_void);
		pub fn cv_text_OCRBeamSearchDecoder_ClassifierCallback_eval_const__InputArrayR_vectorLvectorLdoubleGGR_vectorLintGR(instance: *mut c_void, image: *const c_void, recognition_probabilities: *mut c_void, oversegmentation: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRBeamSearchDecoder_ClassifierCallback_getWindowSize(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_text_OCRBeamSearchDecoder_ClassifierCallback_getStepSize(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_text_OCRBeamSearchDecoder_ClassifierCallback_delete(instance: *mut c_void);
		pub fn cv_text_OCRHMMDecoder_run_MatR_stringR_vectorLRectGX_vectorLstringGX_vectorLfloatGX_int(instance: *mut c_void, image: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRHMMDecoder_run_MatR_stringR(instance: *mut c_void, image: *mut c_void, output_text: *mut *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRHMMDecoder_run_MatR_MatR_stringR_vectorLRectGX_vectorLstringGX_vectorLfloatGX_int(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRHMMDecoder_run_MatR_MatR_stringR(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, output_text: *mut *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRHMMDecoder_run_const__InputArrayR_int_int(instance: *mut c_void, image: *const c_void, min_confidence: i32, component_level: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRHMMDecoder_run_const__InputArrayR_int(instance: *mut c_void, image: *const c_void, min_confidence: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRHMMDecoder_run_const__InputArrayR_const__InputArrayR_int_int(instance: *mut c_void, image: *const c_void, mask: *const c_void, min_confidence: i32, component_level: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRHMMDecoder_run_const__InputArrayR_const__InputArrayR_int(instance: *mut c_void, image: *const c_void, mask: *const c_void, min_confidence: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRHMMDecoder_create_const_PtrLClassifierCallbackG_const_StringR_const__InputArrayR_const__InputArrayR_int(classifier: *const c_void, vocabulary: *const c_char, transition_probabilities_table: *const c_void, emission_probabilities_table: *const c_void, mode: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRHMMDecoder_create_const_PtrLClassifierCallbackG_const_StringR_const__InputArrayR_const__InputArrayR(classifier: *const c_void, vocabulary: *const c_char, transition_probabilities_table: *const c_void, emission_probabilities_table: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRHMMDecoder_create_const_StringR_const_StringR_const__InputArrayR_const__InputArrayR_int_int(filename: *const c_char, vocabulary: *const c_char, transition_probabilities_table: *const c_void, emission_probabilities_table: *const c_void, mode: i32, classifier: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRHMMDecoder_create_const_StringR_const_StringR_const__InputArrayR_const__InputArrayR(filename: *const c_char, vocabulary: *const c_char, transition_probabilities_table: *const c_void, emission_probabilities_table: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRHMMDecoder_to_BaseOCR(instance: *mut c_void) -> *mut c_void;
		pub fn cv_text_OCRHMMDecoder_delete(instance: *mut c_void);
		pub fn cv_text_OCRHMMDecoder_ClassifierCallback_eval_const__InputArrayR_vectorLintGR_vectorLdoubleGR(instance: *mut c_void, image: *const c_void, out_class: *mut c_void, out_confidence: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRHMMDecoder_ClassifierCallback_delete(instance: *mut c_void);
		pub fn cv_text_OCRHolisticWordRecognizer_run_MatR_stringR_vectorLRectGX_vectorLstringGX_vectorLfloatGX_int(instance: *mut c_void, image: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRHolisticWordRecognizer_run_MatR_stringR(instance: *mut c_void, image: *mut c_void, output_text: *mut *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRHolisticWordRecognizer_run_MatR_MatR_stringR_vectorLRectGX_vectorLstringGX_vectorLfloatGX_int(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRHolisticWordRecognizer_run_MatR_MatR_stringR(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, output_text: *mut *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRHolisticWordRecognizer_create_const_stringR_const_stringR_const_stringR(arch_filename: *const c_char, weights_filename: *const c_char, words_filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRHolisticWordRecognizer_to_BaseOCR(instance: *mut c_void) -> *mut c_void;
		pub fn cv_text_OCRHolisticWordRecognizer_delete(instance: *mut c_void);
		pub fn cv_text_OCRTesseract_run_MatR_stringR_vectorLRectGX_vectorLstringGX_vectorLfloatGX_int(instance: *mut c_void, image: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRTesseract_run_MatR_stringR(instance: *mut c_void, image: *mut c_void, output_text: *mut *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRTesseract_run_MatR_MatR_stringR_vectorLRectGX_vectorLstringGX_vectorLfloatGX_int(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, output_text: *mut *mut c_void, component_rects: *mut c_void, component_texts: *mut c_void, component_confidences: *mut c_void, component_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRTesseract_run_MatR_MatR_stringR(instance: *mut c_void, image: *mut c_void, mask: *mut c_void, output_text: *mut *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRTesseract_run_const__InputArrayR_int_int(instance: *mut c_void, image: *const c_void, min_confidence: i32, component_level: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRTesseract_run_const__InputArrayR_int(instance: *mut c_void, image: *const c_void, min_confidence: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRTesseract_run_const__InputArrayR_const__InputArrayR_int_int(instance: *mut c_void, image: *const c_void, mask: *const c_void, min_confidence: i32, component_level: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRTesseract_run_const__InputArrayR_const__InputArrayR_int(instance: *mut c_void, image: *const c_void, mask: *const c_void, min_confidence: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRTesseract_setWhiteList_const_StringR(instance: *mut c_void, char_whitelist: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_text_OCRTesseract_create_const_charX_const_charX_const_charX_int_int(datapath: *const c_char, language: *const c_char, char_whitelist: *const c_char, oem: i32, psmode: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRTesseract_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_OCRTesseract_to_BaseOCR(instance: *mut c_void) -> *mut c_void;
		pub fn cv_text_OCRTesseract_delete(instance: *mut c_void);
		pub fn cv_text_TextDetector_detect_const__InputArrayR_vectorLRectGR_vectorLfloatGR(instance: *mut c_void, input_image: *const c_void, bbox: *mut c_void, confidence: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_TextDetector_to_TextDetectorCNN(instance: *mut c_void) -> *mut c_void;
		pub fn cv_text_TextDetector_delete(instance: *mut c_void);
		pub fn cv_text_TextDetectorCNN_detect_const__InputArrayR_vectorLRectGR_vectorLfloatGR(instance: *mut c_void, input_image: *const c_void, bbox: *mut c_void, confidence: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_text_TextDetectorCNN_create_const_StringR_const_StringR_vectorLSizeG(model_arch_filename: *const c_char, model_weights_filename: *const c_char, detection_sizes: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_TextDetectorCNN_create_const_StringR_const_StringR(model_arch_filename: *const c_char, model_weights_filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_text_TextDetectorCNN_to_TextDetector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_text_TextDetectorCNN_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_text_BaseOCRG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_BaseOCRG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_BaseOCRG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_text_ERFilterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_ERFilterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_ERFilterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_text_ERFilterG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_ERFilter_CallbackG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_ERFilter_CallbackG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_ERFilter_CallbackG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_text_OCRBeamSearchDecoderG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRBeamSearchDecoderG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRBeamSearchDecoderG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_text_OCRBeamSearchDecoderG_to_PtrOfBaseOCR(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRBeamSearchDecoderG_new_const_OCRBeamSearchDecoder(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRBeamSearchDecoder_ClassifierCallbackG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRBeamSearchDecoder_ClassifierCallbackG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRBeamSearchDecoder_ClassifierCallbackG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_text_OCRBeamSearchDecoder_ClassifierCallbackG_new_const_ClassifierCallback(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRHMMDecoderG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRHMMDecoderG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRHMMDecoderG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_text_OCRHMMDecoderG_to_PtrOfBaseOCR(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRHMMDecoderG_new_const_OCRHMMDecoder(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRHMMDecoder_ClassifierCallbackG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRHMMDecoder_ClassifierCallbackG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRHMMDecoder_ClassifierCallbackG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_text_OCRHMMDecoder_ClassifierCallbackG_new_const_ClassifierCallback(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRHolisticWordRecognizerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRHolisticWordRecognizerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRHolisticWordRecognizerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_text_OCRHolisticWordRecognizerG_to_PtrOfBaseOCR(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRTesseractG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRTesseractG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_OCRTesseractG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_text_OCRTesseractG_to_PtrOfBaseOCR(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_TextDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_TextDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_TextDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_text_TextDetectorCNNG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_TextDetectorCNNG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_text_TextDetectorCNNG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_text_TextDetectorCNNG_to_PtrOfTextDetector(instance: *mut c_void) -> *mut c_void;
		pub fn std_vectorLcv_text_ERStatG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_text_ERStatG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_text_ERStatG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_text_ERStatG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_text_ERStatG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_text_ERStatG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_text_ERStatG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_text_ERStatG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_text_ERStatG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_text_ERStatG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_text_ERStatG_push_const_ERStat(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_text_ERStatG_insert_size_t_const_ERStat(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_text_ERStatG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_text_ERStatG_set_size_t_const_ERStat(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_text_ERStatGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLcv_text_ERStatGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_text_ERStatGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_text_ERStatGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLcv_text_ERStatGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_text_ERStatGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_text_ERStatGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLcv_text_ERStatGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLcv_text_ERStatGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLcv_text_ERStatGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_text_ERStatGG_push_const_vectorLERStatG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_text_ERStatGG_insert_size_t_const_vectorLERStatG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_text_ERStatGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLcv_text_ERStatGG_set_size_t_const_vectorLERStatG(instance: *mut c_void, index: size_t, val: *const c_void);
	}
}
#[cfg(ocvrs_has_module_text)]
pub use text_sys::*;

#[cfg(ocvrs_has_module_tracking)]
mod tracking_sys {
	use super::*;

	extern "C" {
		pub fn cv_tracking_TrackerCSRT_create_const_ParamsR(parameters: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_tracking_TrackerCSRT_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_tracking_TrackerCSRT_setInitialMask_const__InputArrayR(instance: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_tracking_TrackerCSRT_to_Tracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_tracking_TrackerCSRT_delete(instance: *mut c_void);
		pub fn cv_tracking_TrackerCSRT_Params_Params(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_tracking_TrackerCSRT_Params_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_tracking_TrackerCSRT_Params_propUse_hog_const(instance: *const c_void) -> bool;
		pub fn cv_tracking_TrackerCSRT_Params_propUse_hog_bool(instance: *mut c_void, val: bool);
		pub fn cv_tracking_TrackerCSRT_Params_propUse_color_names_const(instance: *const c_void) -> bool;
		pub fn cv_tracking_TrackerCSRT_Params_propUse_color_names_bool(instance: *mut c_void, val: bool);
		pub fn cv_tracking_TrackerCSRT_Params_propUse_gray_const(instance: *const c_void) -> bool;
		pub fn cv_tracking_TrackerCSRT_Params_propUse_gray_bool(instance: *mut c_void, val: bool);
		pub fn cv_tracking_TrackerCSRT_Params_propUse_rgb_const(instance: *const c_void) -> bool;
		pub fn cv_tracking_TrackerCSRT_Params_propUse_rgb_bool(instance: *mut c_void, val: bool);
		pub fn cv_tracking_TrackerCSRT_Params_propUse_channel_weights_const(instance: *const c_void) -> bool;
		pub fn cv_tracking_TrackerCSRT_Params_propUse_channel_weights_bool(instance: *mut c_void, val: bool);
		pub fn cv_tracking_TrackerCSRT_Params_propUse_segmentation_const(instance: *const c_void) -> bool;
		pub fn cv_tracking_TrackerCSRT_Params_propUse_segmentation_bool(instance: *mut c_void, val: bool);
		pub fn cv_tracking_TrackerCSRT_Params_propWindow_function_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_tracking_TrackerCSRT_Params_propWindow_function_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_tracking_TrackerCSRT_Params_propKaiser_alpha_const(instance: *const c_void) -> f32;
		pub fn cv_tracking_TrackerCSRT_Params_propKaiser_alpha_float(instance: *mut c_void, val: f32);
		pub fn cv_tracking_TrackerCSRT_Params_propCheb_attenuation_const(instance: *const c_void) -> f32;
		pub fn cv_tracking_TrackerCSRT_Params_propCheb_attenuation_float(instance: *mut c_void, val: f32);
		pub fn cv_tracking_TrackerCSRT_Params_propTemplate_size_const(instance: *const c_void) -> f32;
		pub fn cv_tracking_TrackerCSRT_Params_propTemplate_size_float(instance: *mut c_void, val: f32);
		pub fn cv_tracking_TrackerCSRT_Params_propGsl_sigma_const(instance: *const c_void) -> f32;
		pub fn cv_tracking_TrackerCSRT_Params_propGsl_sigma_float(instance: *mut c_void, val: f32);
		pub fn cv_tracking_TrackerCSRT_Params_propHog_orientations_const(instance: *const c_void) -> f32;
		pub fn cv_tracking_TrackerCSRT_Params_propHog_orientations_float(instance: *mut c_void, val: f32);
		pub fn cv_tracking_TrackerCSRT_Params_propHog_clip_const(instance: *const c_void) -> f32;
		pub fn cv_tracking_TrackerCSRT_Params_propHog_clip_float(instance: *mut c_void, val: f32);
		pub fn cv_tracking_TrackerCSRT_Params_propPadding_const(instance: *const c_void) -> f32;
		pub fn cv_tracking_TrackerCSRT_Params_propPadding_float(instance: *mut c_void, val: f32);
		pub fn cv_tracking_TrackerCSRT_Params_propFilter_lr_const(instance: *const c_void) -> f32;
		pub fn cv_tracking_TrackerCSRT_Params_propFilter_lr_float(instance: *mut c_void, val: f32);
		pub fn cv_tracking_TrackerCSRT_Params_propWeights_lr_const(instance: *const c_void) -> f32;
		pub fn cv_tracking_TrackerCSRT_Params_propWeights_lr_float(instance: *mut c_void, val: f32);
		pub fn cv_tracking_TrackerCSRT_Params_propNum_hog_channels_used_const(instance: *const c_void) -> i32;
		pub fn cv_tracking_TrackerCSRT_Params_propNum_hog_channels_used_int(instance: *mut c_void, val: i32);
		pub fn cv_tracking_TrackerCSRT_Params_propAdmm_iterations_const(instance: *const c_void) -> i32;
		pub fn cv_tracking_TrackerCSRT_Params_propAdmm_iterations_int(instance: *mut c_void, val: i32);
		pub fn cv_tracking_TrackerCSRT_Params_propHistogram_bins_const(instance: *const c_void) -> i32;
		pub fn cv_tracking_TrackerCSRT_Params_propHistogram_bins_int(instance: *mut c_void, val: i32);
		pub fn cv_tracking_TrackerCSRT_Params_propHistogram_lr_const(instance: *const c_void) -> f32;
		pub fn cv_tracking_TrackerCSRT_Params_propHistogram_lr_float(instance: *mut c_void, val: f32);
		pub fn cv_tracking_TrackerCSRT_Params_propBackground_ratio_const(instance: *const c_void) -> i32;
		pub fn cv_tracking_TrackerCSRT_Params_propBackground_ratio_int(instance: *mut c_void, val: i32);
		pub fn cv_tracking_TrackerCSRT_Params_propNumber_of_scales_const(instance: *const c_void) -> i32;
		pub fn cv_tracking_TrackerCSRT_Params_propNumber_of_scales_int(instance: *mut c_void, val: i32);
		pub fn cv_tracking_TrackerCSRT_Params_propScale_sigma_factor_const(instance: *const c_void) -> f32;
		pub fn cv_tracking_TrackerCSRT_Params_propScale_sigma_factor_float(instance: *mut c_void, val: f32);
		pub fn cv_tracking_TrackerCSRT_Params_propScale_model_max_area_const(instance: *const c_void) -> f32;
		pub fn cv_tracking_TrackerCSRT_Params_propScale_model_max_area_float(instance: *mut c_void, val: f32);
		pub fn cv_tracking_TrackerCSRT_Params_propScale_lr_const(instance: *const c_void) -> f32;
		pub fn cv_tracking_TrackerCSRT_Params_propScale_lr_float(instance: *mut c_void, val: f32);
		pub fn cv_tracking_TrackerCSRT_Params_propScale_step_const(instance: *const c_void) -> f32;
		pub fn cv_tracking_TrackerCSRT_Params_propScale_step_float(instance: *mut c_void, val: f32);
		pub fn cv_tracking_TrackerCSRT_Params_propPsr_threshold_const(instance: *const c_void) -> f32;
		pub fn cv_tracking_TrackerCSRT_Params_propPsr_threshold_float(instance: *mut c_void, val: f32);
		pub fn cv_tracking_TrackerCSRT_Params_delete(instance: *mut c_void);
		pub fn cv_tracking_TrackerKCF_create_const_ParamsR(parameters: *const crate::tracking::TrackerKCF_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_tracking_TrackerKCF_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_tracking_TrackerKCF_setFeatureExtractor_FeatureExtractorCallbackFN_bool(instance: *mut c_void, callback: Option<unsafe extern "C" fn(*const c_void, core::Rect, *mut c_void) -> ()>, pca_func: bool, ocvrs_return: *mut Result_void);
		pub fn cv_tracking_TrackerKCF_setFeatureExtractor_FeatureExtractorCallbackFN(instance: *mut c_void, callback: Option<unsafe extern "C" fn(*const c_void, core::Rect, *mut c_void) -> ()>, ocvrs_return: *mut Result_void);
		pub fn cv_tracking_TrackerKCF_to_Tracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_tracking_TrackerKCF_delete(instance: *mut c_void);
		pub fn cv_tracking_TrackerKCF_Params_Params(ocvrs_return: *mut Result<crate::tracking::TrackerKCF_Params>);
		pub fn cv_PtrLcv_tracking_TrackerCSRTG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_tracking_TrackerCSRTG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_tracking_TrackerCSRTG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_tracking_TrackerCSRTG_to_PtrOfTracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_tracking_TrackerKCFG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_tracking_TrackerKCFG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_tracking_TrackerKCFG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_tracking_TrackerKCFG_to_PtrOfTracker(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_tracking)]
pub use tracking_sys::*;

#[cfg(ocvrs_has_module_video)]
mod video_sys {
	use super::*;

	extern "C" {
		pub fn cv_CamShift_const__InputArrayR_RectR_TermCriteria(prob_image: *const c_void, window: *mut core::Rect, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<core::RotatedRect>);
		pub fn cv_buildOpticalFlowPyramid_const__InputArrayR_const__OutputArrayR_Size_int(img: *const c_void, pyramid: *const c_void, win_size: *const core::Size, max_level: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_buildOpticalFlowPyramid_const__InputArrayR_const__OutputArrayR_Size_int_bool_int_int_bool(img: *const c_void, pyramid: *const c_void, win_size: *const core::Size, max_level: i32, with_derivatives: bool, pyr_border: i32, deriv_border: i32, try_reuse_input_image: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_calcOpticalFlowFarneback_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_double_int_int_int_int_double_int(prev: *const c_void, next: *const c_void, flow: *const c_void, pyr_scale: f64, levels: i32, winsize: i32, iterations: i32, poly_n: i32, poly_sigma: f64, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_calcOpticalFlowPyrLK_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR(prev_img: *const c_void, next_img: *const c_void, prev_pts: *const c_void, next_pts: *const c_void, status: *const c_void, err: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_calcOpticalFlowPyrLK_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_Size_int_TermCriteria_int_double(prev_img: *const c_void, next_img: *const c_void, prev_pts: *const c_void, next_pts: *const c_void, status: *const c_void, err: *const c_void, win_size: *const core::Size, max_level: i32, criteria: *const core::TermCriteria, flags: i32, min_eig_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_computeECC_const__InputArrayR_const__InputArrayR(template_image: *const c_void, input_image: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_computeECC_const__InputArrayR_const__InputArrayR_const__InputArrayR(template_image: *const c_void, input_image: *const c_void, input_mask: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_createBackgroundSubtractorKNN(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createBackgroundSubtractorKNN_int_double_bool(history: i32, dist2_threshold: f64, detect_shadows: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createBackgroundSubtractorMOG2(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createBackgroundSubtractorMOG2_int_double_bool(history: i32, var_threshold: f64, detect_shadows: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_estimateRigidTransform_const__InputArrayR_const__InputArrayR_bool(src: *const c_void, dst: *const c_void, full_affine: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_findTransformECC_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR(template_image: *const c_void, input_image: *const c_void, warp_matrix: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_findTransformECC_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_int_TermCriteria_const__InputArrayR(template_image: *const c_void, input_image: *const c_void, warp_matrix: *const c_void, motion_type: i32, criteria: *const core::TermCriteria, input_mask: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_findTransformECC_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_int_TermCriteria_const__InputArrayR_int(template_image: *const c_void, input_image: *const c_void, warp_matrix: *const c_void, motion_type: i32, criteria: *const core::TermCriteria, input_mask: *const c_void, gauss_filt_size: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_meanShift_const__InputArrayR_RectR_TermCriteria(prob_image: *const c_void, window: *mut core::Rect, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<i32>);
		pub fn cv_readOpticalFlow_const_StringR(path: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_writeOpticalFlow_const_StringR_const__InputArrayR(path: *const c_char, flow: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_BackgroundSubtractor_apply_const__InputArrayR_const__OutputArrayR_double(instance: *mut c_void, image: *const c_void, fgmask: *const c_void, learning_rate: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractor_apply_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, fgmask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractor_getBackgroundImage_const_const__OutputArrayR(instance: *const c_void, background_image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractor_to_BackgroundSubtractorKNN(instance: *mut c_void) -> *mut c_void;
		pub fn cv_BackgroundSubtractor_to_BackgroundSubtractorMOG2(instance: *mut c_void) -> *mut c_void;
		pub fn cv_BackgroundSubtractor_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_BackgroundSubtractor_delete(instance: *mut c_void);
		pub fn cv_BackgroundSubtractorKNN_getHistory_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BackgroundSubtractorKNN_setHistory_int(instance: *mut c_void, history: i32, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorKNN_getNSamples_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BackgroundSubtractorKNN_setNSamples_int(instance: *mut c_void, _n_n: i32, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorKNN_getDist2Threshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorKNN_setDist2Threshold_double(instance: *mut c_void, _dist2_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorKNN_getkNNSamples_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BackgroundSubtractorKNN_setkNNSamples_int(instance: *mut c_void, _nk_nn: i32, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorKNN_getDetectShadows_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_BackgroundSubtractorKNN_setDetectShadows_bool(instance: *mut c_void, detect_shadows: bool, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorKNN_getShadowValue_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BackgroundSubtractorKNN_setShadowValue_int(instance: *mut c_void, value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorKNN_getShadowThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorKNN_setShadowThreshold_double(instance: *mut c_void, threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorKNN_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_BackgroundSubtractorKNN_to_BackgroundSubtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_BackgroundSubtractorKNN_delete(instance: *mut c_void);
		pub fn cv_BackgroundSubtractorMOG2_getHistory_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BackgroundSubtractorMOG2_setHistory_int(instance: *mut c_void, history: i32, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getNMixtures_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BackgroundSubtractorMOG2_setNMixtures_int(instance: *mut c_void, nmixtures: i32, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getBackgroundRatio_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorMOG2_setBackgroundRatio_double(instance: *mut c_void, ratio: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getVarThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorMOG2_setVarThreshold_double(instance: *mut c_void, var_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getVarThresholdGen_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorMOG2_setVarThresholdGen_double(instance: *mut c_void, var_threshold_gen: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getVarInit_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorMOG2_setVarInit_double(instance: *mut c_void, var_init: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getVarMin_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorMOG2_setVarMin_double(instance: *mut c_void, var_min: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getVarMax_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorMOG2_setVarMax_double(instance: *mut c_void, var_max: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getComplexityReductionThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorMOG2_setComplexityReductionThreshold_double(instance: *mut c_void, ct: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getDetectShadows_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_BackgroundSubtractorMOG2_setDetectShadows_bool(instance: *mut c_void, detect_shadows: bool, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getShadowValue_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BackgroundSubtractorMOG2_setShadowValue_int(instance: *mut c_void, value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_getShadowThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_BackgroundSubtractorMOG2_setShadowThreshold_double(instance: *mut c_void, threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_apply_const__InputArrayR_const__OutputArrayR_double(instance: *mut c_void, image: *const c_void, fgmask: *const c_void, learning_rate: f64, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_apply_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, fgmask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_BackgroundSubtractorMOG2_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_BackgroundSubtractorMOG2_to_BackgroundSubtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_BackgroundSubtractorMOG2_delete(instance: *mut c_void);
		pub fn cv_DISOpticalFlow_getFinestScale_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_DISOpticalFlow_setFinestScale_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getPatchSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_DISOpticalFlow_setPatchSize_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getPatchStride_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_DISOpticalFlow_setPatchStride_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getGradientDescentIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_DISOpticalFlow_setGradientDescentIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getVariationalRefinementIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_DISOpticalFlow_setVariationalRefinementIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getVariationalRefinementAlpha_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_DISOpticalFlow_setVariationalRefinementAlpha_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getVariationalRefinementDelta_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_DISOpticalFlow_setVariationalRefinementDelta_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getVariationalRefinementGamma_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_DISOpticalFlow_setVariationalRefinementGamma_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getUseMeanNormalization_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_DISOpticalFlow_setUseMeanNormalization_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_getUseSpatialPropagation_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_DISOpticalFlow_setUseSpatialPropagation_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_DISOpticalFlow_create_int(preset: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DISOpticalFlow_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DISOpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_DISOpticalFlow_to_DenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_DISOpticalFlow_delete(instance: *mut c_void);
		pub fn cv_DenseOpticalFlow_calc_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR(instance: *mut c_void, i0: *const c_void, i1: *const c_void, flow: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DenseOpticalFlow_collectGarbage(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_DenseOpticalFlow_to_DISOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_DenseOpticalFlow_to_FarnebackOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_DenseOpticalFlow_to_VariationalRefinement(instance: *mut c_void) -> *mut c_void;
		pub fn cv_DenseOpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_DenseOpticalFlow_delete(instance: *mut c_void);
		pub fn cv_FarnebackOpticalFlow_getNumLevels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FarnebackOpticalFlow_setNumLevels_int(instance: *mut c_void, num_levels: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FarnebackOpticalFlow_getPyrScale_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_FarnebackOpticalFlow_setPyrScale_double(instance: *mut c_void, pyr_scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_FarnebackOpticalFlow_getFastPyramids_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FarnebackOpticalFlow_setFastPyramids_bool(instance: *mut c_void, fast_pyramids: bool, ocvrs_return: *mut Result_void);
		pub fn cv_FarnebackOpticalFlow_getWinSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FarnebackOpticalFlow_setWinSize_int(instance: *mut c_void, win_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FarnebackOpticalFlow_getNumIters_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FarnebackOpticalFlow_setNumIters_int(instance: *mut c_void, num_iters: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FarnebackOpticalFlow_getPolyN_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FarnebackOpticalFlow_setPolyN_int(instance: *mut c_void, poly_n: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FarnebackOpticalFlow_getPolySigma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_FarnebackOpticalFlow_setPolySigma_double(instance: *mut c_void, poly_sigma: f64, ocvrs_return: *mut Result_void);
		pub fn cv_FarnebackOpticalFlow_getFlags_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FarnebackOpticalFlow_setFlags_int(instance: *mut c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_FarnebackOpticalFlow_create_int_double_bool_int_int_int_double_int(num_levels: i32, pyr_scale: f64, fast_pyramids: bool, win_size: i32, num_iters: i32, poly_n: i32, poly_sigma: f64, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FarnebackOpticalFlow_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FarnebackOpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_FarnebackOpticalFlow_to_DenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_FarnebackOpticalFlow_delete(instance: *mut c_void);
		pub fn cv_KalmanFilter_KalmanFilter(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KalmanFilter_KalmanFilter_int_int_int_int(dynam_params: i32, measure_params: i32, control_params: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KalmanFilter_KalmanFilter_int_int(dynam_params: i32, measure_params: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KalmanFilter_init_int_int_int_int(instance: *mut c_void, dynam_params: i32, measure_params: i32, control_params: i32, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_KalmanFilter_init_int_int(instance: *mut c_void, dynam_params: i32, measure_params: i32, ocvrs_return: *mut Result_void);
		pub fn cv_KalmanFilter_predict_const_MatR(instance: *mut c_void, control: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KalmanFilter_predict(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KalmanFilter_correct_const_MatR(instance: *mut c_void, measurement: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KalmanFilter_propStatePre_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_propStatePre_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_propStatePost_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_propStatePost_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_propTransitionMatrix_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_propTransitionMatrix_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_propControlMatrix_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_propControlMatrix_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_propMeasurementMatrix_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_propMeasurementMatrix_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_propProcessNoiseCov_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_propProcessNoiseCov_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_propMeasurementNoiseCov_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_propMeasurementNoiseCov_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_propErrorCovPre_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_propErrorCovPre_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_propGain_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_propGain_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_propErrorCovPost_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_propErrorCovPost_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_propTemp1_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_propTemp1_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_propTemp2_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_propTemp2_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_propTemp3_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_propTemp3_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_propTemp4_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_propTemp4_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_propTemp5_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KalmanFilter_propTemp5_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_KalmanFilter_delete(instance: *mut c_void);
		pub fn cv_SparseOpticalFlow_calc_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, prev_img: *const c_void, next_img: *const c_void, prev_pts: *const c_void, next_pts: *const c_void, status: *const c_void, err: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseOpticalFlow_calc_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR(instance: *mut c_void, prev_img: *const c_void, next_img: *const c_void, prev_pts: *const c_void, next_pts: *const c_void, status: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_SparseOpticalFlow_to_SparsePyrLKOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_SparseOpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_SparseOpticalFlow_delete(instance: *mut c_void);
		pub fn cv_SparsePyrLKOpticalFlow_getWinSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_SparsePyrLKOpticalFlow_setWinSize_Size(instance: *mut c_void, win_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_SparsePyrLKOpticalFlow_getMaxLevel_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_SparsePyrLKOpticalFlow_setMaxLevel_int(instance: *mut c_void, max_level: i32, ocvrs_return: *mut Result_void);
		pub fn cv_SparsePyrLKOpticalFlow_getTermCriteria_const(instance: *const c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_SparsePyrLKOpticalFlow_setTermCriteria_TermCriteriaR(instance: *mut c_void, crit: *mut core::TermCriteria, ocvrs_return: *mut Result_void);
		pub fn cv_SparsePyrLKOpticalFlow_getFlags_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_SparsePyrLKOpticalFlow_setFlags_int(instance: *mut c_void, flags: i32, ocvrs_return: *mut Result_void);
		pub fn cv_SparsePyrLKOpticalFlow_getMinEigThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_SparsePyrLKOpticalFlow_setMinEigThreshold_double(instance: *mut c_void, min_eig_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_SparsePyrLKOpticalFlow_create_Size_int_TermCriteria_int_double(win_size: *const core::Size, max_level: i32, crit: *const core::TermCriteria, flags: i32, min_eig_threshold: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparsePyrLKOpticalFlow_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparsePyrLKOpticalFlow_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_SparsePyrLKOpticalFlow_to_SparseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_SparsePyrLKOpticalFlow_delete(instance: *mut c_void);
		pub fn cv_Tracker_init_const__InputArrayR_const_RectR(instance: *mut c_void, image: *const c_void, bounding_box: *const core::Rect, ocvrs_return: *mut Result_void);
		pub fn cv_Tracker_update_const__InputArrayR_RectR(instance: *mut c_void, image: *const c_void, bounding_box: *mut core::Rect, ocvrs_return: *mut Result<bool>);
		pub fn cv_Tracker_to_TrackerDaSiamRPN(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Tracker_to_TrackerGOTURN(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Tracker_to_TrackerMIL(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Tracker_to_TrackerNano(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Tracker_delete(instance: *mut c_void);
		pub fn cv_TrackerDaSiamRPN_create_const_ParamsR(parameters: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TrackerDaSiamRPN_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TrackerDaSiamRPN_getTrackingScore(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_TrackerDaSiamRPN_to_Tracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_TrackerDaSiamRPN_delete(instance: *mut c_void);
		pub fn cv_TrackerDaSiamRPN_Params_Params(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TrackerDaSiamRPN_Params_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_TrackerDaSiamRPN_Params_propModel_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_TrackerDaSiamRPN_Params_propModel_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_TrackerDaSiamRPN_Params_propKernel_cls1_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_TrackerDaSiamRPN_Params_propKernel_cls1_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_TrackerDaSiamRPN_Params_propKernel_r1_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_TrackerDaSiamRPN_Params_propKernel_r1_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_TrackerDaSiamRPN_Params_propBackend_const(instance: *const c_void) -> i32;
		pub fn cv_TrackerDaSiamRPN_Params_propBackend_int(instance: *mut c_void, val: i32);
		pub fn cv_TrackerDaSiamRPN_Params_propTarget_const(instance: *const c_void) -> i32;
		pub fn cv_TrackerDaSiamRPN_Params_propTarget_int(instance: *mut c_void, val: i32);
		pub fn cv_TrackerDaSiamRPN_Params_delete(instance: *mut c_void);
		pub fn cv_TrackerGOTURN_create_const_ParamsR(parameters: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TrackerGOTURN_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TrackerGOTURN_to_Tracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_TrackerGOTURN_delete(instance: *mut c_void);
		pub fn cv_TrackerGOTURN_Params_Params(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TrackerGOTURN_Params_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_TrackerGOTURN_Params_propModelTxt_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_TrackerGOTURN_Params_propModelTxt_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_TrackerGOTURN_Params_propModelBin_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_TrackerGOTURN_Params_propModelBin_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_TrackerGOTURN_Params_delete(instance: *mut c_void);
		pub fn cv_TrackerMIL_create_const_ParamsR(parameters: *const crate::video::TrackerMIL_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TrackerMIL_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TrackerMIL_to_Tracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_TrackerMIL_delete(instance: *mut c_void);
		pub fn cv_TrackerMIL_Params_Params(ocvrs_return: *mut Result<crate::video::TrackerMIL_Params>);
		pub fn cv_TrackerNano_create_const_ParamsR(parameters: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TrackerNano_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TrackerNano_getTrackingScore(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_TrackerNano_to_Tracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_TrackerNano_delete(instance: *mut c_void);
		pub fn cv_TrackerNano_Params_Params(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TrackerNano_Params_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_TrackerNano_Params_propBackbone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_TrackerNano_Params_propBackbone_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_TrackerNano_Params_propNeckhead_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_TrackerNano_Params_propNeckhead_string(instance: *mut c_void, val: *mut c_char);
		pub fn cv_TrackerNano_Params_propBackend_const(instance: *const c_void) -> i32;
		pub fn cv_TrackerNano_Params_propBackend_int(instance: *mut c_void, val: i32);
		pub fn cv_TrackerNano_Params_propTarget_const(instance: *const c_void) -> i32;
		pub fn cv_TrackerNano_Params_propTarget_int(instance: *mut c_void, val: i32);
		pub fn cv_TrackerNano_Params_delete(instance: *mut c_void);
		pub fn cv_VariationalRefinement_calcUV_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(instance: *mut c_void, i0: *const c_void, i1: *const c_void, flow_u: *const c_void, flow_v: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_VariationalRefinement_getFixedPointIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_VariationalRefinement_setFixedPointIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_VariationalRefinement_getSorIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_VariationalRefinement_setSorIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_VariationalRefinement_getOmega_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_VariationalRefinement_setOmega_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_VariationalRefinement_getAlpha_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_VariationalRefinement_setAlpha_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_VariationalRefinement_getDelta_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_VariationalRefinement_setDelta_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_VariationalRefinement_getGamma_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_VariationalRefinement_setGamma_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_VariationalRefinement_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VariationalRefinement_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_VariationalRefinement_to_DenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_VariationalRefinement_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_BackgroundSubtractorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BackgroundSubtractorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BackgroundSubtractorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_BackgroundSubtractorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BackgroundSubtractorKNNG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BackgroundSubtractorKNNG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BackgroundSubtractorKNNG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_BackgroundSubtractorKNNG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BackgroundSubtractorKNNG_to_PtrOfBackgroundSubtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BackgroundSubtractorMOG2G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BackgroundSubtractorMOG2G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BackgroundSubtractorMOG2G_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_BackgroundSubtractorMOG2G_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BackgroundSubtractorMOG2G_to_PtrOfBackgroundSubtractor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DISOpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DISOpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DISOpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_DISOpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DISOpticalFlowG_to_PtrOfDenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DenseOpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DenseOpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DenseOpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_DenseOpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FarnebackOpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FarnebackOpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FarnebackOpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_FarnebackOpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FarnebackOpticalFlowG_to_PtrOfDenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SparseOpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SparseOpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SparseOpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_SparseOpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SparsePyrLKOpticalFlowG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SparsePyrLKOpticalFlowG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SparsePyrLKOpticalFlowG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_SparsePyrLKOpticalFlowG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_SparsePyrLKOpticalFlowG_to_PtrOfSparseOpticalFlow(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TrackerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TrackerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TrackerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_TrackerDaSiamRPNG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TrackerDaSiamRPNG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TrackerDaSiamRPNG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_TrackerDaSiamRPNG_to_PtrOfTracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TrackerGOTURNG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TrackerGOTURNG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TrackerGOTURNG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_TrackerGOTURNG_to_PtrOfTracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TrackerMILG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TrackerMILG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TrackerMILG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_TrackerMILG_to_PtrOfTracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TrackerNanoG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TrackerNanoG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_TrackerNanoG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_TrackerNanoG_to_PtrOfTracker(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_VariationalRefinementG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_VariationalRefinementG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_VariationalRefinementG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_VariationalRefinementG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_VariationalRefinementG_to_PtrOfDenseOpticalFlow(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_video)]
pub use video_sys::*;

#[cfg(ocvrs_has_module_videoio)]
mod videoio_sys {
	use super::*;

	extern "C" {
		pub fn cv_videoio_registry_getBackendName_VideoCaptureAPIs(api: crate::videoio::VideoCaptureAPIs, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videoio_registry_getBackends(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videoio_registry_getCameraBackendPluginVersion_VideoCaptureAPIs_intR_intR(api: crate::videoio::VideoCaptureAPIs, version_abi: *mut i32, version_api: *mut i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videoio_registry_getCameraBackends(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videoio_registry_getStreamBackendPluginVersion_VideoCaptureAPIs_intR_intR(api: crate::videoio::VideoCaptureAPIs, version_abi: *mut i32, version_api: *mut i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videoio_registry_getStreamBackends(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videoio_registry_getWriterBackendPluginVersion_VideoCaptureAPIs_intR_intR(api: crate::videoio::VideoCaptureAPIs, version_abi: *mut i32, version_api: *mut i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videoio_registry_getWriterBackends(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videoio_registry_hasBackend_VideoCaptureAPIs(api: crate::videoio::VideoCaptureAPIs, ocvrs_return: *mut Result<bool>);
		pub fn cv_videoio_registry_isBackendBuiltIn_VideoCaptureAPIs(api: crate::videoio::VideoCaptureAPIs, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_VideoCapture(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoCapture_VideoCapture_const_StringR_int(filename: *const c_char, api_preference: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoCapture_VideoCapture_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoCapture_VideoCapture_const_StringR_int_const_vectorLintGR(filename: *const c_char, api_preference: i32, params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoCapture_VideoCapture_int_int(index: i32, api_preference: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoCapture_VideoCapture_int(index: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoCapture_VideoCapture_int_int_const_vectorLintGR(index: i32, api_preference: i32, params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoCapture_open_const_StringR_int(instance: *mut c_void, filename: *const c_char, api_preference: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_open_const_StringR(instance: *mut c_void, filename: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_open_const_StringR_int_const_vectorLintGR(instance: *mut c_void, filename: *const c_char, api_preference: i32, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_open_int_int(instance: *mut c_void, index: i32, api_preference: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_open_int(instance: *mut c_void, index: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_open_int_int_const_vectorLintGR(instance: *mut c_void, index: i32, api_preference: i32, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_isOpened_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_VideoCapture_grab(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_retrieve_const__OutputArrayR_int(instance: *mut c_void, image: *const c_void, flag: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_retrieve_const__OutputArrayR(instance: *mut c_void, image: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_read_const__OutputArrayR(instance: *mut c_void, image: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_set_int_double(instance: *mut c_void, prop_id: i32, value: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_get_const_int(instance: *const c_void, prop_id: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_VideoCapture_getBackendName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoCapture_setExceptionMode_bool(instance: *mut c_void, enable: bool, ocvrs_return: *mut Result_void);
		pub fn cv_VideoCapture_getExceptionMode(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_waitAny_const_vectorLVideoCaptureGR_vectorLintGR_int64_t(streams: *const c_void, ready_index: *mut c_void, timeout_ns: i64, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_waitAny_const_vectorLVideoCaptureGR_vectorLintGR(streams: *const c_void, ready_index: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoCapture_delete(instance: *mut c_void);
		pub fn cv_VideoWriter_VideoWriter(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoWriter_VideoWriter_const_StringR_int_double_Size_bool(filename: *const c_char, fourcc: i32, fps: f64, frame_size: *const core::Size, is_color: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoWriter_VideoWriter_const_StringR_int_double_Size(filename: *const c_char, fourcc: i32, fps: f64, frame_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoWriter_VideoWriter_const_StringR_int_int_double_Size_bool(filename: *const c_char, api_preference: i32, fourcc: i32, fps: f64, frame_size: *const core::Size, is_color: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoWriter_VideoWriter_const_StringR_int_int_double_Size(filename: *const c_char, api_preference: i32, fourcc: i32, fps: f64, frame_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoWriter_VideoWriter_const_StringR_int_double_const_SizeR_const_vectorLintGR(filename: *const c_char, fourcc: i32, fps: f64, frame_size: *const core::Size, params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoWriter_VideoWriter_const_StringR_int_int_double_const_SizeR_const_vectorLintGR(filename: *const c_char, api_preference: i32, fourcc: i32, fps: f64, frame_size: *const core::Size, params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoWriter_open_const_StringR_int_double_Size_bool(instance: *mut c_void, filename: *const c_char, fourcc: i32, fps: f64, frame_size: *const core::Size, is_color: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoWriter_open_const_StringR_int_double_Size(instance: *mut c_void, filename: *const c_char, fourcc: i32, fps: f64, frame_size: *const core::Size, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoWriter_open_const_StringR_int_int_double_Size_bool(instance: *mut c_void, filename: *const c_char, api_preference: i32, fourcc: i32, fps: f64, frame_size: *const core::Size, is_color: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoWriter_open_const_StringR_int_int_double_Size(instance: *mut c_void, filename: *const c_char, api_preference: i32, fourcc: i32, fps: f64, frame_size: *const core::Size, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoWriter_open_const_StringR_int_double_const_SizeR_const_vectorLintGR(instance: *mut c_void, filename: *const c_char, fourcc: i32, fps: f64, frame_size: *const core::Size, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoWriter_open_const_StringR_int_int_double_const_SizeR_const_vectorLintGR(instance: *mut c_void, filename: *const c_char, api_preference: i32, fourcc: i32, fps: f64, frame_size: *const core::Size, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoWriter_isOpened_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoWriter_release(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_VideoWriter_write_const__InputArrayR(instance: *mut c_void, image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_VideoWriter_set_int_double(instance: *mut c_void, prop_id: i32, value: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_VideoWriter_get_const_int(instance: *const c_void, prop_id: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_VideoWriter_fourcc_char_char_char_char(c1: c_char, c2: c_char, c3: c_char, c4: c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_VideoWriter_getBackendName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_VideoWriter_delete(instance: *mut c_void);
		pub fn std_vectorLcv_VideoCaptureG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_VideoCaptureG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_VideoCaptureG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_VideoCaptureG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_VideoCaptureG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_VideoCaptureG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_VideoCaptureG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_VideoCaptureG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_VideoCaptureG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_VideoCaptureG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_VideoCaptureG_push_const_VideoCapture(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_VideoCaptureG_insert_size_t_const_VideoCapture(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_VideoCaptureG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_VideoCaptureG_set_size_t_const_VideoCapture(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_VideoCaptureAPIsG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_VideoCaptureAPIsG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_VideoCaptureAPIsG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_VideoCaptureAPIsG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_VideoCaptureAPIsG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_VideoCaptureAPIsG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_VideoCaptureAPIsG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_VideoCaptureAPIsG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_VideoCaptureAPIsG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_VideoCaptureAPIsG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_VideoCaptureAPIsG_push_const_VideoCaptureAPIs(instance: *mut c_void, val: crate::videoio::VideoCaptureAPIs);
		pub fn std_vectorLcv_VideoCaptureAPIsG_insert_size_t_const_VideoCaptureAPIs(instance: *mut c_void, index: size_t, val: crate::videoio::VideoCaptureAPIs);
		pub fn std_vectorLcv_VideoCaptureAPIsG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut crate::videoio::VideoCaptureAPIs);
		pub fn std_vectorLcv_VideoCaptureAPIsG_set_size_t_const_VideoCaptureAPIs(instance: *mut c_void, index: size_t, val: crate::videoio::VideoCaptureAPIs);
		pub fn std_vectorLcv_VideoCaptureAPIsG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_VideoCaptureAPIsG_data_const(instance: *const c_void) -> *const crate::videoio::VideoCaptureAPIs;
		pub fn std_vectorLcv_VideoCaptureAPIsG_dataMut(instance: *mut c_void) -> *mut crate::videoio::VideoCaptureAPIs;
		pub fn cv_fromSlice_const_const_VideoCaptureAPIsX_size_t(data: *const crate::videoio::VideoCaptureAPIs, len: size_t) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_videoio)]
pub use videoio_sys::*;

#[cfg(ocvrs_has_module_videostab)]
mod videostab_sys {
	use super::*;

	extern "C" {
		pub fn cv_videostab_calcBlurriness_const_MatR(frame: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_videostab_calcFlowMask_const_MatR_const_MatR_const_MatR_float_const_MatR_const_MatR_MatR(flow_x: *const c_void, flow_y: *const c_void, errors: *const c_void, max_error: f32, mask0: *const c_void, mask1: *const c_void, flow_mask: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_completeFrameAccordingToFlow_const_MatR_const_MatR_const_MatR_const_MatR_const_MatR_float_MatR_MatR(flow_mask: *const c_void, flow_x: *const c_void, flow_y: *const c_void, frame1: *const c_void, mask1: *const c_void, dist_thresh: f32, frame0: *mut c_void, mask0: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_ensureInclusionConstraint_const_MatR_Size_float(m: *const c_void, size: *const core::Size, trim_ratio: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_estimateGlobalMotionLeastSquares_const__InputOutputArrayR_const__InputOutputArrayR(points0: *const c_void, points1: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_estimateGlobalMotionLeastSquares_const__InputOutputArrayR_const__InputOutputArrayR_int_floatX(points0: *const c_void, points1: *const c_void, model: i32, rmse: *mut f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_estimateGlobalMotionRansac_const__InputArrayR_const__InputArrayR(points0: *const c_void, points1: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_estimateGlobalMotionRansac_const__InputArrayR_const__InputArrayR_int_const_RansacParamsR_floatX_intX(points0: *const c_void, points1: *const c_void, model: i32, params: *const c_void, rmse: *mut f32, ninliers: *mut i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_estimateOptimalTrimRatio_const_MatR_Size(m: *const c_void, size: *const core::Size, ocvrs_return: *mut Result<f32>);
		pub fn cv_videostab_getMotion_int_int_const_vectorLMatGR(from: i32, to: i32, motions: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_ColorAverageInpainter_inpaint_int_MatR_MatR(instance: *mut c_void, idx: i32, frame: *mut c_void, mask: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_ColorAverageInpainter_to_InpainterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_ColorAverageInpainter_delete(instance: *mut c_void);
		pub fn cv_videostab_ColorInpainter_ColorInpainter_int_double(method: i32, radius: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_ColorInpainter_ColorInpainter(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_ColorInpainter_inpaint_int_MatR_MatR(instance: *mut c_void, idx: i32, frame: *mut c_void, mask: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_ColorInpainter_to_InpainterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_ColorInpainter_delete(instance: *mut c_void);
		pub fn cv_videostab_ConsistentMosaicInpainter_ConsistentMosaicInpainter(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_ConsistentMosaicInpainter_setStdevThresh_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_ConsistentMosaicInpainter_stdevThresh_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_videostab_ConsistentMosaicInpainter_inpaint_int_MatR_MatR(instance: *mut c_void, idx: i32, frame: *mut c_void, mask: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_ConsistentMosaicInpainter_to_InpainterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_ConsistentMosaicInpainter_delete(instance: *mut c_void);
		pub fn cv_videostab_DeblurerBase_setRadius_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_DeblurerBase_radius_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_videostab_DeblurerBase_deblur_int_MatR_const_RangeR(instance: *mut c_void, idx: i32, frame: *mut c_void, range: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_DeblurerBase_setFrames_const_vectorLMatGR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_DeblurerBase_frames_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_DeblurerBase_setMotions_const_vectorLMatGR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_DeblurerBase_motions_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_DeblurerBase_setBlurrinessRates_const_vectorLfloatGR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_DeblurerBase_blurrinessRates_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_DeblurerBase_to_NullDeblurer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_DeblurerBase_to_WeightingDeblurer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_DeblurerBase_delete(instance: *mut c_void);
		pub fn cv_videostab_DensePyrLkOptFlowEstimatorGpu_DensePyrLkOptFlowEstimatorGpu(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_DensePyrLkOptFlowEstimatorGpu_run_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, flow_x: *const c_void, flow_y: *const c_void, errors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_DensePyrLkOptFlowEstimatorGpu_to_IDenseOptFlowEstimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_DensePyrLkOptFlowEstimatorGpu_to_PyrLkOptFlowEstimatorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_DensePyrLkOptFlowEstimatorGpu_delete(instance: *mut c_void);
		pub fn cv_videostab_FastMarchingMethod_FastMarchingMethod(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_FastMarchingMethod_distanceMap_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_FastMarchingMethod_delete(instance: *mut c_void);
		pub fn cv_videostab_FromFileMotionReader_FromFileMotionReader_const_StringR(path: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_FromFileMotionReader_estimate_const_MatR_const_MatR_boolX(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, ok: *mut bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_FromFileMotionReader_estimate_const_MatR_const_MatR(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_FromFileMotionReader_to_ImageMotionEstimatorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_FromFileMotionReader_delete(instance: *mut c_void);
		pub fn cv_videostab_GaussianMotionFilter_GaussianMotionFilter_int_float(radius: i32, stdev: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_GaussianMotionFilter_GaussianMotionFilter(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_GaussianMotionFilter_setParams_int_float(instance: *mut c_void, radius: i32, stdev: f32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_GaussianMotionFilter_setParams_int(instance: *mut c_void, radius: i32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_GaussianMotionFilter_radius_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_videostab_GaussianMotionFilter_stdev_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_videostab_GaussianMotionFilter_stabilize_int_const_vectorLMatGR_const_RangeR(instance: *mut c_void, idx: i32, motions: *const c_void, range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_GaussianMotionFilter_to_IMotionStabilizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_GaussianMotionFilter_to_MotionFilterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_GaussianMotionFilter_delete(instance: *mut c_void);
		pub fn cv_videostab_IDenseOptFlowEstimator_run_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__OutputArrayR(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, flow_x: *const c_void, flow_y: *const c_void, errors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_IDenseOptFlowEstimator_to_DensePyrLkOptFlowEstimatorGpu(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_IDenseOptFlowEstimator_delete(instance: *mut c_void);
		pub fn cv_videostab_IFrameSource_reset(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_IFrameSource_nextFrame(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_IFrameSource_to_MaskFrameSource(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_IFrameSource_to_NullFrameSource(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_IFrameSource_to_OnePassStabilizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_IFrameSource_to_TwoPassStabilizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_IFrameSource_to_VideoFileSource(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_IFrameSource_delete(instance: *mut c_void);
		pub fn cv_videostab_ILog_print_const_charX(instance: *mut c_void, format: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_ILog_to_LogToStdout(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_ILog_to_NullLog(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_ILog_delete(instance: *mut c_void);
		pub fn cv_videostab_IMotionStabilizer_stabilize_int_const_vectorLMatGR_const_RangeR_MatX(instance: *mut c_void, size: i32, motions: *const c_void, range: *const c_void, stabilization_motions: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_IMotionStabilizer_to_GaussianMotionFilter(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_IMotionStabilizer_to_LpMotionStabilizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_IMotionStabilizer_to_MotionFilterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_IMotionStabilizer_to_MotionStabilizationPipeline(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_IMotionStabilizer_delete(instance: *mut c_void);
		pub fn cv_videostab_IOutlierRejector_process_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, frame_size: *const core::Size, points0: *const c_void, points1: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_IOutlierRejector_to_NullOutlierRejector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_IOutlierRejector_to_TranslationBasedLocalOutlierRejector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_IOutlierRejector_delete(instance: *mut c_void);
		pub fn cv_videostab_ISparseOptFlowEstimator_run_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, points0: *const c_void, points1: *const c_void, status: *const c_void, errors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_ISparseOptFlowEstimator_to_SparsePyrLkOptFlowEstimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_ISparseOptFlowEstimator_to_SparsePyrLkOptFlowEstimatorGpu(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_ISparseOptFlowEstimator_delete(instance: *mut c_void);
		pub fn cv_videostab_ImageMotionEstimatorBase_setMotionModel_MotionModel(instance: *mut c_void, val: crate::videostab::MotionModel, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_ImageMotionEstimatorBase_motionModel_const(instance: *const c_void, ocvrs_return: *mut Result<crate::videostab::MotionModel>);
		pub fn cv_videostab_ImageMotionEstimatorBase_setFrameMask_const__InputArrayR(instance: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_ImageMotionEstimatorBase_estimate_const_MatR_const_MatR_boolX(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, ok: *mut bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_ImageMotionEstimatorBase_estimate_const_MatR_const_MatR(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_ImageMotionEstimatorBase_to_FromFileMotionReader(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_ImageMotionEstimatorBase_to_KeypointBasedMotionEstimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_ImageMotionEstimatorBase_to_KeypointBasedMotionEstimatorGpu(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_ImageMotionEstimatorBase_to_ToFileMotionWriter(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_ImageMotionEstimatorBase_delete(instance: *mut c_void);
		pub fn cv_videostab_InpainterBase_setRadius_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_InpainterBase_radius_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_videostab_InpainterBase_setMotionModel_MotionModel(instance: *mut c_void, val: crate::videostab::MotionModel, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_InpainterBase_motionModel_const(instance: *const c_void, ocvrs_return: *mut Result<crate::videostab::MotionModel>);
		pub fn cv_videostab_InpainterBase_inpaint_int_MatR_MatR(instance: *mut c_void, idx: i32, frame: *mut c_void, mask: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_InpainterBase_setFrames_const_vectorLMatGR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_InpainterBase_frames_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_InpainterBase_setMotions_const_vectorLMatGR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_InpainterBase_motions_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_InpainterBase_setStabilizedFrames_const_vectorLMatGR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_InpainterBase_stabilizedFrames_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_InpainterBase_setStabilizationMotions_const_vectorLMatGR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_InpainterBase_stabilizationMotions_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_InpainterBase_to_ColorAverageInpainter(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_InpainterBase_to_ColorInpainter(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_InpainterBase_to_ConsistentMosaicInpainter(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_InpainterBase_to_InpaintingPipeline(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_InpainterBase_to_MotionInpainter(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_InpainterBase_to_NullInpainter(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_InpainterBase_delete(instance: *mut c_void);
		pub fn cv_videostab_InpaintingPipeline_pushBack_PtrLInpainterBaseG(instance: *mut c_void, inpainter: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_InpaintingPipeline_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_videostab_InpaintingPipeline_setRadius_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_InpaintingPipeline_setMotionModel_MotionModel(instance: *mut c_void, val: crate::videostab::MotionModel, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_InpaintingPipeline_setFrames_const_vectorLMatGR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_InpaintingPipeline_setMotions_const_vectorLMatGR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_InpaintingPipeline_setStabilizedFrames_const_vectorLMatGR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_InpaintingPipeline_setStabilizationMotions_const_vectorLMatGR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_InpaintingPipeline_inpaint_int_MatR_MatR(instance: *mut c_void, idx: i32, frame: *mut c_void, mask: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_InpaintingPipeline_to_InpainterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_InpaintingPipeline_delete(instance: *mut c_void);
		pub fn cv_videostab_KeypointBasedMotionEstimator_KeypointBasedMotionEstimator_PtrLMotionEstimatorBaseG(estimator: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_KeypointBasedMotionEstimator_setMotionModel_MotionModel(instance: *mut c_void, val: crate::videostab::MotionModel, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_KeypointBasedMotionEstimator_motionModel_const(instance: *const c_void, ocvrs_return: *mut Result<crate::videostab::MotionModel>);
		pub fn cv_videostab_KeypointBasedMotionEstimator_setDetector_PtrLFeature2DG(instance: *mut c_void, val: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_KeypointBasedMotionEstimator_detector_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_KeypointBasedMotionEstimator_setOpticalFlowEstimator_PtrLISparseOptFlowEstimatorG(instance: *mut c_void, val: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_KeypointBasedMotionEstimator_opticalFlowEstimator_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_KeypointBasedMotionEstimator_setOutlierRejector_PtrLIOutlierRejectorG(instance: *mut c_void, val: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_KeypointBasedMotionEstimator_outlierRejector_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_KeypointBasedMotionEstimator_setFrameMask_const__InputArrayR(instance: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_KeypointBasedMotionEstimator_estimate_const_MatR_const_MatR_boolX(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, ok: *mut bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_KeypointBasedMotionEstimator_estimate_const_MatR_const_MatR(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_KeypointBasedMotionEstimator_estimate_const__InputArrayR_const__InputArrayR_boolX(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, ok: *mut bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_KeypointBasedMotionEstimator_estimate_const__InputArrayR_const__InputArrayR(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_KeypointBasedMotionEstimator_to_ImageMotionEstimatorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_KeypointBasedMotionEstimator_delete(instance: *mut c_void);
		pub fn cv_videostab_KeypointBasedMotionEstimatorGpu_KeypointBasedMotionEstimatorGpu_PtrLMotionEstimatorBaseG(estimator: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_KeypointBasedMotionEstimatorGpu_setMotionModel_MotionModel(instance: *mut c_void, val: crate::videostab::MotionModel, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_KeypointBasedMotionEstimatorGpu_motionModel_const(instance: *const c_void, ocvrs_return: *mut Result<crate::videostab::MotionModel>);
		pub fn cv_videostab_KeypointBasedMotionEstimatorGpu_setOutlierRejector_PtrLIOutlierRejectorG(instance: *mut c_void, val: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_KeypointBasedMotionEstimatorGpu_outlierRejector_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_KeypointBasedMotionEstimatorGpu_estimate_const_MatR_const_MatR_boolX(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, ok: *mut bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_KeypointBasedMotionEstimatorGpu_estimate_const_MatR_const_MatR(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_KeypointBasedMotionEstimatorGpu_estimate_const_GpuMatR_const_GpuMatR_boolX(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, ok: *mut bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_KeypointBasedMotionEstimatorGpu_estimate_const_GpuMatR_const_GpuMatR(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_KeypointBasedMotionEstimatorGpu_to_ImageMotionEstimatorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_KeypointBasedMotionEstimatorGpu_delete(instance: *mut c_void);
		pub fn cv_videostab_LogToStdout_print_const_charX(instance: *mut c_void, format: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_LogToStdout_to_ILog(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_LogToStdout_delete(instance: *mut c_void);
		pub fn cv_videostab_LpMotionStabilizer_LpMotionStabilizer_MotionModel(model: crate::videostab::MotionModel, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_LpMotionStabilizer_LpMotionStabilizer(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_LpMotionStabilizer_setMotionModel_MotionModel(instance: *mut c_void, val: crate::videostab::MotionModel, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_LpMotionStabilizer_motionModel_const(instance: *const c_void, ocvrs_return: *mut Result<crate::videostab::MotionModel>);
		pub fn cv_videostab_LpMotionStabilizer_setFrameSize_Size(instance: *mut c_void, val: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_LpMotionStabilizer_frameSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_videostab_LpMotionStabilizer_setTrimRatio_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_LpMotionStabilizer_trimRatio_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_videostab_LpMotionStabilizer_setWeight1_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_LpMotionStabilizer_weight1_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_videostab_LpMotionStabilizer_setWeight2_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_LpMotionStabilizer_weight2_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_videostab_LpMotionStabilizer_setWeight3_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_LpMotionStabilizer_weight3_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_videostab_LpMotionStabilizer_setWeight4_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_LpMotionStabilizer_weight4_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_videostab_LpMotionStabilizer_stabilize_int_const_vectorLMatGR_const_RangeR_MatX(instance: *mut c_void, size: i32, motions: *const c_void, range: *const c_void, stabilization_motions: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_LpMotionStabilizer_to_IMotionStabilizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_LpMotionStabilizer_delete(instance: *mut c_void);
		pub fn cv_videostab_MaskFrameSource_MaskFrameSource_const_PtrLIFrameSourceGR(source: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_MaskFrameSource_reset(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_MaskFrameSource_nextFrame(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_MaskFrameSource_to_IFrameSource(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_MaskFrameSource_delete(instance: *mut c_void);
		pub fn cv_videostab_MoreAccurateMotionWobbleSuppressor_suppress_int_const_MatR_MatR(instance: *mut c_void, idx: i32, frame: *const c_void, result: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_MoreAccurateMotionWobbleSuppressor_to_MoreAccurateMotionWobbleSuppressorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_MoreAccurateMotionWobbleSuppressor_to_WobbleSuppressorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_MoreAccurateMotionWobbleSuppressor_delete(instance: *mut c_void);
		pub fn cv_videostab_MoreAccurateMotionWobbleSuppressorBase_setPeriod_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_MoreAccurateMotionWobbleSuppressorBase_period_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_videostab_MoreAccurateMotionWobbleSuppressorBase_to_MoreAccurateMotionWobbleSuppressor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_MoreAccurateMotionWobbleSuppressorBase_to_MoreAccurateMotionWobbleSuppressorGpu(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_MoreAccurateMotionWobbleSuppressorBase_to_WobbleSuppressorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_MoreAccurateMotionWobbleSuppressorBase_delete(instance: *mut c_void);
		pub fn cv_videostab_MoreAccurateMotionWobbleSuppressorGpu_suppress_int_const_GpuMatR_GpuMatR(instance: *mut c_void, idx: i32, frame: *const c_void, result: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_MoreAccurateMotionWobbleSuppressorGpu_suppress_int_const_MatR_MatR(instance: *mut c_void, idx: i32, frame: *const c_void, result: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_MoreAccurateMotionWobbleSuppressorGpu_to_MoreAccurateMotionWobbleSuppressorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_MoreAccurateMotionWobbleSuppressorGpu_to_WobbleSuppressorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_MoreAccurateMotionWobbleSuppressorGpu_delete(instance: *mut c_void);
		pub fn cv_videostab_MotionEstimatorBase_setMotionModel_MotionModel(instance: *mut c_void, val: crate::videostab::MotionModel, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_MotionEstimatorBase_motionModel_const(instance: *const c_void, ocvrs_return: *mut Result<crate::videostab::MotionModel>);
		pub fn cv_videostab_MotionEstimatorBase_estimate_const__InputArrayR_const__InputArrayR_boolX(instance: *mut c_void, points0: *const c_void, points1: *const c_void, ok: *mut bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_MotionEstimatorBase_estimate_const__InputArrayR_const__InputArrayR(instance: *mut c_void, points0: *const c_void, points1: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_MotionEstimatorBase_to_MotionEstimatorL1(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_MotionEstimatorBase_to_MotionEstimatorRansacL2(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_MotionEstimatorBase_delete(instance: *mut c_void);
		pub fn cv_videostab_MotionEstimatorL1_MotionEstimatorL1_MotionModel(model: crate::videostab::MotionModel, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_MotionEstimatorL1_MotionEstimatorL1(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_MotionEstimatorL1_estimate_const__InputArrayR_const__InputArrayR_boolX(instance: *mut c_void, points0: *const c_void, points1: *const c_void, ok: *mut bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_MotionEstimatorL1_estimate_const__InputArrayR_const__InputArrayR(instance: *mut c_void, points0: *const c_void, points1: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_MotionEstimatorL1_to_MotionEstimatorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_MotionEstimatorL1_delete(instance: *mut c_void);
		pub fn cv_videostab_MotionEstimatorRansacL2_MotionEstimatorRansacL2_MotionModel(model: crate::videostab::MotionModel, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_MotionEstimatorRansacL2_MotionEstimatorRansacL2(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_MotionEstimatorRansacL2_setRansacParams_const_RansacParamsR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_MotionEstimatorRansacL2_ransacParams_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_MotionEstimatorRansacL2_setMinInlierRatio_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_MotionEstimatorRansacL2_minInlierRatio_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_videostab_MotionEstimatorRansacL2_estimate_const__InputArrayR_const__InputArrayR_boolX(instance: *mut c_void, points0: *const c_void, points1: *const c_void, ok: *mut bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_MotionEstimatorRansacL2_estimate_const__InputArrayR_const__InputArrayR(instance: *mut c_void, points0: *const c_void, points1: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_MotionEstimatorRansacL2_to_MotionEstimatorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_MotionEstimatorRansacL2_delete(instance: *mut c_void);
		pub fn cv_videostab_MotionFilterBase_stabilize_int_const_vectorLMatGR_const_RangeR(instance: *mut c_void, idx: i32, motions: *const c_void, range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_MotionFilterBase_stabilize_int_const_vectorLMatGR_const_RangeR_MatX(instance: *mut c_void, size: i32, motions: *const c_void, range: *const c_void, stabilization_motions: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_MotionFilterBase_to_GaussianMotionFilter(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_MotionFilterBase_to_IMotionStabilizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_MotionFilterBase_delete(instance: *mut c_void);
		pub fn cv_videostab_MotionInpainter_MotionInpainter(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_MotionInpainter_setOptFlowEstimator_PtrLIDenseOptFlowEstimatorG(instance: *mut c_void, val: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_MotionInpainter_optFlowEstimator_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_MotionInpainter_setFlowErrorThreshold_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_MotionInpainter_flowErrorThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_videostab_MotionInpainter_setDistThreshold_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_MotionInpainter_distThresh_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_videostab_MotionInpainter_setBorderMode_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_MotionInpainter_borderMode_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_videostab_MotionInpainter_inpaint_int_MatR_MatR(instance: *mut c_void, idx: i32, frame: *mut c_void, mask: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_MotionInpainter_to_InpainterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_MotionInpainter_delete(instance: *mut c_void);
		pub fn cv_videostab_MotionStabilizationPipeline_pushBack_PtrLIMotionStabilizerG(instance: *mut c_void, stabilizer: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_MotionStabilizationPipeline_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_videostab_MotionStabilizationPipeline_stabilize_int_const_vectorLMatGR_const_RangeR_MatX(instance: *mut c_void, size: i32, motions: *const c_void, range: *const c_void, stabilization_motions: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_MotionStabilizationPipeline_to_IMotionStabilizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_MotionStabilizationPipeline_delete(instance: *mut c_void);
		pub fn cv_videostab_NullDeblurer_deblur_int_MatR_const_RangeR(instance: *mut c_void, unnamed: i32, unnamed_1: *mut c_void, unnamed_2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_NullDeblurer_to_DeblurerBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_NullDeblurer_delete(instance: *mut c_void);
		pub fn cv_videostab_NullFrameSource_reset(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_NullFrameSource_nextFrame(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_NullFrameSource_to_IFrameSource(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_NullFrameSource_delete(instance: *mut c_void);
		pub fn cv_videostab_NullInpainter_inpaint_int_MatR_MatR(instance: *mut c_void, unnamed: i32, unnamed_1: *mut c_void, unnamed_2: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_NullInpainter_to_InpainterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_NullInpainter_delete(instance: *mut c_void);
		pub fn cv_videostab_NullLog_print_const_charX(instance: *mut c_void, unnamed: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_NullLog_to_ILog(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_NullLog_delete(instance: *mut c_void);
		pub fn cv_videostab_NullOutlierRejector_process_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, frame_size: *const core::Size, points0: *const c_void, points1: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_NullOutlierRejector_to_IOutlierRejector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_NullOutlierRejector_delete(instance: *mut c_void);
		pub fn cv_videostab_NullWobbleSuppressor_suppress_int_const_MatR_MatR(instance: *mut c_void, idx: i32, frame: *const c_void, result: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_NullWobbleSuppressor_to_WobbleSuppressorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_NullWobbleSuppressor_delete(instance: *mut c_void);
		pub fn cv_videostab_OnePassStabilizer_OnePassStabilizer(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_OnePassStabilizer_setMotionFilter_PtrLMotionFilterBaseG(instance: *mut c_void, val: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_OnePassStabilizer_motionFilter_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_OnePassStabilizer_reset(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_OnePassStabilizer_nextFrame(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_OnePassStabilizer_to_IFrameSource(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_OnePassStabilizer_to_StabilizerBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_OnePassStabilizer_delete(instance: *mut c_void);
		pub fn cv_videostab_PyrLkOptFlowEstimatorBase_PyrLkOptFlowEstimatorBase(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_PyrLkOptFlowEstimatorBase_setWinSize_Size(instance: *mut c_void, val: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_PyrLkOptFlowEstimatorBase_winSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_videostab_PyrLkOptFlowEstimatorBase_setMaxLevel_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_PyrLkOptFlowEstimatorBase_maxLevel_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_videostab_PyrLkOptFlowEstimatorBase_to_DensePyrLkOptFlowEstimatorGpu(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_PyrLkOptFlowEstimatorBase_to_SparsePyrLkOptFlowEstimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_PyrLkOptFlowEstimatorBase_to_SparsePyrLkOptFlowEstimatorGpu(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_PyrLkOptFlowEstimatorBase_delete(instance: *mut c_void);
		pub fn cv_videostab_RansacParams_RansacParams(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_RansacParams_RansacParams_int_float_float_float(size: i32, thresh: f32, eps: f32, prob: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_RansacParams_niters_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_videostab_RansacParams_default2dMotion_MotionModel(model: crate::videostab::MotionModel, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_RansacParams_propSize_const(instance: *const c_void) -> i32;
		pub fn cv_videostab_RansacParams_propSize_int(instance: *mut c_void, val: i32);
		pub fn cv_videostab_RansacParams_propThresh_const(instance: *const c_void) -> f32;
		pub fn cv_videostab_RansacParams_propThresh_float(instance: *mut c_void, val: f32);
		pub fn cv_videostab_RansacParams_propEps_const(instance: *const c_void) -> f32;
		pub fn cv_videostab_RansacParams_propEps_float(instance: *mut c_void, val: f32);
		pub fn cv_videostab_RansacParams_propProb_const(instance: *const c_void) -> f32;
		pub fn cv_videostab_RansacParams_propProb_float(instance: *mut c_void, val: f32);
		pub fn cv_videostab_RansacParams_delete(instance: *mut c_void);
		pub fn cv_videostab_SparsePyrLkOptFlowEstimator_run_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, points0: *const c_void, points1: *const c_void, status: *const c_void, errors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_SparsePyrLkOptFlowEstimator_to_ISparseOptFlowEstimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_SparsePyrLkOptFlowEstimator_to_PyrLkOptFlowEstimatorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_SparsePyrLkOptFlowEstimator_delete(instance: *mut c_void);
		pub fn cv_videostab_SparsePyrLkOptFlowEstimatorGpu_SparsePyrLkOptFlowEstimatorGpu(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_SparsePyrLkOptFlowEstimatorGpu_run_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, points0: *const c_void, points1: *const c_void, status: *const c_void, errors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_SparsePyrLkOptFlowEstimatorGpu_run_const_GpuMatR_const_GpuMatR_const_GpuMatR_GpuMatR_GpuMatR_GpuMatR(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, points0: *const c_void, points1: *mut c_void, status: *mut c_void, errors: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_SparsePyrLkOptFlowEstimatorGpu_run_const_GpuMatR_const_GpuMatR_const_GpuMatR_GpuMatR_GpuMatR(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, points0: *const c_void, points1: *mut c_void, status: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_SparsePyrLkOptFlowEstimatorGpu_to_ISparseOptFlowEstimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_SparsePyrLkOptFlowEstimatorGpu_to_PyrLkOptFlowEstimatorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_SparsePyrLkOptFlowEstimatorGpu_delete(instance: *mut c_void);
		pub fn cv_videostab_StabilizerBase_setLog_PtrLILogG(instance: *mut c_void, ilog: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_StabilizerBase_log_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_StabilizerBase_setRadius_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_StabilizerBase_radius_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_videostab_StabilizerBase_setFrameSource_PtrLIFrameSourceG(instance: *mut c_void, val: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_StabilizerBase_frameSource_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_StabilizerBase_setMaskSource_const_PtrLIFrameSourceGR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_StabilizerBase_maskSource_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_StabilizerBase_setMotionEstimator_PtrLImageMotionEstimatorBaseG(instance: *mut c_void, val: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_StabilizerBase_motionEstimator_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_StabilizerBase_setDeblurer_PtrLDeblurerBaseG(instance: *mut c_void, val: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_StabilizerBase_deblurrer_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_StabilizerBase_setTrimRatio_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_StabilizerBase_trimRatio_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_videostab_StabilizerBase_setCorrectionForInclusion_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_StabilizerBase_doCorrectionForInclusion_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_videostab_StabilizerBase_setBorderMode_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_StabilizerBase_borderMode_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_videostab_StabilizerBase_setInpainter_PtrLInpainterBaseG(instance: *mut c_void, val: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_StabilizerBase_inpainter_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_StabilizerBase_to_OnePassStabilizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_StabilizerBase_to_TwoPassStabilizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_StabilizerBase_delete(instance: *mut c_void);
		pub fn cv_videostab_ToFileMotionWriter_ToFileMotionWriter_const_StringR_PtrLImageMotionEstimatorBaseG(path: *const c_char, estimator: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_ToFileMotionWriter_setMotionModel_MotionModel(instance: *mut c_void, val: crate::videostab::MotionModel, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_ToFileMotionWriter_motionModel_const(instance: *const c_void, ocvrs_return: *mut Result<crate::videostab::MotionModel>);
		pub fn cv_videostab_ToFileMotionWriter_setFrameMask_const__InputArrayR(instance: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_ToFileMotionWriter_estimate_const_MatR_const_MatR_boolX(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, ok: *mut bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_ToFileMotionWriter_estimate_const_MatR_const_MatR(instance: *mut c_void, frame0: *const c_void, frame1: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_ToFileMotionWriter_to_ImageMotionEstimatorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_ToFileMotionWriter_delete(instance: *mut c_void);
		pub fn cv_videostab_TranslationBasedLocalOutlierRejector_TranslationBasedLocalOutlierRejector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_TranslationBasedLocalOutlierRejector_setCellSize_Size(instance: *mut c_void, val: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_TranslationBasedLocalOutlierRejector_cellSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_videostab_TranslationBasedLocalOutlierRejector_setRansacParams_RansacParams(instance: *mut c_void, val: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_TranslationBasedLocalOutlierRejector_ransacParams_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_TranslationBasedLocalOutlierRejector_process_Size_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, frame_size: *const core::Size, points0: *const c_void, points1: *const c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_TranslationBasedLocalOutlierRejector_to_IOutlierRejector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_TranslationBasedLocalOutlierRejector_delete(instance: *mut c_void);
		pub fn cv_videostab_TwoPassStabilizer_TwoPassStabilizer(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_TwoPassStabilizer_setMotionStabilizer_PtrLIMotionStabilizerG(instance: *mut c_void, val: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_TwoPassStabilizer_motionStabilizer_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_TwoPassStabilizer_setWobbleSuppressor_PtrLWobbleSuppressorBaseG(instance: *mut c_void, val: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_TwoPassStabilizer_wobbleSuppressor_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_TwoPassStabilizer_setEstimateTrimRatio_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_TwoPassStabilizer_mustEstimateTrimaRatio_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_videostab_TwoPassStabilizer_reset(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_TwoPassStabilizer_nextFrame(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_TwoPassStabilizer_to_IFrameSource(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_TwoPassStabilizer_to_StabilizerBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_TwoPassStabilizer_delete(instance: *mut c_void);
		pub fn cv_videostab_VideoFileSource_VideoFileSource_const_StringR_bool(path: *const c_char, volatile_frame: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_VideoFileSource_VideoFileSource_const_StringR(path: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_VideoFileSource_reset(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_VideoFileSource_nextFrame(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_VideoFileSource_width(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_videostab_VideoFileSource_height(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_videostab_VideoFileSource_count(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_videostab_VideoFileSource_fps(instance: *mut c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_videostab_VideoFileSource_to_IFrameSource(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_VideoFileSource_delete(instance: *mut c_void);
		pub fn cv_videostab_WeightingDeblurer_WeightingDeblurer(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_WeightingDeblurer_setSensitivity_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_WeightingDeblurer_sensitivity_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_videostab_WeightingDeblurer_deblur_int_MatR_const_RangeR(instance: *mut c_void, idx: i32, frame: *mut c_void, range: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_WeightingDeblurer_to_DeblurerBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_WeightingDeblurer_delete(instance: *mut c_void);
		pub fn cv_videostab_WobbleSuppressorBase_setMotionEstimator_PtrLImageMotionEstimatorBaseG(instance: *mut c_void, val: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_WobbleSuppressorBase_motionEstimator_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_WobbleSuppressorBase_suppress_int_const_MatR_MatR(instance: *mut c_void, idx: i32, frame: *const c_void, result: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_WobbleSuppressorBase_setFrameCount_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_WobbleSuppressorBase_frameCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_videostab_WobbleSuppressorBase_setMotions_const_vectorLMatGR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_WobbleSuppressorBase_motions_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_WobbleSuppressorBase_setMotions2_const_vectorLMatGR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_WobbleSuppressorBase_motions2_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_WobbleSuppressorBase_setStabilizationMotions_const_vectorLMatGR(instance: *mut c_void, val: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_videostab_WobbleSuppressorBase_stabilizationMotions_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_videostab_WobbleSuppressorBase_to_MoreAccurateMotionWobbleSuppressor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_WobbleSuppressorBase_to_MoreAccurateMotionWobbleSuppressorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_WobbleSuppressorBase_to_MoreAccurateMotionWobbleSuppressorGpu(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_WobbleSuppressorBase_to_NullWobbleSuppressor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_videostab_WobbleSuppressorBase_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_ColorAverageInpainterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ColorAverageInpainterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ColorAverageInpainterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_ColorAverageInpainterG_to_PtrOfInpainterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ColorAverageInpainterG_new_const_ColorAverageInpainter(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ColorInpainterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ColorInpainterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ColorInpainterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_ColorInpainterG_to_PtrOfInpainterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ColorInpainterG_new_const_ColorInpainter(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ConsistentMosaicInpainterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ConsistentMosaicInpainterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ConsistentMosaicInpainterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_ConsistentMosaicInpainterG_to_PtrOfInpainterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ConsistentMosaicInpainterG_new_const_ConsistentMosaicInpainter(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_DeblurerBaseG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_DeblurerBaseG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_DeblurerBaseG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_DensePyrLkOptFlowEstimatorGpuG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_DensePyrLkOptFlowEstimatorGpuG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_DensePyrLkOptFlowEstimatorGpuG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_DensePyrLkOptFlowEstimatorGpuG_to_PtrOfIDenseOptFlowEstimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_DensePyrLkOptFlowEstimatorGpuG_to_PtrOfPyrLkOptFlowEstimatorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_DensePyrLkOptFlowEstimatorGpuG_new_const_DensePyrLkOptFlowEstimatorGpu(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_FromFileMotionReaderG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_FromFileMotionReaderG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_FromFileMotionReaderG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_FromFileMotionReaderG_to_PtrOfImageMotionEstimatorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_FromFileMotionReaderG_new_const_FromFileMotionReader(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_GaussianMotionFilterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_GaussianMotionFilterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_GaussianMotionFilterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_GaussianMotionFilterG_to_PtrOfIMotionStabilizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_GaussianMotionFilterG_to_PtrOfMotionFilterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_GaussianMotionFilterG_new_const_GaussianMotionFilter(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_IDenseOptFlowEstimatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_IDenseOptFlowEstimatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_IDenseOptFlowEstimatorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_IFrameSourceG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_IFrameSourceG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_IFrameSourceG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_ILogG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ILogG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ILogG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_IMotionStabilizerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_IMotionStabilizerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_IMotionStabilizerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_IOutlierRejectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_IOutlierRejectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_IOutlierRejectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_ISparseOptFlowEstimatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ISparseOptFlowEstimatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ISparseOptFlowEstimatorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_ImageMotionEstimatorBaseG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ImageMotionEstimatorBaseG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ImageMotionEstimatorBaseG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_InpainterBaseG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_InpainterBaseG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_InpainterBaseG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_InpaintingPipelineG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_InpaintingPipelineG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_InpaintingPipelineG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_InpaintingPipelineG_to_PtrOfInpainterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_InpaintingPipelineG_new_const_InpaintingPipeline(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_KeypointBasedMotionEstimatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_KeypointBasedMotionEstimatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_KeypointBasedMotionEstimatorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_KeypointBasedMotionEstimatorG_to_PtrOfImageMotionEstimatorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_KeypointBasedMotionEstimatorG_new_const_KeypointBasedMotionEstimator(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_KeypointBasedMotionEstimatorGpuG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_KeypointBasedMotionEstimatorGpuG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_KeypointBasedMotionEstimatorGpuG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_KeypointBasedMotionEstimatorGpuG_to_PtrOfImageMotionEstimatorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_KeypointBasedMotionEstimatorGpuG_new_const_KeypointBasedMotionEstimatorGpu(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_LogToStdoutG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_LogToStdoutG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_LogToStdoutG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_LogToStdoutG_to_PtrOfILog(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_LogToStdoutG_new_const_LogToStdout(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_LpMotionStabilizerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_LpMotionStabilizerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_LpMotionStabilizerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_LpMotionStabilizerG_to_PtrOfIMotionStabilizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_LpMotionStabilizerG_new_const_LpMotionStabilizer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MaskFrameSourceG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MaskFrameSourceG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MaskFrameSourceG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_MaskFrameSourceG_to_PtrOfIFrameSource(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MaskFrameSourceG_new_const_MaskFrameSource(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MoreAccurateMotionWobbleSuppressorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MoreAccurateMotionWobbleSuppressorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MoreAccurateMotionWobbleSuppressorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_MoreAccurateMotionWobbleSuppressorG_to_PtrOfMoreAccurateMotionWobbleSuppressorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MoreAccurateMotionWobbleSuppressorG_to_PtrOfWobbleSuppressorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MoreAccurateMotionWobbleSuppressorG_new_const_MoreAccurateMotionWobbleSuppressor(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MoreAccurateMotionWobbleSuppressorBaseG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MoreAccurateMotionWobbleSuppressorBaseG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MoreAccurateMotionWobbleSuppressorBaseG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_MoreAccurateMotionWobbleSuppressorBaseG_to_PtrOfWobbleSuppressorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MoreAccurateMotionWobbleSuppressorGpuG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MoreAccurateMotionWobbleSuppressorGpuG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MoreAccurateMotionWobbleSuppressorGpuG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_MoreAccurateMotionWobbleSuppressorGpuG_to_PtrOfMoreAccurateMotionWobbleSuppressorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MoreAccurateMotionWobbleSuppressorGpuG_to_PtrOfWobbleSuppressorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MoreAccurateMotionWobbleSuppressorGpuG_new_const_MoreAccurateMotionWobbleSuppressorGpu(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionEstimatorBaseG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionEstimatorBaseG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionEstimatorBaseG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_MotionEstimatorL1G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionEstimatorL1G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionEstimatorL1G_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_MotionEstimatorL1G_to_PtrOfMotionEstimatorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionEstimatorL1G_new_const_MotionEstimatorL1(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionEstimatorRansacL2G_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionEstimatorRansacL2G_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionEstimatorRansacL2G_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_MotionEstimatorRansacL2G_to_PtrOfMotionEstimatorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionEstimatorRansacL2G_new_const_MotionEstimatorRansacL2(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionFilterBaseG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionFilterBaseG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionFilterBaseG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_MotionFilterBaseG_to_PtrOfIMotionStabilizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionInpainterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionInpainterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionInpainterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_MotionInpainterG_to_PtrOfInpainterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionInpainterG_new_const_MotionInpainter(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionStabilizationPipelineG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionStabilizationPipelineG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionStabilizationPipelineG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_MotionStabilizationPipelineG_to_PtrOfIMotionStabilizer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_MotionStabilizationPipelineG_new_const_MotionStabilizationPipeline(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullDeblurerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullDeblurerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullDeblurerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_NullDeblurerG_to_PtrOfDeblurerBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullDeblurerG_new_const_NullDeblurer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullFrameSourceG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullFrameSourceG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullFrameSourceG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_NullFrameSourceG_to_PtrOfIFrameSource(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullFrameSourceG_new_const_NullFrameSource(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullInpainterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullInpainterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullInpainterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_NullInpainterG_to_PtrOfInpainterBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullInpainterG_new_const_NullInpainter(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullLogG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullLogG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullLogG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_NullLogG_to_PtrOfILog(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullLogG_new_const_NullLog(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullOutlierRejectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullOutlierRejectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullOutlierRejectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_NullOutlierRejectorG_to_PtrOfIOutlierRejector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullOutlierRejectorG_new_const_NullOutlierRejector(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullWobbleSuppressorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullWobbleSuppressorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullWobbleSuppressorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_NullWobbleSuppressorG_to_PtrOfWobbleSuppressorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_NullWobbleSuppressorG_new_const_NullWobbleSuppressor(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_OnePassStabilizerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_OnePassStabilizerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_OnePassStabilizerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_OnePassStabilizerG_to_PtrOfIFrameSource(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_OnePassStabilizerG_to_PtrOfStabilizerBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_OnePassStabilizerG_new_const_OnePassStabilizer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_PyrLkOptFlowEstimatorBaseG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_PyrLkOptFlowEstimatorBaseG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_PyrLkOptFlowEstimatorBaseG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_PyrLkOptFlowEstimatorBaseG_new_const_PyrLkOptFlowEstimatorBase(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_SparsePyrLkOptFlowEstimatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_SparsePyrLkOptFlowEstimatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_SparsePyrLkOptFlowEstimatorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_SparsePyrLkOptFlowEstimatorG_to_PtrOfISparseOptFlowEstimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_SparsePyrLkOptFlowEstimatorG_to_PtrOfPyrLkOptFlowEstimatorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_SparsePyrLkOptFlowEstimatorG_new_const_SparsePyrLkOptFlowEstimator(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_SparsePyrLkOptFlowEstimatorGpuG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_SparsePyrLkOptFlowEstimatorGpuG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_SparsePyrLkOptFlowEstimatorGpuG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_SparsePyrLkOptFlowEstimatorGpuG_to_PtrOfISparseOptFlowEstimator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_SparsePyrLkOptFlowEstimatorGpuG_to_PtrOfPyrLkOptFlowEstimatorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_SparsePyrLkOptFlowEstimatorGpuG_new_const_SparsePyrLkOptFlowEstimatorGpu(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_StabilizerBaseG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_StabilizerBaseG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_StabilizerBaseG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_ToFileMotionWriterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ToFileMotionWriterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ToFileMotionWriterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_ToFileMotionWriterG_to_PtrOfImageMotionEstimatorBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_ToFileMotionWriterG_new_const_ToFileMotionWriter(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_TranslationBasedLocalOutlierRejectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_TranslationBasedLocalOutlierRejectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_TranslationBasedLocalOutlierRejectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_TranslationBasedLocalOutlierRejectorG_to_PtrOfIOutlierRejector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_TranslationBasedLocalOutlierRejectorG_new_const_TranslationBasedLocalOutlierRejector(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_TwoPassStabilizerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_TwoPassStabilizerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_TwoPassStabilizerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_TwoPassStabilizerG_to_PtrOfIFrameSource(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_TwoPassStabilizerG_to_PtrOfStabilizerBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_TwoPassStabilizerG_new_const_TwoPassStabilizer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_VideoFileSourceG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_VideoFileSourceG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_VideoFileSourceG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_VideoFileSourceG_to_PtrOfIFrameSource(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_VideoFileSourceG_new_const_VideoFileSource(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_WeightingDeblurerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_WeightingDeblurerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_WeightingDeblurerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_videostab_WeightingDeblurerG_to_PtrOfDeblurerBase(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_WeightingDeblurerG_new_const_WeightingDeblurer(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_WobbleSuppressorBaseG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_WobbleSuppressorBaseG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_videostab_WobbleSuppressorBaseG_delete(instance: *mut c_void);
	}
}
#[cfg(ocvrs_has_module_videostab)]
pub use videostab_sys::*;

#[cfg(ocvrs_has_module_viz)]
mod viz_sys {
	use super::*;

	extern "C" {
		pub fn cv_viz_computeNormals_const_MeshR_const__OutputArrayR(mesh: *const c_void, normals: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_getWindowByName_const_StringR(window_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_imshow_const_StringR_const__InputArrayR(window_name: *const c_char, image: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_imshow_const_StringR_const__InputArrayR_const_SizeR(window_name: *const c_char, image: *const c_void, window_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_makeCameraPose_const_Vec3dR_const_Vec3dR_const_Vec3dR(position: *const core::Vec3d, focal_point: *const core::Vec3d, y_dir: *const core::Vec3d, ocvrs_return: *mut Result<core::Affine3d>);
		pub fn cv_viz_makeTransformToGlobal_const_Vec3dR_const_Vec3dR_const_Vec3dR(axis_x: *const core::Vec3d, axis_y: *const core::Vec3d, axis_z: *const core::Vec3d, ocvrs_return: *mut Result<core::Affine3d>);
		pub fn cv_viz_makeTransformToGlobal_const_Vec3dR_const_Vec3dR_const_Vec3dR_const_Vec3dR(axis_x: *const core::Vec3d, axis_y: *const core::Vec3d, axis_z: *const core::Vec3d, origin: *const core::Vec3d, ocvrs_return: *mut Result<core::Affine3d>);
		pub fn cv_viz_readCloud_const_StringR(file: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_readCloud_const_StringR_const__OutputArrayR_const__OutputArrayR(file: *const c_char, colors: *const c_void, normals: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_readMesh_const_StringR(file: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_readPose_const_StringR_Affine3dR(file: *const c_char, pose: *mut core::Affine3d, ocvrs_return: *mut Result<bool>);
		pub fn cv_viz_readPose_const_StringR_Affine3dR_const_StringR(file: *const c_char, pose: *mut core::Affine3d, tag: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_viz_readTrajectory_const__OutputArrayR(traj: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_readTrajectory_const__OutputArrayR_const_StringR_int_int_const_StringR(traj: *const c_void, files_format: *const c_char, start: i32, end: i32, tag: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_viz_unregisterAllWindows(ocvrs_return: *mut Result_void);
		pub fn cv_viz_writeCloud_const_StringR_const__InputArrayR(file: *const c_char, cloud: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_writeCloud_const_StringR_const__InputArrayR_const__InputArrayR_const__InputArrayR_bool(file: *const c_char, cloud: *const c_void, colors: *const c_void, normals: *const c_void, binary: bool, ocvrs_return: *mut Result_void);
		pub fn cv_viz_writePose_const_StringR_const_Affine3dR(file: *const c_char, pose: *const core::Affine3d, ocvrs_return: *mut Result_void);
		pub fn cv_viz_writePose_const_StringR_const_Affine3dR_const_StringR(file: *const c_char, pose: *const core::Affine3d, tag: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_viz_writeTrajectory_const__InputArrayR(traj: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_writeTrajectory_const__InputArrayR_const_StringR_int_const_StringR(traj: *const c_void, files_format: *const c_char, start: i32, tag: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Camera_Camera_double_double_double_double_const_SizeR(fx: f64, fy: f64, cx: f64, cy: f64, window_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Camera_Camera_const_Vec2dR_const_SizeR(fov: *const core::Vec2d, window_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Camera_Camera_const_Matx33dR_const_SizeR(k: *const core::Matx33d, window_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Camera_Camera_const_Matx44dR_const_SizeR(proj: *const core::Matx44d, window_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Camera_getClip_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2d>);
		pub fn cv_viz_Camera_setClip_const_Vec2dR(instance: *mut c_void, clip: *const core::Vec2d, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Camera_getWindowSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_viz_Camera_setWindowSize_const_SizeR(instance: *mut c_void, window_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Camera_getFov_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2d>);
		pub fn cv_viz_Camera_setFov_const_Vec2dR(instance: *mut c_void, fov: *const core::Vec2d, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Camera_getPrincipalPoint_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2d>);
		pub fn cv_viz_Camera_getFocalLength_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec2d>);
		pub fn cv_viz_Camera_computeProjectionMatrix_const_Matx44dR(instance: *const c_void, proj: *mut core::Matx44d, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Camera_KinectCamera_const_SizeR(window_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Camera_delete(instance: *mut c_void);
		pub fn cv_viz_Color_Color(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_Color_double(gray: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_Color_double_double_double(blue: f64, green: f64, red: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_Color_const_ScalarR(color: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_operator_cv_Vec3b_const(instance: *const c_void, ocvrs_return: *mut Result<core::Vec3b>);
		pub fn cv_viz_Color_black(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_blue(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_green(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_red(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_cyan(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_yellow(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_magenta(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_white(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_gray(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_silver(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_mlab(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_navy(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_maroon(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_teal(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_olive(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_purple(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_azure(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_chartreuse(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_rose(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_lime(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_gold(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_orange(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_orange_red(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_indigo(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_brown(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_apricot(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_pink(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_raspberry(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_cherry(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_violet(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_amethyst(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_bluberry(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_celestial_blue(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_turquoise(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_not_set(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Color_delete(instance: *mut c_void);
		pub fn cv_viz_KeyboardEvent_KeyboardEvent_Action_const_StringR_unsigned_char_int(action: crate::viz::KeyboardEvent_Action, symbol: *const c_char, code: u8, modifiers: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_KeyboardEvent_propAction_const(instance: *const c_void, ocvrs_return: *mut crate::viz::KeyboardEvent_Action);
		pub fn cv_viz_KeyboardEvent_propAction_Action(instance: *mut c_void, val: crate::viz::KeyboardEvent_Action);
		pub fn cv_viz_KeyboardEvent_propSymbol_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_viz_KeyboardEvent_propSymbol_String(instance: *mut c_void, val: *mut c_char);
		pub fn cv_viz_KeyboardEvent_propCode_const(instance: *const c_void) -> u8;
		pub fn cv_viz_KeyboardEvent_propCode_unsigned_char(instance: *mut c_void, val: u8);
		pub fn cv_viz_KeyboardEvent_propModifiers_const(instance: *const c_void) -> i32;
		pub fn cv_viz_KeyboardEvent_propModifiers_int(instance: *mut c_void, val: i32);
		pub fn cv_viz_KeyboardEvent_delete(instance: *mut c_void);
		pub fn cv_viz_Mesh_Mesh(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Mesh_load_const_StringR_int(file: *const c_char, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Mesh_load_const_StringR(file: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Mesh_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_viz_Mesh_propCloud_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_viz_Mesh_propCloud_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_viz_Mesh_propColors_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_viz_Mesh_propColors_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_viz_Mesh_propNormals_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_viz_Mesh_propNormals_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_viz_Mesh_propPolygons_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_viz_Mesh_propPolygons_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_viz_Mesh_propTexture_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_viz_Mesh_propTexture_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_viz_Mesh_propTcoords_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_viz_Mesh_propTcoords_Mat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_viz_Mesh_delete(instance: *mut c_void);
		pub fn cv_viz_MouseEvent_MouseEvent_const_TypeR_const_MouseButtonR_const_PointR_int(typ: *const crate::viz::MouseEvent_Type, button: *const crate::viz::MouseEvent_MouseButton, pointer: *const core::Point, modifiers: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_MouseEvent_propType_const(instance: *const c_void, ocvrs_return: *mut crate::viz::MouseEvent_Type);
		pub fn cv_viz_MouseEvent_propType_Type(instance: *mut c_void, val: crate::viz::MouseEvent_Type);
		pub fn cv_viz_MouseEvent_propButton_const(instance: *const c_void, ocvrs_return: *mut crate::viz::MouseEvent_MouseButton);
		pub fn cv_viz_MouseEvent_propButton_MouseButton(instance: *mut c_void, val: crate::viz::MouseEvent_MouseButton);
		pub fn cv_viz_MouseEvent_propPointer_const(instance: *const c_void, ocvrs_return: *mut core::Point);
		pub fn cv_viz_MouseEvent_propPointer_Point(instance: *mut c_void, val: *const core::Point);
		pub fn cv_viz_MouseEvent_propModifiers_const(instance: *const c_void) -> i32;
		pub fn cv_viz_MouseEvent_propModifiers_int(instance: *mut c_void, val: i32);
		pub fn cv_viz_MouseEvent_delete(instance: *mut c_void);
		pub fn cv_viz_Viz3d_Viz3d_const_StringR(window_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Viz3d_Viz3d(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Viz3d_Viz3d_const_Viz3dR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Viz3d_operatorST_const_Viz3dR(instance: *mut c_void, unnamed: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_showWidget_const_StringR_const_WidgetR_const_Affine3dR(instance: *mut c_void, id: *const c_char, widget: *const c_void, pose: *const core::Affine3d, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_showWidget_const_StringR_const_WidgetR(instance: *mut c_void, id: *const c_char, widget: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_removeWidget_const_StringR(instance: *mut c_void, id: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_getWidget_const_const_StringR(instance: *const c_void, id: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Viz3d_removeAllWidgets(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_showImage_const__InputArrayR_const_SizeR(instance: *mut c_void, image: *const c_void, window_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_showImage_const__InputArrayR(instance: *mut c_void, image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_setWidgetPose_const_StringR_const_Affine3dR(instance: *mut c_void, id: *const c_char, pose: *const core::Affine3d, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_updateWidgetPose_const_StringR_const_Affine3dR(instance: *mut c_void, id: *const c_char, pose: *const core::Affine3d, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_getWidgetPose_const_const_StringR(instance: *const c_void, id: *const c_char, ocvrs_return: *mut Result<core::Affine3d>);
		pub fn cv_viz_Viz3d_setCamera_const_CameraR(instance: *mut c_void, camera: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_getCamera_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Viz3d_getViewerPose_const(instance: *const c_void, ocvrs_return: *mut Result<core::Affine3d>);
		pub fn cv_viz_Viz3d_setViewerPose_const_Affine3dR(instance: *mut c_void, pose: *const core::Affine3d, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_resetCameraViewpoint_const_StringR(instance: *mut c_void, id: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_resetCamera(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_convertToWindowCoordinates_const_Point3dR_Point3dR(instance: *mut c_void, pt: *const core::Point3d, window_coord: *mut core::Point3d, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_converTo3DRay_const_Point3dR_Point3dR_Vec3dR(instance: *mut c_void, window_coord: *const core::Point3d, origin: *mut core::Point3d, direction: *mut core::Vec3d, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_getWindowSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_viz_Viz3d_setWindowSize_const_SizeR(instance: *mut c_void, window_size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_getWindowName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Viz3d_getScreenshot_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Viz3d_saveScreenshot_const_StringR(instance: *mut c_void, file: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_setWindowPosition_const_PointR(instance: *mut c_void, window_position: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_setFullScreen_bool(instance: *mut c_void, mode: bool, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_setFullScreen(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_setBackgroundColor_const_ColorR_const_ColorR(instance: *mut c_void, color: *const c_void, color2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_setBackgroundColor(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_setBackgroundTexture_const__InputArrayR(instance: *mut c_void, image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_setBackgroundTexture(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_setBackgroundMeshLab(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_spin(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_spinOnce_int_bool(instance: *mut c_void, time: i32, force_redraw: bool, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_spinOnce(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_setOffScreenRendering(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_removeAllLights(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_addLight_const_Vec3dR_const_Vec3dR_const_ColorR_const_ColorR_const_ColorR_const_ColorR(instance: *mut c_void, position: *const core::Vec3d, focal_point: *const core::Vec3d, color: *const c_void, diffuse_color: *const c_void, ambient_color: *const c_void, specular_color: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_addLight_const_Vec3dR(instance: *mut c_void, position: *const core::Vec3d, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_wasStopped_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_viz_Viz3d_close(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_registerKeyboardCallback_KeyboardCallback_voidX(instance: *mut c_void, callback: Option<unsafe extern "C" fn(*const c_void, *mut c_void) -> ()>, cookie: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_registerMouseCallback_MouseCallback_voidX(instance: *mut c_void, callback: Option<unsafe extern "C" fn(*const c_void, *mut c_void) -> ()>, cookie: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_setRenderingProperty_const_StringR_int_double(instance: *mut c_void, id: *const c_char, property: i32, value: f64, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_getRenderingProperty_const_StringR_int(instance: *mut c_void, id: *const c_char, property: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_viz_Viz3d_setRepresentation_int(instance: *mut c_void, representation: i32, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_setGlobalWarnings_bool(instance: *mut c_void, enabled: bool, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_setGlobalWarnings(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Viz3d_delete(instance: *mut c_void);
		pub fn cv_viz_WArrow_WArrow_const_Point3dR_const_Point3dR_double_const_ColorR(pt1: *const core::Point3d, pt2: *const core::Point3d, thickness: f64, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WArrow_WArrow_const_Point3dR_const_Point3dR(pt1: *const core::Point3d, pt2: *const core::Point3d, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WArrow_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WArrow_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WArrow_delete(instance: *mut c_void);
		pub fn cv_viz_WCameraPosition_WCameraPosition_double(scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCameraPosition_WCameraPosition(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCameraPosition_WCameraPosition_const_Matx33dR_double_const_ColorR(k: *const core::Matx33d, scale: f64, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCameraPosition_WCameraPosition_const_Matx33dR(k: *const core::Matx33d, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCameraPosition_WCameraPosition_const_Vec2dR_double_const_ColorR(fov: *const core::Vec2d, scale: f64, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCameraPosition_WCameraPosition_const_Vec2dR(fov: *const core::Vec2d, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCameraPosition_WCameraPosition_const_Matx33dR_const__InputArrayR_double_const_ColorR(k: *const core::Matx33d, image: *const c_void, scale: f64, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCameraPosition_WCameraPosition_const_Matx33dR_const__InputArrayR(k: *const core::Matx33d, image: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCameraPosition_WCameraPosition_const_Vec2dR_const__InputArrayR_double_const_ColorR(fov: *const core::Vec2d, image: *const c_void, scale: f64, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCameraPosition_WCameraPosition_const_Vec2dR_const__InputArrayR(fov: *const core::Vec2d, image: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCameraPosition_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WCameraPosition_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WCameraPosition_delete(instance: *mut c_void);
		pub fn cv_viz_WCircle_WCircle_double_double_const_ColorR(radius: f64, thickness: f64, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCircle_WCircle_double(radius: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCircle_WCircle_double_const_Point3dR_const_Vec3dR_double_const_ColorR(radius: f64, center: *const core::Point3d, normal: *const core::Vec3d, thickness: f64, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCircle_WCircle_double_const_Point3dR_const_Vec3dR(radius: f64, center: *const core::Point3d, normal: *const core::Vec3d, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCircle_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WCircle_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WCircle_delete(instance: *mut c_void);
		pub fn cv_viz_WCloud_WCloud_const__InputArrayR_const__InputArrayR(cloud: *const c_void, colors: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCloud_WCloud_const__InputArrayR_const_ColorR(cloud: *const c_void, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCloud_WCloud_const__InputArrayR(cloud: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCloud_WCloud_const__InputArrayR_const__InputArrayR_const__InputArrayR(cloud: *const c_void, colors: *const c_void, normals: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCloud_WCloud_const__InputArrayR_const_ColorR_const__InputArrayR(cloud: *const c_void, color: *const c_void, normals: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCloud_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WCloud_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WCloud_delete(instance: *mut c_void);
		pub fn cv_viz_WCloudCollection_WCloudCollection(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCloudCollection_addCloud_const__InputArrayR_const__InputArrayR_const_Affine3dR(instance: *mut c_void, cloud: *const c_void, colors: *const c_void, pose: *const core::Affine3d, ocvrs_return: *mut Result_void);
		pub fn cv_viz_WCloudCollection_addCloud_const__InputArrayR_const__InputArrayR(instance: *mut c_void, cloud: *const c_void, colors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_WCloudCollection_addCloud_const__InputArrayR_const_ColorR_const_Affine3dR(instance: *mut c_void, cloud: *const c_void, color: *const c_void, pose: *const core::Affine3d, ocvrs_return: *mut Result_void);
		pub fn cv_viz_WCloudCollection_addCloud_const__InputArrayR(instance: *mut c_void, cloud: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_WCloudCollection_finalize(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_WCloudCollection_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WCloudCollection_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WCloudCollection_delete(instance: *mut c_void);
		pub fn cv_viz_WCloudNormals_WCloudNormals_const__InputArrayR_const__InputArrayR_int_double_const_ColorR(cloud: *const c_void, normals: *const c_void, level: i32, scale: f64, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCloudNormals_WCloudNormals_const__InputArrayR_const__InputArrayR(cloud: *const c_void, normals: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCloudNormals_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WCloudNormals_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WCloudNormals_delete(instance: *mut c_void);
		pub fn cv_viz_WCone_WCone_double_double_int_const_ColorR(length: f64, radius: f64, resolution: i32, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCone_WCone_double_double(length: f64, radius: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCone_WCone_double_const_Point3dR_const_Point3dR_int_const_ColorR(radius: f64, center: *const core::Point3d, tip: *const core::Point3d, resolution: i32, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCone_WCone_double_const_Point3dR_const_Point3dR(radius: f64, center: *const core::Point3d, tip: *const core::Point3d, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCone_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WCone_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WCone_delete(instance: *mut c_void);
		pub fn cv_viz_WCoordinateSystem_WCoordinateSystem_double(scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCoordinateSystem_WCoordinateSystem(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCoordinateSystem_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WCoordinateSystem_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WCoordinateSystem_delete(instance: *mut c_void);
		pub fn cv_viz_WCube_WCube_const_Point3dR_const_Point3dR_bool_const_ColorR(min_point: *const core::Point3d, max_point: *const core::Point3d, wire_frame: bool, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCube_WCube(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCube_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WCube_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WCube_delete(instance: *mut c_void);
		pub fn cv_viz_WCylinder_WCylinder_const_Point3dR_const_Point3dR_double_int_const_ColorR(axis_point1: *const core::Point3d, axis_point2: *const core::Point3d, radius: f64, numsides: i32, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCylinder_WCylinder_const_Point3dR_const_Point3dR_double(axis_point1: *const core::Point3d, axis_point2: *const core::Point3d, radius: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WCylinder_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WCylinder_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WCylinder_delete(instance: *mut c_void);
		pub fn cv_viz_WGrid_WGrid_const_Vec2iR_const_Vec2dR_const_ColorR(cells: *const core::Vec2i, cells_spacing: *const core::Vec2d, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WGrid_WGrid(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WGrid_WGrid_const_Point3dR_const_Vec3dR_const_Vec3dR_const_Vec2iR_const_Vec2dR_const_ColorR(center: *const core::Point3d, normal: *const core::Vec3d, new_yaxis: *const core::Vec3d, cells: *const core::Vec2i, cells_spacing: *const core::Vec2d, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WGrid_WGrid_const_Point3dR_const_Vec3dR_const_Vec3dR(center: *const core::Point3d, normal: *const core::Vec3d, new_yaxis: *const core::Vec3d, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WGrid_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WGrid_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WGrid_delete(instance: *mut c_void);
		pub fn cv_viz_WImage3D_WImage3D_const__InputArrayR_const_Size2dR(image: *const c_void, size: *const core::Size2d, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WImage3D_WImage3D_const__InputArrayR_const_Size2dR_const_Vec3dR_const_Vec3dR_const_Vec3dR(image: *const c_void, size: *const core::Size2d, center: *const core::Vec3d, normal: *const core::Vec3d, up_vector: *const core::Vec3d, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WImage3D_setImage_const__InputArrayR(instance: *mut c_void, image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_WImage3D_setSize_const_SizeR(instance: *mut c_void, size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_viz_WImage3D_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WImage3D_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WImage3D_delete(instance: *mut c_void);
		pub fn cv_viz_WImageOverlay_WImageOverlay_const__InputArrayR_const_RectR(image: *const c_void, rect: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WImageOverlay_setImage_const__InputArrayR(instance: *mut c_void, image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_WImageOverlay_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WImageOverlay_to_Widget2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WImageOverlay_delete(instance: *mut c_void);
		pub fn cv_viz_WLine_WLine_const_Point3dR_const_Point3dR_const_ColorR(pt1: *const core::Point3d, pt2: *const core::Point3d, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WLine_WLine_const_Point3dR_const_Point3dR(pt1: *const core::Point3d, pt2: *const core::Point3d, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WLine_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WLine_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WLine_delete(instance: *mut c_void);
		pub fn cv_viz_WMesh_WMesh_const_MeshR(mesh: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WMesh_WMesh_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(cloud: *const c_void, polygons: *const c_void, colors: *const c_void, normals: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WMesh_WMesh_const__InputArrayR_const__InputArrayR(cloud: *const c_void, polygons: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WMesh_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WMesh_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WMesh_delete(instance: *mut c_void);
		pub fn cv_viz_WPaintedCloud_WPaintedCloud_const__InputArrayR(cloud: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WPaintedCloud_WPaintedCloud_const__InputArrayR_const_Point3dR_const_Point3dR(cloud: *const c_void, p1: *const core::Point3d, p2: *const core::Point3d, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WPaintedCloud_WPaintedCloud_const__InputArrayR_const_Point3dR_const_Point3dR_const_ColorR_const_Color(cloud: *const c_void, p1: *const core::Point3d, p2: *const core::Point3d, c1: *const c_void, c2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WPaintedCloud_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WPaintedCloud_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WPaintedCloud_delete(instance: *mut c_void);
		pub fn cv_viz_WPlane_WPlane_const_Size2dR_const_ColorR(size: *const core::Size2d, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WPlane_WPlane(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WPlane_WPlane_const_Point3dR_const_Vec3dR_const_Vec3dR_const_Size2dR_const_ColorR(center: *const core::Point3d, normal: *const core::Vec3d, new_yaxis: *const core::Vec3d, size: *const core::Size2d, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WPlane_WPlane_const_Point3dR_const_Vec3dR_const_Vec3dR(center: *const core::Point3d, normal: *const core::Vec3d, new_yaxis: *const core::Vec3d, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WPlane_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WPlane_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WPlane_delete(instance: *mut c_void);
		pub fn cv_viz_WPolyLine_WPolyLine_const__InputArrayR_const__InputArrayR(points: *const c_void, colors: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WPolyLine_WPolyLine_const__InputArrayR_const_ColorR(points: *const c_void, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WPolyLine_WPolyLine_const__InputArrayR(points: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WPolyLine_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WPolyLine_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WPolyLine_delete(instance: *mut c_void);
		pub fn cv_viz_WSphere_WSphere_const_Point3dR_double_int_const_ColorR(center: *const core::Point3d, radius: f64, sphere_resolution: i32, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WSphere_WSphere_const_Point3dR_double(center: *const core::Point3d, radius: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WSphere_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WSphere_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WSphere_delete(instance: *mut c_void);
		pub fn cv_viz_WText_WText_const_StringR_const_PointR_int_const_ColorR(text: *const c_char, pos: *const core::Point, font_size: i32, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WText_WText_const_StringR_const_PointR(text: *const c_char, pos: *const core::Point, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WText_setText_const_StringR(instance: *mut c_void, text: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_viz_WText_getText_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WText_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WText_to_Widget2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WText_delete(instance: *mut c_void);
		pub fn cv_viz_WText3D_WText3D_const_StringR_const_Point3dR_double_bool_const_ColorR(text: *const c_char, position: *const core::Point3d, text_scale: f64, face_camera: bool, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WText3D_WText3D_const_StringR_const_Point3dR(text: *const c_char, position: *const core::Point3d, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WText3D_setText_const_StringR(instance: *mut c_void, text: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_viz_WText3D_getText_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WText3D_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WText3D_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WText3D_delete(instance: *mut c_void);
		pub fn cv_viz_WTrajectory_WTrajectory_const__InputArrayR_int_double_const_ColorR(path: *const c_void, display_mode: i32, scale: f64, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WTrajectory_WTrajectory_const__InputArrayR(path: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WTrajectory_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WTrajectory_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WTrajectory_delete(instance: *mut c_void);
		pub fn cv_viz_WTrajectoryFrustums_WTrajectoryFrustums_const__InputArrayR_const_Matx33dR_double_const_ColorR(path: *const c_void, k: *const core::Matx33d, scale: f64, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WTrajectoryFrustums_WTrajectoryFrustums_const__InputArrayR_const_Matx33dR(path: *const c_void, k: *const core::Matx33d, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WTrajectoryFrustums_WTrajectoryFrustums_const__InputArrayR_const_Vec2dR_double_const_ColorR(path: *const c_void, fov: *const core::Vec2d, scale: f64, color: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WTrajectoryFrustums_WTrajectoryFrustums_const__InputArrayR_const_Vec2dR(path: *const c_void, fov: *const core::Vec2d, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WTrajectoryFrustums_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WTrajectoryFrustums_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WTrajectoryFrustums_delete(instance: *mut c_void);
		pub fn cv_viz_WTrajectorySpheres_WTrajectorySpheres_const__InputArrayR_double_double_const_ColorR_const_ColorR(path: *const c_void, line_length: f64, radius: f64, from: *const c_void, to: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WTrajectorySpheres_WTrajectorySpheres_const__InputArrayR(path: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WTrajectorySpheres_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WTrajectorySpheres_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WTrajectorySpheres_delete(instance: *mut c_void);
		pub fn cv_viz_WWidgetMerger_WWidgetMerger(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_WWidgetMerger_addWidget_const_Widget3DR_const_Affine3dR(instance: *mut c_void, widget: *const c_void, pose: *const core::Affine3d, ocvrs_return: *mut Result_void);
		pub fn cv_viz_WWidgetMerger_addWidget_const_Widget3DR(instance: *mut c_void, widget: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_WWidgetMerger_finalize(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_WWidgetMerger_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WWidgetMerger_to_Widget3D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_WWidgetMerger_delete(instance: *mut c_void);
		pub fn cv_viz_Widget_Widget(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Widget_Widget_const_WidgetR(other: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Widget_operatorST_const_WidgetR(instance: *mut c_void, other: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Widget_fromPlyFile_const_StringR(file_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Widget_setRenderingProperty_int_double(instance: *mut c_void, property: i32, value: f64, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Widget_getRenderingProperty_const_int(instance: *const c_void, property: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_viz_Widget_delete(instance: *mut c_void);
		pub fn cv_viz_Widget2D_Widget2D(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Widget2D_setColor_const_ColorR(instance: *mut c_void, color: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Widget2D_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_Widget2D_delete(instance: *mut c_void);
		pub fn cv_viz_Widget3D_Widget3D(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_viz_Widget3D_setPose_const_Affine3dR(instance: *mut c_void, pose: *const core::Affine3d, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Widget3D_updatePose_const_Affine3dR(instance: *mut c_void, pose: *const core::Affine3d, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Widget3D_getPose_const(instance: *const c_void, ocvrs_return: *mut Result<core::Affine3d>);
		pub fn cv_viz_Widget3D_applyTransform_const_Affine3dR(instance: *mut c_void, transform: *const core::Affine3d, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Widget3D_setColor_const_ColorR(instance: *mut c_void, color: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_viz_Widget3D_to_Widget(instance: *mut c_void) -> *mut c_void;
		pub fn cv_viz_Widget3D_delete(instance: *mut c_void);
	}
}
#[cfg(ocvrs_has_module_viz)]
pub use viz_sys::*;

#[cfg(ocvrs_has_module_wechat_qrcode)]
mod wechat_qrcode_sys {
	use super::*;

	extern "C" {
		pub fn cv_wechat_qrcode_WeChatQRCode_WeChatQRCode_const_stringR_const_stringR_const_stringR_const_stringR(detector_prototxt_path: *const c_char, detector_caffe_model_path: *const c_char, super_resolution_prototxt_path: *const c_char, super_resolution_caffe_model_path: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_wechat_qrcode_WeChatQRCode_WeChatQRCode(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_wechat_qrcode_WeChatQRCode_detectAndDecode_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, img: *const c_void, points: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_wechat_qrcode_WeChatQRCode_detectAndDecode_const__InputArrayR(instance: *mut c_void, img: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_wechat_qrcode_WeChatQRCode_setScaleFactor_float(instance: *mut c_void, _scaling_factor: f32, ocvrs_return: *mut Result_void);
		pub fn cv_wechat_qrcode_WeChatQRCode_getScaleFactor(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_wechat_qrcode_WeChatQRCode_delete(instance: *mut c_void);
	}
}
#[cfg(ocvrs_has_module_wechat_qrcode)]
pub use wechat_qrcode_sys::*;

#[cfg(ocvrs_has_module_xfeatures2d)]
mod xfeatures2d_sys {
	use super::*;

	extern "C" {
		pub fn cv_xfeatures2d_FASTForPointSet_const__InputArrayR_vectorLKeyPointGR_int(image: *const c_void, keypoints: *mut c_void, threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_FASTForPointSet_const__InputArrayR_vectorLKeyPointGR_int_bool_DetectorType(image: *const c_void, keypoints: *mut c_void, threshold: i32, nonmax_suppression: bool, typ: crate::features2d::FastFeatureDetector_DetectorType, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_matchGMS_const_SizeR_const_SizeR_const_vectorLKeyPointGR_const_vectorLKeyPointGR_const_vectorLDMatchGR_vectorLDMatchGR(size1: *const core::Size, size2: *const core::Size, keypoints1: *const c_void, keypoints2: *const c_void, matches1to2: *const c_void, matches_gms: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_matchGMS_const_SizeR_const_SizeR_const_vectorLKeyPointGR_const_vectorLKeyPointGR_const_vectorLDMatchGR_vectorLDMatchGR_const_bool_const_bool_const_double(size1: *const core::Size, size2: *const core::Size, keypoints1: *const c_void, keypoints2: *const c_void, matches1to2: *const c_void, matches_gms: *mut c_void, with_rotation: bool, with_scale: bool, threshold_factor: f64, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_matchLOGOS_const_vectorLKeyPointGR_const_vectorLKeyPointGR_const_vectorLintGR_const_vectorLintGR_vectorLDMatchGR(keypoints1: *const c_void, keypoints2: *const c_void, nn1: *const c_void, nn2: *const c_void, matches1to2: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SURF_CUDA_SURF_CUDA(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_SURF_CUDA_SURF_CUDA_double_int_int_bool_float_bool(_hessian_threshold: f64, _n_octaves: i32, _n_octave_layers: i32, _extended: bool, _keypoints_ratio: f32, _upright: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_SURF_CUDA_SURF_CUDA_double(_hessian_threshold: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_SURF_CUDA_create_double_int_int_bool_float_bool(_hessian_threshold: f64, _n_octaves: i32, _n_octave_layers: i32, _extended: bool, _keypoints_ratio: f32, _upright: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_SURF_CUDA_create_double(_hessian_threshold: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cuda_SURF_CUDA_descriptorSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_SURF_CUDA_defaultNorm_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cuda_SURF_CUDA_uploadKeypoints_const_vectorLKeyPointGR_GpuMatR(instance: *mut c_void, keypoints: *const c_void, keypoints_gpu: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SURF_CUDA_downloadKeypoints_const_GpuMatR_vectorLKeyPointGR(instance: *mut c_void, keypoints_gpu: *const c_void, keypoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SURF_CUDA_downloadDescriptors_const_GpuMatR_vectorLfloatGR(instance: *mut c_void, descriptors_gpu: *const c_void, descriptors: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SURF_CUDA_operator___const_GpuMatR_const_GpuMatR_GpuMatR(instance: *mut c_void, img: *const c_void, mask: *const c_void, keypoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SURF_CUDA_operator___const_GpuMatR_const_GpuMatR_GpuMatR_GpuMatR_bool(instance: *mut c_void, img: *const c_void, mask: *const c_void, keypoints: *mut c_void, descriptors: *mut c_void, use_provided_keypoints: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SURF_CUDA_operator___const_GpuMatR_const_GpuMatR_GpuMatR_GpuMatR(instance: *mut c_void, img: *const c_void, mask: *const c_void, keypoints: *mut c_void, descriptors: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SURF_CUDA_detect_const_GpuMatR_const_GpuMatR_GpuMatR(instance: *mut c_void, img: *const c_void, mask: *const c_void, keypoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SURF_CUDA_operator___const_GpuMatR_const_GpuMatR_vectorLKeyPointGR(instance: *mut c_void, img: *const c_void, mask: *const c_void, keypoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SURF_CUDA_operator___const_GpuMatR_const_GpuMatR_vectorLKeyPointGR_GpuMatR_bool(instance: *mut c_void, img: *const c_void, mask: *const c_void, keypoints: *mut c_void, descriptors: *mut c_void, use_provided_keypoints: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SURF_CUDA_operator___const_GpuMatR_const_GpuMatR_vectorLKeyPointGR_GpuMatR(instance: *mut c_void, img: *const c_void, mask: *const c_void, keypoints: *mut c_void, descriptors: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SURF_CUDA_detectWithDescriptors_const_GpuMatR_const_GpuMatR_GpuMatR_GpuMatR_bool(instance: *mut c_void, img: *const c_void, mask: *const c_void, keypoints: *mut c_void, descriptors: *mut c_void, use_provided_keypoints: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SURF_CUDA_detectWithDescriptors_const_GpuMatR_const_GpuMatR_GpuMatR_GpuMatR(instance: *mut c_void, img: *const c_void, mask: *const c_void, keypoints: *mut c_void, descriptors: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SURF_CUDA_operator___const_GpuMatR_const_GpuMatR_vectorLKeyPointGR_vectorLfloatGR_bool(instance: *mut c_void, img: *const c_void, mask: *const c_void, keypoints: *mut c_void, descriptors: *mut c_void, use_provided_keypoints: bool, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SURF_CUDA_operator___const_GpuMatR_const_GpuMatR_vectorLKeyPointGR_vectorLfloatGR(instance: *mut c_void, img: *const c_void, mask: *const c_void, keypoints: *mut c_void, descriptors: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SURF_CUDA_releaseMemory(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_cuda_SURF_CUDA_propHessianThreshold_const(instance: *const c_void) -> f64;
		pub fn cv_cuda_SURF_CUDA_propHessianThreshold_double(instance: *mut c_void, val: f64);
		pub fn cv_cuda_SURF_CUDA_propNOctaves_const(instance: *const c_void) -> i32;
		pub fn cv_cuda_SURF_CUDA_propNOctaves_int(instance: *mut c_void, val: i32);
		pub fn cv_cuda_SURF_CUDA_propNOctaveLayers_const(instance: *const c_void) -> i32;
		pub fn cv_cuda_SURF_CUDA_propNOctaveLayers_int(instance: *mut c_void, val: i32);
		pub fn cv_cuda_SURF_CUDA_propExtended_const(instance: *const c_void) -> bool;
		pub fn cv_cuda_SURF_CUDA_propExtended_bool(instance: *mut c_void, val: bool);
		pub fn cv_cuda_SURF_CUDA_propUpright_const(instance: *const c_void) -> bool;
		pub fn cv_cuda_SURF_CUDA_propUpright_bool(instance: *mut c_void, val: bool);
		pub fn cv_cuda_SURF_CUDA_propKeypointsRatio_const(instance: *const c_void) -> f32;
		pub fn cv_cuda_SURF_CUDA_propKeypointsRatio_float(instance: *mut c_void, val: f32);
		pub fn cv_cuda_SURF_CUDA_propSum_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_cuda_SURF_CUDA_propSum_GpuMat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_cuda_SURF_CUDA_propMask1_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_cuda_SURF_CUDA_propMask1_GpuMat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_cuda_SURF_CUDA_propMaskSum_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_cuda_SURF_CUDA_propMaskSum_GpuMat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_cuda_SURF_CUDA_propDet_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_cuda_SURF_CUDA_propDet_GpuMat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_cuda_SURF_CUDA_propTrace_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_cuda_SURF_CUDA_propTrace_GpuMat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_cuda_SURF_CUDA_propMaxPosBuffer_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_cuda_SURF_CUDA_propMaxPosBuffer_GpuMat(instance: *mut c_void, val: *mut c_void);
		pub fn cv_cuda_SURF_CUDA_delete(instance: *mut c_void);
		pub fn cv_xfeatures2d_AffineFeature2D_create_PtrLFeature2DG_PtrLFeature2DG(keypoint_detector: *mut c_void, descriptor_extractor: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_AffineFeature2D_create_PtrLFeature2DG(keypoint_detector: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_AffineFeature2D_detect_const__InputArrayR_vectorLElliptic_KeyPointGR_const__InputArrayR(instance: *mut c_void, image: *const c_void, keypoints: *mut c_void, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_AffineFeature2D_detect_const__InputArrayR_vectorLElliptic_KeyPointGR(instance: *mut c_void, image: *const c_void, keypoints: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_AffineFeature2D_detectAndCompute_const__InputArrayR_const__InputArrayR_vectorLElliptic_KeyPointGR_const__OutputArrayR_bool(instance: *mut c_void, image: *const c_void, mask: *const c_void, keypoints: *mut c_void, descriptors: *const c_void, use_provided_keypoints: bool, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_AffineFeature2D_detectAndCompute_const__InputArrayR_const__InputArrayR_vectorLElliptic_KeyPointGR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, mask: *const c_void, keypoints: *mut c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_AffineFeature2D_to_TBMR(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_AffineFeature2D_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_AffineFeature2D_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_AffineFeature2D_delete(instance: *mut c_void);
		pub fn cv_xfeatures2d_BEBLID_create_float_int(scale_factor: f32, n_bits: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_BEBLID_create_float(scale_factor: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_BEBLID_setScaleFactor_float(instance: *mut c_void, scale_factor: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_BEBLID_getScaleFactor_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_BEBLID_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_BEBLID_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_BEBLID_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_BEBLID_delete(instance: *mut c_void);
		pub fn cv_xfeatures2d_BoostDesc_create_int_bool_float(desc: i32, use_scale_orientation: bool, scale_factor: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_BoostDesc_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_BoostDesc_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_BoostDesc_setUseScaleOrientation_const_bool(instance: *mut c_void, use_scale_orientation: bool, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_BoostDesc_getUseScaleOrientation_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_xfeatures2d_BoostDesc_setScaleFactor_const_float(instance: *mut c_void, scale_factor: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_BoostDesc_getScaleFactor_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_BoostDesc_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_BoostDesc_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_BoostDesc_delete(instance: *mut c_void);
		pub fn cv_xfeatures2d_BriefDescriptorExtractor_create_int_bool(bytes: i32, use_orientation: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_BriefDescriptorExtractor_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_BriefDescriptorExtractor_setDescriptorSize_int(instance: *mut c_void, bytes: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_BriefDescriptorExtractor_getDescriptorSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_BriefDescriptorExtractor_setUseOrientation_bool(instance: *mut c_void, use_orientation: bool, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_BriefDescriptorExtractor_getUseOrientation_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_xfeatures2d_BriefDescriptorExtractor_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_BriefDescriptorExtractor_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_BriefDescriptorExtractor_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_BriefDescriptorExtractor_delete(instance: *mut c_void);
		pub fn cv_xfeatures2d_DAISY_create_float_int_int_int_NormalizationType_const__InputArrayR_bool_bool(radius: f32, q_radius: i32, q_theta: i32, q_hist: i32, norm: crate::xfeatures2d::DAISY_NormalizationType, h: *const c_void, interpolation: bool, use_orientation: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_DAISY_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_DAISY_setRadius_float(instance: *mut c_void, radius: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_DAISY_getRadius_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_DAISY_setQRadius_int(instance: *mut c_void, q_radius: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_DAISY_getQRadius_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_DAISY_setQTheta_int(instance: *mut c_void, q_theta: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_DAISY_getQTheta_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_DAISY_setQHist_int(instance: *mut c_void, q_hist: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_DAISY_getQHist_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_DAISY_setNorm_int(instance: *mut c_void, norm: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_DAISY_getNorm_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_DAISY_setH_const__InputArrayR(instance: *mut c_void, h: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_DAISY_getH_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_DAISY_setInterpolation_bool(instance: *mut c_void, interpolation: bool, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_DAISY_getInterpolation_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_xfeatures2d_DAISY_setUseOrientation_bool(instance: *mut c_void, use_orientation: bool, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_DAISY_getUseOrientation_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_xfeatures2d_DAISY_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_DAISY_compute_const__InputArrayR_vectorLKeyPointGR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, keypoints: *mut c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_DAISY_compute_const__InputArrayR_vectorLvectorLKeyPointGGR_const__OutputArrayR(instance: *mut c_void, images: *const c_void, keypoints: *mut c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_DAISY_compute_const__InputArrayR_Rect_const__OutputArrayR(instance: *mut c_void, image: *const c_void, roi: *const core::Rect, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_DAISY_compute_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, descriptors: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_DAISY_GetDescriptor_const_double_double_int_floatX(instance: *const c_void, y: f64, x: f64, orientation: i32, descriptor: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_DAISY_GetDescriptor_const_double_double_int_floatX_doubleX(instance: *const c_void, y: f64, x: f64, orientation: i32, descriptor: *mut f32, h: *mut f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_xfeatures2d_DAISY_GetUnnormalizedDescriptor_const_double_double_int_floatX(instance: *const c_void, y: f64, x: f64, orientation: i32, descriptor: *mut f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_DAISY_GetUnnormalizedDescriptor_const_double_double_int_floatX_doubleX(instance: *const c_void, y: f64, x: f64, orientation: i32, descriptor: *mut f32, h: *mut f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_xfeatures2d_DAISY_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_DAISY_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_DAISY_delete(instance: *mut c_void);
		pub fn cv_xfeatures2d_Elliptic_KeyPoint_Elliptic_KeyPoint(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_Elliptic_KeyPoint_Elliptic_KeyPoint_Point2f_float_Size_float_float(pt: *const core::Point2f, angle: f32, axes: *const core::Size, size: f32, si: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_Elliptic_KeyPoint_propAxes_const(instance: *const c_void, ocvrs_return: *mut core::Size_<f32>);
		pub fn cv_xfeatures2d_Elliptic_KeyPoint_propAxes_Size_LfloatG(instance: *mut c_void, val: *const core::Size_<f32>);
		pub fn cv_xfeatures2d_Elliptic_KeyPoint_propSi_const(instance: *const c_void) -> f32;
		pub fn cv_xfeatures2d_Elliptic_KeyPoint_propSi_float(instance: *mut c_void, val: f32);
		pub fn cv_xfeatures2d_Elliptic_KeyPoint_propTransf_const(instance: *const c_void, ocvrs_return: *mut core::Matx23f);
		pub fn cv_xfeatures2d_Elliptic_KeyPoint_propTransf_Matx23f(instance: *mut c_void, val: *const core::Matx23f);
		pub fn cv_xfeatures2d_Elliptic_KeyPoint_to_KeyPoint(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_Elliptic_KeyPoint_delete(instance: *mut c_void);
		pub fn cv_xfeatures2d_FREAK_create_bool_bool_float_int_const_vectorLintGR(orientation_normalized: bool, scale_normalized: bool, pattern_scale: f32, n_octaves: i32, selected_pairs: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_FREAK_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_FREAK_setOrientationNormalized_bool(instance: *mut c_void, orientation_normalized: bool, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_FREAK_getOrientationNormalized_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_xfeatures2d_FREAK_setScaleNormalized_bool(instance: *mut c_void, scale_normalized: bool, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_FREAK_getScaleNormalized_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_xfeatures2d_FREAK_setPatternScale_double(instance: *mut c_void, pattern_scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_FREAK_getPatternScale_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_xfeatures2d_FREAK_setNOctaves_int(instance: *mut c_void, n_octaves: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_FREAK_getNOctaves_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_FREAK_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_FREAK_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_FREAK_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_FREAK_delete(instance: *mut c_void);
		pub fn cv_xfeatures2d_HarrisLaplaceFeatureDetector_create_int_float_float_int_int(num_octaves: i32, corn_thresh: f32, dog_thresh: f32, max_corners: i32, num_layers: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_HarrisLaplaceFeatureDetector_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_HarrisLaplaceFeatureDetector_setNumOctaves_int(instance: *mut c_void, num_octaves_: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_HarrisLaplaceFeatureDetector_getNumOctaves_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_HarrisLaplaceFeatureDetector_setCornThresh_float(instance: *mut c_void, corn_thresh_: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_HarrisLaplaceFeatureDetector_getCornThresh_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_HarrisLaplaceFeatureDetector_setDOGThresh_float(instance: *mut c_void, dog_thresh_: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_HarrisLaplaceFeatureDetector_getDOGThresh_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_HarrisLaplaceFeatureDetector_setMaxCorners_int(instance: *mut c_void, max_corners_: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_HarrisLaplaceFeatureDetector_getMaxCorners_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_HarrisLaplaceFeatureDetector_setNumLayers_int(instance: *mut c_void, num_layers_: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_HarrisLaplaceFeatureDetector_getNumLayers_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_HarrisLaplaceFeatureDetector_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_HarrisLaplaceFeatureDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_HarrisLaplaceFeatureDetector_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_HarrisLaplaceFeatureDetector_delete(instance: *mut c_void);
		pub fn cv_xfeatures2d_LATCH_create_int_bool_int_double(bytes: i32, rotation_invariance: bool, half_ssd_size: i32, sigma: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_LATCH_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_LATCH_setBytes_int(instance: *mut c_void, bytes: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_LATCH_getBytes_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_LATCH_setRotationInvariance_bool(instance: *mut c_void, rotation_invariance: bool, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_LATCH_getRotationInvariance_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_xfeatures2d_LATCH_setHalfSSDsize_int(instance: *mut c_void, half_ssd_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_LATCH_getHalfSSDsize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_LATCH_setSigma_double(instance: *mut c_void, sigma: f64, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_LATCH_getSigma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_xfeatures2d_LATCH_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_LATCH_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_LATCH_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_LATCH_delete(instance: *mut c_void);
		pub fn cv_xfeatures2d_LUCID_create_const_int_const_int(lucid_kernel: i32, blur_kernel: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_LUCID_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_LUCID_setLucidKernel_int(instance: *mut c_void, lucid_kernel: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_LUCID_getLucidKernel_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_LUCID_setBlurKernel_int(instance: *mut c_void, blur_kernel: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_LUCID_getBlurKernel_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_LUCID_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_LUCID_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_LUCID_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_LUCID_delete(instance: *mut c_void);
		pub fn cv_xfeatures2d_MSDDetector_create_int_int_int_int_float_int_float_int_bool(m_patch_radius: i32, m_search_area_radius: i32, m_nms_radius: i32, m_nms_scale_radius: i32, m_th_saliency: f32, m_k_nn: i32, m_scale_factor: f32, m_n_scales: i32, m_compute_orientation: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_MSDDetector_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_MSDDetector_setPatchRadius_int(instance: *mut c_void, patch_radius: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_MSDDetector_getPatchRadius_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_MSDDetector_setSearchAreaRadius_int(instance: *mut c_void, use_orientation: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_MSDDetector_getSearchAreaRadius_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_MSDDetector_setNmsRadius_int(instance: *mut c_void, nms_radius: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_MSDDetector_getNmsRadius_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_MSDDetector_setNmsScaleRadius_int(instance: *mut c_void, nms_scale_radius: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_MSDDetector_getNmsScaleRadius_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_MSDDetector_setThSaliency_float(instance: *mut c_void, th_saliency: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_MSDDetector_getThSaliency_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_MSDDetector_setKNN_int(instance: *mut c_void, k_nn: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_MSDDetector_getKNN_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_MSDDetector_setScaleFactor_float(instance: *mut c_void, scale_factor: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_MSDDetector_getScaleFactor_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_MSDDetector_setNScales_int(instance: *mut c_void, use_orientation: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_MSDDetector_getNScales_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_MSDDetector_setComputeOrientation_bool(instance: *mut c_void, compute_orientation: bool, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_MSDDetector_getComputeOrientation_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_xfeatures2d_MSDDetector_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_MSDDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_MSDDetector_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_MSDDetector_delete(instance: *mut c_void);
		pub fn cv_xfeatures2d_PCTSignatures_create_const_int_const_int_const_int(init_sample_count: i32, init_seed_count: i32, point_distribution: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_PCTSignatures_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_PCTSignatures_create_const_vectorLPoint2fGR_const_int(init_sampling_points: *const c_void, init_seed_count: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_PCTSignatures_create_const_vectorLPoint2fGR_const_vectorLintGR(init_sampling_points: *const c_void, init_cluster_seed_indexes: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_PCTSignatures_computeSignature_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, image: *const c_void, signature: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_computeSignatures_const_const_vectorLMatGR_vectorLMatGR(instance: *const c_void, images: *const c_void, signatures: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_drawSignature_const__InputArrayR_const__InputArrayR_const__OutputArrayR_float_int(source: *const c_void, signature: *const c_void, result: *const c_void, radius_to_shorter_side_ratio: f32, border_thickness: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_drawSignature_const__InputArrayR_const__InputArrayR_const__OutputArrayR(source: *const c_void, signature: *const c_void, result: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_generateInitPoints_vectorLPoint2fGR_const_int_int(init_points: *mut c_void, count: i32, point_distribution: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_getSampleCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_PCTSignatures_getGrayscaleBits_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_PCTSignatures_setGrayscaleBits_int(instance: *mut c_void, grayscale_bits: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_getWindowRadius_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_PCTSignatures_setWindowRadius_int(instance: *mut c_void, radius: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_getWeightX_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_PCTSignatures_setWeightX_float(instance: *mut c_void, weight: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_getWeightY_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_PCTSignatures_setWeightY_float(instance: *mut c_void, weight: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_getWeightL_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_PCTSignatures_setWeightL_float(instance: *mut c_void, weight: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_getWeightA_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_PCTSignatures_setWeightA_float(instance: *mut c_void, weight: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_getWeightB_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_PCTSignatures_setWeightB_float(instance: *mut c_void, weight: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_getWeightContrast_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_PCTSignatures_setWeightContrast_float(instance: *mut c_void, weight: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_getWeightEntropy_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_PCTSignatures_setWeightEntropy_float(instance: *mut c_void, weight: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_getSamplingPoints_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_PCTSignatures_setWeight_int_float(instance: *mut c_void, idx: i32, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_setWeights_const_vectorLfloatGR(instance: *mut c_void, weights: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_setTranslation_int_float(instance: *mut c_void, idx: i32, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_setTranslations_const_vectorLfloatGR(instance: *mut c_void, translations: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_setSamplingPoints_vectorLPoint2fG(instance: *mut c_void, sampling_points: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_getInitSeedIndexes_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_PCTSignatures_setInitSeedIndexes_vectorLintG(instance: *mut c_void, init_seed_indexes: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_getInitSeedCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_PCTSignatures_getIterationCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_PCTSignatures_setIterationCount_int(instance: *mut c_void, iteration_count: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_getMaxClustersCount_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_PCTSignatures_setMaxClustersCount_int(instance: *mut c_void, max_clusters_count: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_getClusterMinSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_PCTSignatures_setClusterMinSize_int(instance: *mut c_void, cluster_min_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_getJoiningDistance_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_PCTSignatures_setJoiningDistance_float(instance: *mut c_void, joining_distance: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_getDropThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_PCTSignatures_setDropThreshold_float(instance: *mut c_void, drop_threshold: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_getDistanceFunction_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_PCTSignatures_setDistanceFunction_int(instance: *mut c_void, distance_function: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignatures_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_PCTSignatures_delete(instance: *mut c_void);
		pub fn cv_xfeatures2d_PCTSignaturesSQFD_create_const_int_const_int_const_float(distance_function: i32, similarity_function: i32, similarity_parameter: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_PCTSignaturesSQFD_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_PCTSignaturesSQFD_computeQuadraticFormDistance_const_const__InputArrayR_const__InputArrayR(instance: *const c_void, _signature0: *const c_void, _signature1: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_PCTSignaturesSQFD_computeQuadraticFormDistances_const_const_MatR_const_vectorLMatGR_vectorLfloatGR(instance: *const c_void, source_signature: *const c_void, image_signatures: *const c_void, distances: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_PCTSignaturesSQFD_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_PCTSignaturesSQFD_delete(instance: *mut c_void);
		pub fn cv_xfeatures2d_SURF_create_double_int_int_bool_bool(hessian_threshold: f64, n_octaves: i32, n_octave_layers: i32, extended: bool, upright: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_SURF_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_SURF_setHessianThreshold_double(instance: *mut c_void, hessian_threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_SURF_getHessianThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_xfeatures2d_SURF_setNOctaves_int(instance: *mut c_void, n_octaves: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_SURF_getNOctaves_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_SURF_setNOctaveLayers_int(instance: *mut c_void, n_octave_layers: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_SURF_getNOctaveLayers_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_SURF_setExtended_bool(instance: *mut c_void, extended: bool, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_SURF_getExtended_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_xfeatures2d_SURF_setUpright_bool(instance: *mut c_void, upright: bool, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_SURF_getUpright_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_xfeatures2d_SURF_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_SURF_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_SURF_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_SURF_delete(instance: *mut c_void);
		pub fn cv_xfeatures2d_StarDetector_create_int_int_int_int_int(max_size: i32, response_threshold: i32, line_threshold_projected: i32, line_threshold_binarized: i32, suppress_nonmax_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_StarDetector_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_StarDetector_setMaxSize_int(instance: *mut c_void, _max_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_StarDetector_getMaxSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_StarDetector_setResponseThreshold_int(instance: *mut c_void, _response_threshold: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_StarDetector_getResponseThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_StarDetector_setLineThresholdProjected_int(instance: *mut c_void, _line_threshold_projected: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_StarDetector_getLineThresholdProjected_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_StarDetector_setLineThresholdBinarized_int(instance: *mut c_void, _line_threshold_binarized: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_StarDetector_getLineThresholdBinarized_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_StarDetector_setSuppressNonmaxSize_int(instance: *mut c_void, _suppress_nonmax_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_StarDetector_getSuppressNonmaxSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_StarDetector_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_StarDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_StarDetector_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_StarDetector_delete(instance: *mut c_void);
		pub fn cv_xfeatures2d_TBMR_create_int_float_float_int(min_area: i32, max_area_relative: f32, scale_factor: f32, n_scales: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_TBMR_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_TBMR_setMinArea_int(instance: *mut c_void, min_area: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_TBMR_getMinArea_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_TBMR_setMaxAreaRelative_float(instance: *mut c_void, max_area: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_TBMR_getMaxAreaRelative_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_TBMR_setScaleFactor_float(instance: *mut c_void, scale_factor: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_TBMR_getScaleFactor_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_TBMR_setNScales_int(instance: *mut c_void, n_scales: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_TBMR_getNScales_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xfeatures2d_TBMR_to_AffineFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_TBMR_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_TBMR_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_TBMR_delete(instance: *mut c_void);
		pub fn cv_xfeatures2d_TEBLID_create_float_int(scale_factor: f32, n_bits: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_TEBLID_create_float(scale_factor: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_TEBLID_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_TEBLID_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_TEBLID_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_TEBLID_delete(instance: *mut c_void);
		pub fn cv_xfeatures2d_VGG_create_int_float_bool_bool_float_bool(desc: i32, isigma: f32, img_normalize: bool, use_scale_orientation: bool, scale_factor: f32, dsc_normalize: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_VGG_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_VGG_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xfeatures2d_VGG_setSigma_const_float(instance: *mut c_void, isigma: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_VGG_getSigma_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_VGG_setUseNormalizeImage_const_bool(instance: *mut c_void, img_normalize: bool, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_VGG_getUseNormalizeImage_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_xfeatures2d_VGG_setUseScaleOrientation_const_bool(instance: *mut c_void, use_scale_orientation: bool, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_VGG_getUseScaleOrientation_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_xfeatures2d_VGG_setScaleFactor_const_float(instance: *mut c_void, scale_factor: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_VGG_getScaleFactor_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xfeatures2d_VGG_setUseNormalizeDescriptor_const_bool(instance: *mut c_void, dsc_normalize: bool, ocvrs_return: *mut Result_void);
		pub fn cv_xfeatures2d_VGG_getUseNormalizeDescriptor_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_xfeatures2d_VGG_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_VGG_to_Feature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xfeatures2d_VGG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xfeatures2d_AffineFeature2DG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_AffineFeature2DG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_AffineFeature2DG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xfeatures2d_AffineFeature2DG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_AffineFeature2DG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_BEBLIDG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_BEBLIDG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_BEBLIDG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xfeatures2d_BEBLIDG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_BEBLIDG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_BoostDescG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_BoostDescG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_BoostDescG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xfeatures2d_BoostDescG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_BoostDescG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_BriefDescriptorExtractorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_BriefDescriptorExtractorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_BriefDescriptorExtractorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xfeatures2d_BriefDescriptorExtractorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_BriefDescriptorExtractorG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_DAISYG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_DAISYG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_DAISYG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xfeatures2d_DAISYG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_DAISYG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_FREAKG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_FREAKG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_FREAKG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xfeatures2d_FREAKG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_FREAKG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_HarrisLaplaceFeatureDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_HarrisLaplaceFeatureDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_HarrisLaplaceFeatureDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xfeatures2d_HarrisLaplaceFeatureDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_HarrisLaplaceFeatureDetectorG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_LATCHG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_LATCHG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_LATCHG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xfeatures2d_LATCHG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_LATCHG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_LUCIDG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_LUCIDG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_LUCIDG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xfeatures2d_LUCIDG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_LUCIDG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_MSDDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_MSDDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_MSDDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xfeatures2d_MSDDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_MSDDetectorG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_PCTSignaturesG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_PCTSignaturesG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_PCTSignaturesG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xfeatures2d_PCTSignaturesG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_PCTSignaturesSQFDG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_PCTSignaturesSQFDG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_PCTSignaturesSQFDG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xfeatures2d_PCTSignaturesSQFDG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_SURFG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_SURFG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_SURFG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xfeatures2d_SURFG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_SURFG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_SURF_CUDAG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_SURF_CUDAG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_cuda_SURF_CUDAG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_cuda_SURF_CUDAG_new_const_SURF_CUDA(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_StarDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_StarDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_StarDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xfeatures2d_StarDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_StarDetectorG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_TBMRG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_TBMRG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_TBMRG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xfeatures2d_TBMRG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_TBMRG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_TBMRG_to_PtrOfAffineFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_TEBLIDG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_TEBLIDG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_TEBLIDG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xfeatures2d_TEBLIDG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_TEBLIDG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_TEBLIDG_new_const_TEBLID(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_VGGG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_VGGG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_VGGG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xfeatures2d_VGGG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xfeatures2d_VGGG_to_PtrOfFeature2D(instance: *mut c_void) -> *mut c_void;
		pub fn std_vectorLcv_xfeatures2d_Elliptic_KeyPointG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_xfeatures2d_Elliptic_KeyPointG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_xfeatures2d_Elliptic_KeyPointG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_xfeatures2d_Elliptic_KeyPointG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_xfeatures2d_Elliptic_KeyPointG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_xfeatures2d_Elliptic_KeyPointG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_xfeatures2d_Elliptic_KeyPointG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_xfeatures2d_Elliptic_KeyPointG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_xfeatures2d_Elliptic_KeyPointG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_xfeatures2d_Elliptic_KeyPointG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_xfeatures2d_Elliptic_KeyPointG_push_const_Elliptic_KeyPoint(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_xfeatures2d_Elliptic_KeyPointG_insert_size_t_const_Elliptic_KeyPoint(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_xfeatures2d_Elliptic_KeyPointG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_xfeatures2d_Elliptic_KeyPointG_set_size_t_const_Elliptic_KeyPoint(instance: *mut c_void, index: size_t, val: *const c_void);
	}
}
#[cfg(ocvrs_has_module_xfeatures2d)]
pub use xfeatures2d_sys::*;

#[cfg(ocvrs_has_module_ximgproc)]
mod ximgproc_sys {
	use super::*;

	extern "C" {
		pub fn cv_ximgproc_BrightEdges_MatR_MatR(_original: *mut c_void, _edgeview: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_BrightEdges_MatR_MatR_int_int_int(_original: *mut c_void, _edgeview: *mut c_void, contrast: i32, shortrange: i32, longrange: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_FastHoughTransform_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, dst_mat_depth: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_FastHoughTransform_const__InputArrayR_const__OutputArrayR_int_int_int_int(src: *const c_void, dst: *const c_void, dst_mat_depth: i32, angle_range: i32, op: i32, make_skew: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_GradientDericheX_const__InputArrayR_const__OutputArrayR_double_double(op: *const c_void, dst: *const c_void, alpha: f64, omega: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_GradientDericheY_const__InputArrayR_const__OutputArrayR_double_double(op: *const c_void, dst: *const c_void, alpha: f64, omega: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_GradientPaillouX_const__InputArrayR_const__OutputArrayR_double_double(op: *const c_void, _dst: *const c_void, alpha: f64, omega: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_GradientPaillouY_const__InputArrayR_const__OutputArrayR_double_double(op: *const c_void, _dst: *const c_void, alpha: f64, omega: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_HoughPoint2Line_const_PointR_const__InputArrayR(hough_point: *const core::Point, src_img_info: *const c_void, ocvrs_return: *mut Result<core::Vec4i>);
		pub fn cv_ximgproc_HoughPoint2Line_const_PointR_const__InputArrayR_int_int_int(hough_point: *const core::Point, src_img_info: *const c_void, angle_range: i32, make_skew: i32, rules: i32, ocvrs_return: *mut Result<core::Vec4i>);
		pub fn cv_ximgproc_PeiLinNormalization_const__InputArrayR(i: *const c_void, ocvrs_return: *mut Result<core::Matx23d>);
		pub fn cv_ximgproc_PeiLinNormalization_const__InputArrayR_const__OutputArrayR(i: *const c_void, t: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RadonTransform_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RadonTransform_const__InputArrayR_const__OutputArrayR_double_double_double_bool_bool(src: *const c_void, dst: *const c_void, theta: f64, start_angle: f64, end_angle: f64, crop: bool, norm: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_amFilter_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_double(joint: *const c_void, src: *const c_void, dst: *const c_void, sigma_s: f64, sigma_r: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_amFilter_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_double_bool(joint: *const c_void, src: *const c_void, dst: *const c_void, sigma_s: f64, sigma_r: f64, adjust_outliers: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_anisotropicDiffusion_const__InputArrayR_const__OutputArrayR_float_float_int(src: *const c_void, dst: *const c_void, alpha: f32, k: f32, niters: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_bilateralTextureFilter_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_bilateralTextureFilter_const__InputArrayR_const__OutputArrayR_int_int_double_double(src: *const c_void, dst: *const c_void, fr: i32, num_iter: i32, sigma_alpha: f64, sigma_avg: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_colorMatchTemplate_const__InputArrayR_const__InputArrayR_const__OutputArrayR(img: *const c_void, templ: *const c_void, result: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_computeBadPixelPercent_const__InputArrayR_const__InputArrayR_Rect(gt: *const c_void, src: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<f64>);
		pub fn cv_ximgproc_computeBadPixelPercent_const__InputArrayR_const__InputArrayR_Rect_int(gt: *const c_void, src: *const c_void, roi: *const core::Rect, thresh: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_ximgproc_computeMSE_const__InputArrayR_const__InputArrayR_Rect(gt: *const c_void, src: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<f64>);
		pub fn cv_ximgproc_contourSampling_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, out: *const c_void, nb_elt: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_covarianceEstimation_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, window_rows: i32, window_cols: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_createAMFilter_double_double(sigma_s: f64, sigma_r: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createAMFilter_double_double_bool(sigma_s: f64, sigma_r: f64, adjust_outliers: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createContourFitting(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createContourFitting_int_int(ctr: i32, fd: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createDTFilter_const__InputArrayR_double_double(guide: *const c_void, sigma_spatial: f64, sigma_color: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createDTFilter_const__InputArrayR_double_double_int_int(guide: *const c_void, sigma_spatial: f64, sigma_color: f64, mode: i32, num_iters: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createDisparityWLSFilterGeneric_bool(use_confidence: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createDisparityWLSFilter_PtrLStereoMatcherG(matcher_left: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createEdgeAwareInterpolator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createEdgeBoxes(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createEdgeBoxes_float_float_float_float_int_float_float_float_float_float_float_float(alpha: f32, beta: f32, eta: f32, min_score: f32, max_boxes: i32, edge_min_mag: f32, edge_merge_thr: f32, cluster_min_mag: f32, max_aspect_ratio: f32, min_box_area: f32, gamma: f32, kappa: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createEdgeDrawing(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createFastBilateralSolverFilter_const__InputArrayR_double_double_double(guide: *const c_void, sigma_spatial: f64, sigma_luma: f64, sigma_chroma: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createFastBilateralSolverFilter_const__InputArrayR_double_double_double_double_int_double(guide: *const c_void, sigma_spatial: f64, sigma_luma: f64, sigma_chroma: f64, lambda: f64, num_iter: i32, max_tol: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createFastGlobalSmootherFilter_const__InputArrayR_double_double(guide: *const c_void, lambda: f64, sigma_color: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createFastGlobalSmootherFilter_const__InputArrayR_double_double_double_int(guide: *const c_void, lambda: f64, sigma_color: f64, lambda_attenuation: f64, num_iter: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createFastLineDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createFastLineDetector_int_float_double_double_int_bool(length_threshold: i32, distance_threshold: f32, canny_th1: f64, canny_th2: f64, canny_aperture_size: i32, do_merge: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createGuidedFilter_const__InputArrayR_int_double(guide: *const c_void, radius: i32, eps: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createQuaternionImage_const__InputArrayR_const__OutputArrayR(img: *const c_void, qimg: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_createRFFeatureGetter(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createRICInterpolator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createRightMatcher_PtrLStereoMatcherG(matcher_left: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createScanSegment_int_int_int(image_width: i32, image_height: i32, num_superpixels: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createScanSegment_int_int_int_int_bool(image_width: i32, image_height: i32, num_superpixels: i32, slices: i32, merge_small: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createStructuredEdgeDetection_const_StringR(model: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createStructuredEdgeDetection_const_StringR_PtrLconst_RFFeatureGetterG(model: *const c_char, how_to_get_features: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createSuperpixelLSC_const__InputArrayR(image: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createSuperpixelLSC_const__InputArrayR_int_float(image: *const c_void, region_size: i32, ratio: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createSuperpixelSEEDS_int_int_int_int_int(image_width: i32, image_height: i32, image_channels: i32, num_superpixels: i32, num_levels: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createSuperpixelSEEDS_int_int_int_int_int_int_int_bool(image_width: i32, image_height: i32, image_channels: i32, num_superpixels: i32, num_levels: i32, prior: i32, histogram_bins: i32, double_step: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createSuperpixelSLIC_const__InputArrayR(image: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_createSuperpixelSLIC_const__InputArrayR_int_int_float(image: *const c_void, algorithm: i32, region_size: i32, ruler: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_dtFilter_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_double(guide: *const c_void, src: *const c_void, dst: *const c_void, sigma_spatial: f64, sigma_color: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_dtFilter_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_double_int_int(guide: *const c_void, src: *const c_void, dst: *const c_void, sigma_spatial: f64, sigma_color: f64, mode: i32, num_iters: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_edgePreservingFilter_const__InputArrayR_const__OutputArrayR_int_double(src: *const c_void, dst: *const c_void, d: i32, threshold: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_fastBilateralSolverFilter_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(guide: *const c_void, src: *const c_void, confidence: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_fastBilateralSolverFilter_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_double_double_double_int_double(guide: *const c_void, src: *const c_void, confidence: *const c_void, dst: *const c_void, sigma_spatial: f64, sigma_luma: f64, sigma_chroma: f64, lambda: f64, num_iter: i32, max_tol: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_fastGlobalSmootherFilter_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_double(guide: *const c_void, src: *const c_void, dst: *const c_void, lambda: f64, sigma_color: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_fastGlobalSmootherFilter_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_double_double_int(guide: *const c_void, src: *const c_void, dst: *const c_void, lambda: f64, sigma_color: f64, lambda_attenuation: f64, num_iter: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_findEllipses_const__InputArrayR_const__OutputArrayR(image: *const c_void, ellipses: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_findEllipses_const__InputArrayR_const__OutputArrayR_float_float_float(image: *const c_void, ellipses: *const c_void, score_threshold: f32, reliability_threshold: f32, center_distance_threshold: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_fourierDescriptor_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_fourierDescriptor_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, nb_elt: i32, nb_fd: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_getDisparityVis_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_getDisparityVis_const__InputArrayR_const__OutputArrayR_double(src: *const c_void, dst: *const c_void, scale: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_guidedFilter_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_double(guide: *const c_void, src: *const c_void, dst: *const c_void, radius: i32, eps: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_guidedFilter_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_double_int(guide: *const c_void, src: *const c_void, dst: *const c_void, radius: i32, eps: f64, d_depth: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_jointBilateralFilter_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_double_double(joint: *const c_void, src: *const c_void, dst: *const c_void, d: i32, sigma_color: f64, sigma_space: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_jointBilateralFilter_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_double_double_int(joint: *const c_void, src: *const c_void, dst: *const c_void, d: i32, sigma_color: f64, sigma_space: f64, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_l0Smooth_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_l0Smooth_const__InputArrayR_const__OutputArrayR_double_double(src: *const c_void, dst: *const c_void, lambda: f64, kappa: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_niBlackThreshold_const__InputArrayR_const__OutputArrayR_double_int_int_double(_src: *const c_void, _dst: *const c_void, max_value: f64, typ: i32, block_size: i32, k: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_niBlackThreshold_const__InputArrayR_const__OutputArrayR_double_int_int_double_int_double(_src: *const c_void, _dst: *const c_void, max_value: f64, typ: i32, block_size: i32, k: f64, binarization_method: i32, r: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_qconj_const__InputArrayR_const__OutputArrayR(qimg: *const c_void, qcimg: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_qdft_const__InputArrayR_const__OutputArrayR_int_bool(img: *const c_void, qimg: *const c_void, flags: i32, side_left: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_qmultiply_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_qunitary_const__InputArrayR_const__OutputArrayR(qimg: *const c_void, qnimg: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_readGT_String_const__OutputArrayR(src_path: *mut c_char, dst: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_rl_createRLEImage_const_vectorLPoint3iGR_const__OutputArrayR(runs: *const c_void, res: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_rl_createRLEImage_const_vectorLPoint3iGR_const__OutputArrayR_Size(runs: *const c_void, res: *const c_void, size: *const core::Size, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_rl_dilate_const__InputArrayR_const__OutputArrayR_const__InputArrayR(rl_src: *const c_void, rl_dest: *const c_void, rl_kernel: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_rl_dilate_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Point(rl_src: *const c_void, rl_dest: *const c_void, rl_kernel: *const c_void, anchor: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_rl_erode_const__InputArrayR_const__OutputArrayR_const__InputArrayR(rl_src: *const c_void, rl_dest: *const c_void, rl_kernel: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_rl_erode_const__InputArrayR_const__OutputArrayR_const__InputArrayR_bool_Point(rl_src: *const c_void, rl_dest: *const c_void, rl_kernel: *const c_void, b_boundary_on: bool, anchor: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_rl_getStructuringElement_int_Size(shape: i32, ksize: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_rl_isRLMorphologyPossible_const__InputArrayR(rl_structuring_element: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ximgproc_rl_morphologyEx_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR(rl_src: *const c_void, rl_dest: *const c_void, op: i32, rl_kernel: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_rl_morphologyEx_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR_bool_Point(rl_src: *const c_void, rl_dest: *const c_void, op: i32, rl_kernel: *const c_void, b_boundary_on_for_erosion: bool, anchor: *const core::Point, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_rl_paint_const__InputOutputArrayR_const__InputArrayR_const_ScalarR(image: *const c_void, rl_src: *const c_void, value: *const core::Scalar, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_rl_threshold_const__InputArrayR_const__OutputArrayR_double_int(src: *const c_void, rl_dest: *const c_void, thresh: f64, typ: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_rollingGuidanceFilter_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_rollingGuidanceFilter_const__InputArrayR_const__OutputArrayR_int_double_double_int_int(src: *const c_void, dst: *const c_void, d: i32, sigma_color: f64, sigma_space: f64, num_of_iter: i32, border_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_createGraphSegmentation(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_segmentation_createGraphSegmentation_double_float_int(sigma: f64, k: f32, min_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_segmentation_createSelectiveSearchSegmentation(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategyColor(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategyFill(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple_PtrLSelectiveSearchSegmentationStrategyG(s1: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple_PtrLSelectiveSearchSegmentationStrategyG_PtrLSelectiveSearchSegmentationStrategyG(s1: *mut c_void, s2: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple_PtrLSelectiveSearchSegmentationStrategyG_PtrLSelectiveSearchSegmentationStrategyG_PtrLSelectiveSearchSegmentationStrategyG(s1: *mut c_void, s2: *mut c_void, s3: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple_PtrLSelectiveSearchSegmentationStrategyG_PtrLSelectiveSearchSegmentationStrategyG_PtrLSelectiveSearchSegmentationStrategyG_PtrLSelectiveSearchSegmentationStrategyG(s1: *mut c_void, s2: *mut c_void, s3: *mut c_void, s4: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategySize(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategyTexture(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_thinning_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_thinning_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, thinning_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_transformFD_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src: *const c_void, t: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_transformFD_const__InputArrayR_const__InputArrayR_const__OutputArrayR_bool(src: *const c_void, t: *const c_void, dst: *const c_void, fd_contour: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_weightedMedianFilter_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(joint: *const c_void, src: *const c_void, dst: *const c_void, r: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_weightedMedianFilter_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_double_int_const__InputArrayR(joint: *const c_void, src: *const c_void, dst: *const c_void, r: i32, sigma: f64, weight_type: i32, mask: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_AdaptiveManifoldFilter_filter_const__InputArrayR_const__OutputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, joint: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_AdaptiveManifoldFilter_filter_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_AdaptiveManifoldFilter_collectGarbage(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_AdaptiveManifoldFilter_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_AdaptiveManifoldFilter_getSigmaS_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ximgproc_AdaptiveManifoldFilter_setSigmaS_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_AdaptiveManifoldFilter_getSigmaR_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ximgproc_AdaptiveManifoldFilter_setSigmaR_double(instance: *mut c_void, val: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_AdaptiveManifoldFilter_getTreeHeight_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_AdaptiveManifoldFilter_setTreeHeight_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_AdaptiveManifoldFilter_getPCAIterations_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_AdaptiveManifoldFilter_setPCAIterations_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_AdaptiveManifoldFilter_getAdjustOutliers_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ximgproc_AdaptiveManifoldFilter_setAdjustOutliers_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_AdaptiveManifoldFilter_getUseRNG_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ximgproc_AdaptiveManifoldFilter_setUseRNG_bool(instance: *mut c_void, val: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_AdaptiveManifoldFilter_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_AdaptiveManifoldFilter_delete(instance: *mut c_void);
		pub fn cv_ximgproc_ContourFitting_ContourFitting_int_int(ctr: i32, fd: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_ContourFitting_ContourFitting(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_ContourFitting_estimateTransformation_const__InputArrayR_const__InputArrayR_const__OutputArrayR_doubleX_bool(instance: *mut c_void, src: *const c_void, dst: *const c_void, alpha_phi_st: *const c_void, dist: *mut f64, fd_contour: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_ContourFitting_estimateTransformation_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, alpha_phi_st: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_ContourFitting_estimateTransformation_const__InputArrayR_const__InputArrayR_const__OutputArrayR_doubleR_bool(instance: *mut c_void, src: *const c_void, dst: *const c_void, alpha_phi_st: *const c_void, dist: *mut f64, fd_contour: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_ContourFitting_estimateTransformation_const__InputArrayR_const__InputArrayR_const__OutputArrayR_doubleR(instance: *mut c_void, src: *const c_void, dst: *const c_void, alpha_phi_st: *const c_void, dist: *mut f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_ContourFitting_setCtrSize_int(instance: *mut c_void, n: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_ContourFitting_setFDSize_int(instance: *mut c_void, n: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_ContourFitting_getCtrSize(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_ContourFitting_getFDSize(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_ContourFitting_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_ContourFitting_delete(instance: *mut c_void);
		pub fn cv_ximgproc_DTFilter_filter_const__InputArrayR_const__OutputArrayR_int(instance: *mut c_void, src: *const c_void, dst: *const c_void, d_depth: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_DTFilter_filter_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_DTFilter_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_DTFilter_delete(instance: *mut c_void);
		pub fn cv_ximgproc_DisparityFilter_filter_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Rect_const__InputArrayR(instance: *mut c_void, disparity_map_left: *const c_void, left_view: *const c_void, filtered_disparity_map: *const c_void, disparity_map_right: *const c_void, roi: *const core::Rect, right_view: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_DisparityFilter_filter_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, disparity_map_left: *const c_void, left_view: *const c_void, filtered_disparity_map: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_DisparityFilter_to_DisparityWLSFilter(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_DisparityFilter_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_DisparityFilter_delete(instance: *mut c_void);
		pub fn cv_ximgproc_DisparityWLSFilter_getLambda(instance: *mut c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ximgproc_DisparityWLSFilter_setLambda_double(instance: *mut c_void, _lambda: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_DisparityWLSFilter_getSigmaColor(instance: *mut c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ximgproc_DisparityWLSFilter_setSigmaColor_double(instance: *mut c_void, _sigma_color: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_DisparityWLSFilter_getLRCthresh(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_DisparityWLSFilter_setLRCthresh_int(instance: *mut c_void, _lrc_thresh: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_DisparityWLSFilter_getDepthDiscontinuityRadius(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_DisparityWLSFilter_setDepthDiscontinuityRadius_int(instance: *mut c_void, _disc_radius: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_DisparityWLSFilter_getConfidenceMap(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_DisparityWLSFilter_getROI(instance: *mut c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_ximgproc_DisparityWLSFilter_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_DisparityWLSFilter_to_DisparityFilter(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_DisparityWLSFilter_delete(instance: *mut c_void);
		pub fn cv_ximgproc_EdgeAwareInterpolator_setCostMap_const_MatR(instance: *mut c_void, _cost_map: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeAwareInterpolator_setK_int(instance: *mut c_void, _k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeAwareInterpolator_getK(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_EdgeAwareInterpolator_setSigma_float(instance: *mut c_void, _sigma: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeAwareInterpolator_getSigma(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_EdgeAwareInterpolator_setLambda_float(instance: *mut c_void, _lambda: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeAwareInterpolator_getLambda(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_EdgeAwareInterpolator_setUsePostProcessing_bool(instance: *mut c_void, _use_post_proc: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeAwareInterpolator_getUsePostProcessing(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ximgproc_EdgeAwareInterpolator_setFGSLambda_float(instance: *mut c_void, _lambda: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeAwareInterpolator_getFGSLambda(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_EdgeAwareInterpolator_setFGSSigma_float(instance: *mut c_void, _sigma: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeAwareInterpolator_getFGSSigma(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_EdgeAwareInterpolator_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_EdgeAwareInterpolator_to_SparseMatchInterpolator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_EdgeAwareInterpolator_delete(instance: *mut c_void);
		pub fn cv_ximgproc_EdgeBoxes_getBoundingBoxes_const__InputArrayR_const__InputArrayR_vectorLRectGR_const__OutputArrayR(instance: *mut c_void, edge_map: *const c_void, orientation_map: *const c_void, boxes: *mut c_void, scores: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeBoxes_getBoundingBoxes_const__InputArrayR_const__InputArrayR_vectorLRectGR(instance: *mut c_void, edge_map: *const c_void, orientation_map: *const c_void, boxes: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeBoxes_getAlpha_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_EdgeBoxes_setAlpha_float(instance: *mut c_void, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeBoxes_getBeta_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_EdgeBoxes_setBeta_float(instance: *mut c_void, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeBoxes_getEta_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_EdgeBoxes_setEta_float(instance: *mut c_void, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeBoxes_getMinScore_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_EdgeBoxes_setMinScore_float(instance: *mut c_void, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeBoxes_getMaxBoxes_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_EdgeBoxes_setMaxBoxes_int(instance: *mut c_void, value: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeBoxes_getEdgeMinMag_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_EdgeBoxes_setEdgeMinMag_float(instance: *mut c_void, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeBoxes_getEdgeMergeThr_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_EdgeBoxes_setEdgeMergeThr_float(instance: *mut c_void, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeBoxes_getClusterMinMag_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_EdgeBoxes_setClusterMinMag_float(instance: *mut c_void, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeBoxes_getMaxAspectRatio_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_EdgeBoxes_setMaxAspectRatio_float(instance: *mut c_void, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeBoxes_getMinBoxArea_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_EdgeBoxes_setMinBoxArea_float(instance: *mut c_void, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeBoxes_getGamma_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_EdgeBoxes_setGamma_float(instance: *mut c_void, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeBoxes_getKappa_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_EdgeBoxes_setKappa_float(instance: *mut c_void, value: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeBoxes_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_EdgeBoxes_delete(instance: *mut c_void);
		pub fn cv_ximgproc_EdgeDrawing_detectEdges_const__InputArrayR(instance: *mut c_void, src: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeDrawing_getEdgeImage_const__OutputArrayR(instance: *mut c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeDrawing_getGradientImage_const__OutputArrayR(instance: *mut c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeDrawing_getSegments(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_EdgeDrawing_getSegmentIndicesOfLines_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_EdgeDrawing_detectLines_const__OutputArrayR(instance: *mut c_void, lines: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeDrawing_detectEllipses_const__OutputArrayR(instance: *mut c_void, ellipses: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeDrawing_setParams_const_ParamsR(instance: *mut c_void, parameters: *const crate::ximgproc::EdgeDrawing_Params, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeDrawing_propParams_const(instance: *const c_void, ocvrs_return: *mut crate::ximgproc::EdgeDrawing_Params);
		pub fn cv_ximgproc_EdgeDrawing_propParams_Params(instance: *mut c_void, val: *const crate::ximgproc::EdgeDrawing_Params);
		pub fn cv_ximgproc_EdgeDrawing_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_EdgeDrawing_delete(instance: *mut c_void);
		pub fn cv_ximgproc_EdgeDrawing_Params_Params(ocvrs_return: *mut Result<crate::ximgproc::EdgeDrawing_Params>);
		pub fn cv_ximgproc_EdgeDrawing_Params_read_const_FileNodeR(instance: *const crate::ximgproc::EdgeDrawing_Params, fn_: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_EdgeDrawing_Params_write_const_FileStorageR(instance: *const crate::ximgproc::EdgeDrawing_Params, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_FastBilateralSolverFilter_filter_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, confidence: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_FastBilateralSolverFilter_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_FastBilateralSolverFilter_delete(instance: *mut c_void);
		pub fn cv_ximgproc_FastGlobalSmootherFilter_filter_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_FastGlobalSmootherFilter_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_FastGlobalSmootherFilter_delete(instance: *mut c_void);
		pub fn cv_ximgproc_FastLineDetector_detect_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, lines: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_FastLineDetector_drawSegments_const__InputOutputArrayR_const__InputArrayR_bool_Scalar_int(instance: *mut c_void, image: *const c_void, lines: *const c_void, draw_arrow: bool, linecolor: *const core::Scalar, linethickness: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_FastLineDetector_drawSegments_const__InputOutputArrayR_const__InputArrayR(instance: *mut c_void, image: *const c_void, lines: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_FastLineDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_FastLineDetector_delete(instance: *mut c_void);
		pub fn cv_ximgproc_GuidedFilter_filter_const__InputArrayR_const__OutputArrayR_int(instance: *mut c_void, src: *const c_void, dst: *const c_void, d_depth: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_GuidedFilter_filter_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_GuidedFilter_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_GuidedFilter_delete(instance: *mut c_void);
		pub fn cv_ximgproc_RFFeatureGetter_getFeatures_const_const_MatR_MatR_const_int_const_int_const_int_const_int_const_int(instance: *const c_void, src: *const c_void, features: *mut c_void, gnrm_rad: i32, gsmth_rad: i32, shrink: i32, out_num: i32, grad_num: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RFFeatureGetter_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_RFFeatureGetter_delete(instance: *mut c_void);
		pub fn cv_ximgproc_RICInterpolator_setK_int(instance: *mut c_void, k: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_setK(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_getK_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_RICInterpolator_setCostMap_const_MatR(instance: *mut c_void, cost_map: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_setSuperpixelSize_int(instance: *mut c_void, sp_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_setSuperpixelSize(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_getSuperpixelSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_RICInterpolator_setSuperpixelNNCnt_int(instance: *mut c_void, sp_nn: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_setSuperpixelNNCnt(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_getSuperpixelNNCnt_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_RICInterpolator_setSuperpixelRuler_float(instance: *mut c_void, ruler: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_setSuperpixelRuler(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_getSuperpixelRuler_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_RICInterpolator_setSuperpixelMode_int(instance: *mut c_void, mode: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_setSuperpixelMode(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_getSuperpixelMode_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_RICInterpolator_setAlpha_float(instance: *mut c_void, alpha: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_setAlpha(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_getAlpha_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_RICInterpolator_setModelIter_int(instance: *mut c_void, model_iter: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_setModelIter(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_getModelIter_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_RICInterpolator_setRefineModels_bool(instance: *mut c_void, refine_modles: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_setRefineModels(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_getRefineModels_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ximgproc_RICInterpolator_setMaxFlow_float(instance: *mut c_void, max_flow: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_setMaxFlow(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_getMaxFlow_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_RICInterpolator_setUseVariationalRefinement_bool(instance: *mut c_void, use_variational_refinement: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_setUseVariationalRefinement(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_getUseVariationalRefinement_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ximgproc_RICInterpolator_setUseGlobalSmootherFilter_bool(instance: *mut c_void, use_fgs: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_setUseGlobalSmootherFilter(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_getUseGlobalSmootherFilter_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ximgproc_RICInterpolator_setFGSLambda_float(instance: *mut c_void, lambda: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_setFGSLambda(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_getFGSLambda_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_RICInterpolator_setFGSSigma_float(instance: *mut c_void, sigma: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_setFGSSigma(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RICInterpolator_getFGSSigma_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_RICInterpolator_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_RICInterpolator_to_SparseMatchInterpolator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_RICInterpolator_delete(instance: *mut c_void);
		pub fn cv_ximgproc_RidgeDetectionFilter_create_int_int_int_int_int_double_double_int(ddepth: i32, dx: i32, dy: i32, ksize: i32, out_dtype: i32, scale: f64, delta: f64, border_type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_RidgeDetectionFilter_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ximgproc_RidgeDetectionFilter_getRidgeFilteredImage_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, _img: *const c_void, out: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_RidgeDetectionFilter_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_RidgeDetectionFilter_delete(instance: *mut c_void);
		pub fn cv_ximgproc_ScanSegment_getNumberOfSuperpixels(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_ScanSegment_iterate_const__InputArrayR(instance: *mut c_void, img: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_ScanSegment_getLabels_const__OutputArrayR(instance: *mut c_void, labels_out: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_ScanSegment_getLabelContourMask_const__OutputArrayR_bool(instance: *mut c_void, image: *const c_void, thick_line: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_ScanSegment_getLabelContourMask_const__OutputArrayR(instance: *mut c_void, image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_ScanSegment_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_ScanSegment_delete(instance: *mut c_void);
		pub fn cv_ximgproc_SparseMatchInterpolator_interpolate_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, from_image: *const c_void, from_points: *const c_void, to_image: *const c_void, to_points: *const c_void, dense_flow: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SparseMatchInterpolator_to_EdgeAwareInterpolator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_SparseMatchInterpolator_to_RICInterpolator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_SparseMatchInterpolator_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_SparseMatchInterpolator_delete(instance: *mut c_void);
		pub fn cv_ximgproc_StructuredEdgeDetection_detectEdges_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_StructuredEdgeDetection_computeOrientation_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_StructuredEdgeDetection_edgesNms_const_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_int_float_bool(instance: *const c_void, edge_image: *const c_void, orientation_image: *const c_void, dst: *const c_void, r: i32, s: i32, m: f32, is_parallel: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_StructuredEdgeDetection_edgesNms_const_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *const c_void, edge_image: *const c_void, orientation_image: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_StructuredEdgeDetection_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_StructuredEdgeDetection_delete(instance: *mut c_void);
		pub fn cv_ximgproc_SuperpixelLSC_getNumberOfSuperpixels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_SuperpixelLSC_iterate_int(instance: *mut c_void, num_iterations: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelLSC_iterate(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelLSC_getLabels_const_const__OutputArrayR(instance: *const c_void, labels_out: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelLSC_getLabelContourMask_const_const__OutputArrayR_bool(instance: *const c_void, image: *const c_void, thick_line: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelLSC_getLabelContourMask_const_const__OutputArrayR(instance: *const c_void, image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelLSC_enforceLabelConnectivity_int(instance: *mut c_void, min_element_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelLSC_enforceLabelConnectivity(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelLSC_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_SuperpixelLSC_delete(instance: *mut c_void);
		pub fn cv_ximgproc_SuperpixelSEEDS_getNumberOfSuperpixels(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_SuperpixelSEEDS_iterate_const__InputArrayR_int(instance: *mut c_void, img: *const c_void, num_iterations: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelSEEDS_iterate_const__InputArrayR(instance: *mut c_void, img: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelSEEDS_getLabels_const__OutputArrayR(instance: *mut c_void, labels_out: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelSEEDS_getLabelContourMask_const__OutputArrayR_bool(instance: *mut c_void, image: *const c_void, thick_line: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelSEEDS_getLabelContourMask_const__OutputArrayR(instance: *mut c_void, image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelSEEDS_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_SuperpixelSEEDS_delete(instance: *mut c_void);
		pub fn cv_ximgproc_SuperpixelSLIC_getNumberOfSuperpixels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_SuperpixelSLIC_iterate_int(instance: *mut c_void, num_iterations: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelSLIC_iterate(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelSLIC_getLabels_const_const__OutputArrayR(instance: *const c_void, labels_out: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelSLIC_getLabelContourMask_const_const__OutputArrayR_bool(instance: *const c_void, image: *const c_void, thick_line: bool, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelSLIC_getLabelContourMask_const_const__OutputArrayR(instance: *const c_void, image: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelSLIC_enforceLabelConnectivity_int(instance: *mut c_void, min_element_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelSLIC_enforceLabelConnectivity(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_SuperpixelSLIC_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_SuperpixelSLIC_delete(instance: *mut c_void);
		pub fn cv_ximgproc_segmentation_GraphSegmentation_processImage_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_GraphSegmentation_setSigma_double(instance: *mut c_void, sigma: f64, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_GraphSegmentation_getSigma(instance: *mut c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_ximgproc_segmentation_GraphSegmentation_setK_float(instance: *mut c_void, k: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_GraphSegmentation_getK(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_segmentation_GraphSegmentation_setMinSize_int(instance: *mut c_void, min_size: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_GraphSegmentation_getMinSize(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ximgproc_segmentation_GraphSegmentation_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_segmentation_GraphSegmentation_delete(instance: *mut c_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentation_setBaseImage_const__InputArrayR(instance: *mut c_void, img: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentation_switchToSingleStrategy_int_float(instance: *mut c_void, k: i32, sigma: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentation_switchToSingleStrategy(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentation_switchToSelectiveSearchFast_int_int_float(instance: *mut c_void, base_k: i32, inc_k: i32, sigma: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentation_switchToSelectiveSearchFast(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentation_switchToSelectiveSearchQuality_int_int_float(instance: *mut c_void, base_k: i32, inc_k: i32, sigma: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentation_switchToSelectiveSearchQuality(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentation_addImage_const__InputArrayR(instance: *mut c_void, img: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentation_clearImages(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentation_addGraphSegmentation_PtrLGraphSegmentationG(instance: *mut c_void, g: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentation_clearGraphSegmentations(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentation_addStrategy_PtrLSelectiveSearchSegmentationStrategyG(instance: *mut c_void, s: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentation_clearStrategies(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentation_process_vectorLRectGR(instance: *mut c_void, rects: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentation_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentation_delete(instance: *mut c_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_setImage_const__InputArrayR_const__InputArrayR_const__InputArrayR_int(instance: *mut c_void, img: *const c_void, regions: *const c_void, sizes: *const c_void, image_id: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_setImage_const__InputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, img: *const c_void, regions: *const c_void, sizes: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_get_int_int(instance: *mut c_void, r1: i32, r2: i32, ocvrs_return: *mut Result<f32>);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_merge_int_int(instance: *mut c_void, r1: i32, r2: i32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_to_SelectiveSearchSegmentationStrategyColor(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_to_SelectiveSearchSegmentationStrategyFill(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_to_SelectiveSearchSegmentationStrategyMultiple(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_to_SelectiveSearchSegmentationStrategySize(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_to_SelectiveSearchSegmentationStrategyTexture(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategy_delete(instance: *mut c_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyColor_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyColor_to_SelectiveSearchSegmentationStrategy(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyColor_delete(instance: *mut c_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyFill_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyFill_to_SelectiveSearchSegmentationStrategy(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyFill_delete(instance: *mut c_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_addStrategy_PtrLSelectiveSearchSegmentationStrategyG_float(instance: *mut c_void, g: *mut c_void, weight: f32, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_clearStrategies(instance: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_to_SelectiveSearchSegmentationStrategy(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultiple_delete(instance: *mut c_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategySize_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategySize_to_SelectiveSearchSegmentationStrategy(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategySize_delete(instance: *mut c_void);
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyTexture_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyTexture_to_SelectiveSearchSegmentationStrategy(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyTexture_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_AdaptiveManifoldFilterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_AdaptiveManifoldFilterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_AdaptiveManifoldFilterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_AdaptiveManifoldFilterG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_ContourFittingG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_ContourFittingG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_ContourFittingG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_ContourFittingG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_ContourFittingG_new_const_ContourFitting(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_DTFilterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_DTFilterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_DTFilterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_DTFilterG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_DisparityFilterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_DisparityFilterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_DisparityFilterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_DisparityFilterG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_DisparityWLSFilterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_DisparityWLSFilterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_DisparityWLSFilterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_DisparityWLSFilterG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_DisparityWLSFilterG_to_PtrOfDisparityFilter(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_EdgeAwareInterpolatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_EdgeAwareInterpolatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_EdgeAwareInterpolatorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_EdgeAwareInterpolatorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_EdgeAwareInterpolatorG_to_PtrOfSparseMatchInterpolator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_EdgeBoxesG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_EdgeBoxesG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_EdgeBoxesG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_EdgeBoxesG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_EdgeDrawingG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_EdgeDrawingG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_EdgeDrawingG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_EdgeDrawingG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_FastBilateralSolverFilterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_FastBilateralSolverFilterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_FastBilateralSolverFilterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_FastBilateralSolverFilterG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_FastGlobalSmootherFilterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_FastGlobalSmootherFilterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_FastGlobalSmootherFilterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_FastGlobalSmootherFilterG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_FastLineDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_FastLineDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_FastLineDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_FastLineDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_GraphSegmentationG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_GraphSegmentationG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_GraphSegmentationG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_segmentation_GraphSegmentationG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_GuidedFilterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_GuidedFilterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_GuidedFilterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_GuidedFilterG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_RFFeatureGetterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_RFFeatureGetterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_RFFeatureGetterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_RFFeatureGetterG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_RICInterpolatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_RICInterpolatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_RICInterpolatorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_RICInterpolatorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_RICInterpolatorG_to_PtrOfSparseMatchInterpolator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_RidgeDetectionFilterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_RidgeDetectionFilterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_RidgeDetectionFilterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_RidgeDetectionFilterG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_ScanSegmentG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_ScanSegmentG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_ScanSegmentG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_ScanSegmentG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyColorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyColorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyColorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyColorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyColorG_to_PtrOfSelectiveSearchSegmentationStrategy(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyFillG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyFillG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyFillG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyFillG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyFillG_to_PtrOfSelectiveSearchSegmentationStrategy(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultipleG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultipleG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultipleG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultipleG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyMultipleG_to_PtrOfSelectiveSearchSegmentationStrategy(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategySizeG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategySizeG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategySizeG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategySizeG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategySizeG_to_PtrOfSelectiveSearchSegmentationStrategy(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyTextureG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyTextureG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyTextureG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyTextureG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_segmentation_SelectiveSearchSegmentationStrategyTextureG_to_PtrOfSelectiveSearchSegmentationStrategy(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_SparseMatchInterpolatorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_SparseMatchInterpolatorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_SparseMatchInterpolatorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_SparseMatchInterpolatorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_StructuredEdgeDetectionG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_StructuredEdgeDetectionG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_StructuredEdgeDetectionG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_StructuredEdgeDetectionG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_SuperpixelLSCG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_SuperpixelLSCG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_SuperpixelLSCG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_SuperpixelLSCG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_SuperpixelSEEDSG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_SuperpixelSEEDSG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_SuperpixelSEEDSG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_SuperpixelSEEDSG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_SuperpixelSLICG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_SuperpixelSLICG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ximgproc_SuperpixelSLICG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ximgproc_SuperpixelSLICG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn std_vectorLcv_ximgproc_BoxG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_ximgproc_BoxG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_ximgproc_BoxG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_ximgproc_BoxG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_ximgproc_BoxG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_ximgproc_BoxG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_ximgproc_BoxG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_ximgproc_BoxG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_ximgproc_BoxG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_ximgproc_BoxG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_ximgproc_BoxG_push_const_Box(instance: *mut c_void, val: *const crate::ximgproc::Box);
		pub fn std_vectorLcv_ximgproc_BoxG_insert_size_t_const_Box(instance: *mut c_void, index: size_t, val: *const crate::ximgproc::Box);
		pub fn std_vectorLcv_ximgproc_BoxG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut crate::ximgproc::Box);
		pub fn std_vectorLcv_ximgproc_BoxG_set_size_t_const_Box(instance: *mut c_void, index: size_t, val: *const crate::ximgproc::Box);
		pub fn std_vectorLcv_ximgproc_BoxG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_ximgproc_BoxG_data_const(instance: *const c_void) -> *const crate::ximgproc::Box;
		pub fn std_vectorLcv_ximgproc_BoxG_dataMut(instance: *mut c_void) -> *mut crate::ximgproc::Box;
		pub fn cv_fromSlice_const_const_BoxX_size_t(data: *const crate::ximgproc::Box, len: size_t) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_ximgproc)]
pub use ximgproc_sys::*;

#[cfg(ocvrs_has_module_xobjdetect)]
mod xobjdetect_sys {
	use super::*;

	extern "C" {
		pub fn cv_xobjdetect_WBDetector_read_const_FileNodeR(instance: *mut c_void, node: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xobjdetect_WBDetector_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xobjdetect_WBDetector_train_const_stringR_const_stringR(instance: *mut c_void, pos_samples: *const c_char, neg_imgs: *const c_char, ocvrs_return: *mut Result_void);
		pub fn cv_xobjdetect_WBDetector_detect_const_MatR_vectorLRectGR_vectorLdoubleGR(instance: *mut c_void, img: *const c_void, bboxes: *mut c_void, confidences: *mut c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xobjdetect_WBDetector_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xobjdetect_WBDetector_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xobjdetect_WBDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xobjdetect_WBDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xobjdetect_WBDetectorG_delete(instance: *mut c_void);
	}
}
#[cfg(ocvrs_has_module_xobjdetect)]
pub use xobjdetect_sys::*;

#[cfg(ocvrs_has_module_xphoto)]
mod xphoto_sys {
	use super::*;

	extern "C" {
		pub fn cv_xphoto_applyChannelGains_const__InputArrayR_const__OutputArrayR_float_float_float(src: *const c_void, dst: *const c_void, gain_b: f32, gain_g: f32, gain_r: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_bm3dDenoising_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR(src: *const c_void, dst_step1: *const c_void, dst_step2: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_bm3dDenoising_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_float_int_int_int_int_int_int_float_int_int_int(src: *const c_void, dst_step1: *const c_void, dst_step2: *const c_void, h: f32, template_window_size: i32, search_window_size: i32, block_matching_step1: i32, block_matching_step2: i32, group_size: i32, sliding_step: i32, beta: f32, norm_type: i32, step: i32, transform_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_bm3dDenoising_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_bm3dDenoising_const__InputArrayR_const__OutputArrayR_float_int_int_int_int_int_int_float_int_int_int(src: *const c_void, dst: *const c_void, h: f32, template_window_size: i32, search_window_size: i32, block_matching_step1: i32, block_matching_step2: i32, group_size: i32, sliding_step: i32, beta: f32, norm_type: i32, step: i32, transform_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_createGrayworldWB(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xphoto_createLearningBasedWB(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xphoto_createLearningBasedWB_const_StringR(path_to_model: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xphoto_createSimpleWB(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xphoto_createTonemapDurand(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xphoto_createTonemapDurand_float_float_float_float_float(gamma: f32, contrast: f32, saturation: f32, sigma_color: f32, sigma_space: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_xphoto_dctDenoising_const_MatR_MatR_const_double(src: *const c_void, dst: *mut c_void, sigma: f64, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_dctDenoising_const_MatR_MatR_const_double_const_int(src: *const c_void, dst: *mut c_void, sigma: f64, psize: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_inpaint_const_MatR_const_MatR_MatR_const_int(src: *const c_void, mask: *const c_void, dst: *mut c_void, algorithm_type: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_oilPainting_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, size: i32, dyn_ratio: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_oilPainting_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, size: i32, dyn_ratio: i32, code: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_GrayworldWB_getSaturationThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xphoto_GrayworldWB_setSaturationThreshold_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_GrayworldWB_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xphoto_GrayworldWB_to_WhiteBalancer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xphoto_GrayworldWB_delete(instance: *mut c_void);
		pub fn cv_xphoto_LearningBasedWB_extractSimpleFeatures_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_LearningBasedWB_getRangeMaxVal_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xphoto_LearningBasedWB_setRangeMaxVal_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_LearningBasedWB_getSaturationThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xphoto_LearningBasedWB_setSaturationThreshold_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_LearningBasedWB_getHistBinNum_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_xphoto_LearningBasedWB_setHistBinNum_int(instance: *mut c_void, val: i32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_LearningBasedWB_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xphoto_LearningBasedWB_to_WhiteBalancer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xphoto_LearningBasedWB_delete(instance: *mut c_void);
		pub fn cv_xphoto_SimpleWB_getInputMin_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xphoto_SimpleWB_setInputMin_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_SimpleWB_getInputMax_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xphoto_SimpleWB_setInputMax_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_SimpleWB_getOutputMin_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xphoto_SimpleWB_setOutputMin_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_SimpleWB_getOutputMax_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xphoto_SimpleWB_setOutputMax_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_SimpleWB_getP_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xphoto_SimpleWB_setP_float(instance: *mut c_void, val: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_SimpleWB_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xphoto_SimpleWB_to_WhiteBalancer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xphoto_SimpleWB_delete(instance: *mut c_void);
		pub fn cv_xphoto_TonemapDurand_getSaturation_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xphoto_TonemapDurand_setSaturation_float(instance: *mut c_void, saturation: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_TonemapDurand_getContrast_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xphoto_TonemapDurand_setContrast_float(instance: *mut c_void, contrast: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_TonemapDurand_getSigmaSpace_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xphoto_TonemapDurand_setSigmaSpace_float(instance: *mut c_void, sigma_space: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_TonemapDurand_getSigmaColor_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_xphoto_TonemapDurand_setSigmaColor_float(instance: *mut c_void, sigma_color: f32, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_TonemapDurand_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xphoto_TonemapDurand_to_Tonemap(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xphoto_TonemapDurand_delete(instance: *mut c_void);
		pub fn cv_xphoto_WhiteBalancer_balanceWhite_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result_void);
		pub fn cv_xphoto_WhiteBalancer_to_GrayworldWB(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xphoto_WhiteBalancer_to_LearningBasedWB(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xphoto_WhiteBalancer_to_SimpleWB(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xphoto_WhiteBalancer_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_xphoto_WhiteBalancer_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xphoto_GrayworldWBG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xphoto_GrayworldWBG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xphoto_GrayworldWBG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xphoto_GrayworldWBG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xphoto_GrayworldWBG_to_PtrOfWhiteBalancer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xphoto_LearningBasedWBG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xphoto_LearningBasedWBG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xphoto_LearningBasedWBG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xphoto_LearningBasedWBG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xphoto_LearningBasedWBG_to_PtrOfWhiteBalancer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xphoto_SimpleWBG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xphoto_SimpleWBG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xphoto_SimpleWBG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xphoto_SimpleWBG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xphoto_SimpleWBG_to_PtrOfWhiteBalancer(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xphoto_TonemapDurandG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xphoto_TonemapDurandG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xphoto_TonemapDurandG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xphoto_TonemapDurandG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xphoto_TonemapDurandG_to_PtrOfTonemap(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xphoto_WhiteBalancerG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xphoto_WhiteBalancerG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_xphoto_WhiteBalancerG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_xphoto_WhiteBalancerG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
	}
}
#[cfg(ocvrs_has_module_xphoto)]
pub use xphoto_sys::*;

pub use crate::manual::sys::*;
